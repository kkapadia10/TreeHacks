import { Preconditions, UnreachableError } from '../preconditions';
import { Deserialization } from '../serialization/deserialization';
let bootstrapCache = {};
let containerCache = {};
const bootstrapOverrides = typeof window !== 'undefined' && window.location
    ? getBootstrapOverridesFromUrlParams(window.location.search)
    : {};
export function loadFromWindow(key, deserializer, opts) {
    const applyOverrides = opts && opts.applyOverrides;
    const retainOnWindow = opts && opts.retainOnWindow;
    if (!(key in containerCache)) {
        const windowBootstrap = self['bootstrap'];
        if (!windowBootstrap) {
            throw new Error('Could not find bootstrap');
        }
        containerCache[key] = { ...windowBootstrap[key] };
        if (!retainOnWindow) {
            delete windowBootstrap[key];
        }
    }
    const container = containerCache;
    const overrides = applyOverrides && key in bootstrapOverrides ? bootstrapOverrides[key] : undefined;
    return loadFromBootstrapContainer(container, key, deserializer, overrides);
}
export function loadFromBootstrapContainer(container, key, deserializer, overrides) {
    if (key in bootstrapCache) {
        if (overrides == null && bootstrapCache[key] != null) {
            return bootstrapCache[key];
        }
    }
    if (overrides != null && overrides.size > 0) {
        overrides.forEach((v, k) => modify(container[key], k.split('.'), v));
    }
    const deserialization = Deserialization.requiredObject(deserializer, key, container);
    bootstrapCache[key] = overrides == null ? deserialization : undefined;
    return deserialization;
}
export function clearCacheForDevelopment() {
    bootstrapCache = {};
    containerCache = {};
}
export function urlParamPrefix(key) {
    return `bootstrap.${key}.`;
}
export function getBootstrapOverridesFromUrlParams(urlQuery) {
    const bootstrapOverrides = {};
    const keys = ['base', 'page', 'ui'];
    keys.forEach(key => {
        const params = getUrlParamsWithPrefix(urlQuery, urlParamPrefix(key));
        if (params.size > 0) {
            bootstrapOverrides[key] = params;
        }
    });
    return bootstrapOverrides;
}
function getUrlParamsWithPrefix(urlQuery, prefix) {
    urlQuery = urlQuery.substring(1);
    const params = new Map();
    const escapedPrefix = prefix.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
    const paramsRegex = new RegExp(`(${escapedPrefix}[^&=]+)=?([^&]*)`, 'g');
    const decodeComponent = (s) => decodeURIComponent(s.replace(/\+/g, ' '));
    let match;
    while ((match = paramsRegex.exec(urlQuery))) {
        const key = match[1].substring(prefix.length);
        params.set(decodeComponent(key), decodeComponent(match[2]));
    }
    return params;
}
function modify(blob, path, val) {
    let o = blob;
    let prop = path.shift();
    while (path.length) {
        if (!(prop in o)) {
            const isNumeral = String(Number(path[0])) === path[0];
            o[prop] = isNumeral ? [] : {};
        }
        o = o[prop];
        prop = path.shift();
    }
    o[prop] = coerce(val, o[prop]);
}
const magicBooleans = new Map([['', true], ['true', true], ['false', false]]);
const magicObjects = new Map([
    ['', undefined],
    ['null', null],
    ['undefined', undefined],
]);
export function coerce(s, hint) {
    const hintType = typeof hint;
    switch (hintType) {
        case 'undefined':
            if (s === '') {
                return true;
            }
            else if (magicBooleans.has(s)) {
                return magicBooleans.get(s);
            }
            else if (s.trim() !== '' && Number.isFinite(Number(s))) {
                return Number(s);
            }
            else if (magicObjects.has(s)) {
                return magicObjects.get(s);
            }
            else {
                return s;
            }
        case 'boolean':
            Preconditions.checkArgument(magicBooleans.has(s), 'boolean value expected: {}', s);
            return magicBooleans.get(s);
        case 'number':
            Preconditions.checkArgument(s.trim() !== '' && Number.isFinite(Number(s)), 'finite numeral expected: {}', s);
            return Number(s);
        case 'object':
            Preconditions.checkArgument(magicObjects.has(s), 'object value expected: {}', s);
            return magicObjects.get(s);
        case 'string':
            return s;
        case 'function':
        case 'bigint':
        case 'symbol':
            throw new Error(`unexpected hint type: ${hintType}`);
        default:
            throw new UnreachableError(hintType);
    }
}
