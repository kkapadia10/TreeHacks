import type { WireType } from './binary/constants';
import type { ReadBuffer } from './binary/read_buffer';
import type { WriteBuffer } from './binary/write_buffer';
export declare const enum FieldType {
    CONSTANT = 1,
    REQUIRED = 2,
    OPTIONAL = 3,
    REPEATED = 4,
    MAP = 5
}
export interface EnumUtil<T> {
    serialize: (enumValue: T) => string;
    serializeWithPath: (enumValue: T, path: string[]) => string;
    deserialize: (enumValue: any) => T;
    deserializeWithPath: (enumValue: any, path: string[]) => T;
    protobufSerialize(buffer: WriteBuffer, enumValue: T): void;
    protobufDeserialize(buffer: ReadBuffer): Promise<T>;
    producibleValues(): T[];
}
export declare const enum MessageType {
    CONCRETE = 1,
    ONE_OF = 2
}
export interface JsonKeyEncodings {
    primaryJsonKey: string;
    secondaryJsonKey?: string;
}
export interface JsonValueEncodings {
    primaryJsonValue: string;
    secondaryJsonValue?: string;
}
interface ConcreteMessageMetadata {
    fields: Record<string, FieldConfig<any>>;
    fieldsByTag: Record<number, FieldConfig<any> & {
        name: string;
    }>;
    fieldMetadata: FieldMetadatum[];
    constantsByTag: Record<number, Extract<FieldConfig<any>, {
        fieldType: FieldType.CONSTANT;
    }> & {
        name: string;
    }>;
}
export type FieldMetadatum = {
    config: FieldConfig<any>;
    name: string;
} & JsonKeyEncodings & Partial<JsonValueEncodings>;
export type MessageMetadata = ({
    type: MessageType.CONCRETE;
} & ConcreteMessageMetadata) | ({
    type: MessageType.ONE_OF;
    discriminatorKey: string;
    discriminatorTag: number;
    nameToObject: Map<string, InternalMessage<any>>;
    defaultObject?: InternalMessage<any>;
    discriminatorJsonKeyEncodings: JsonKeyEncodings;
    serializedToObject: Map<string, InternalMessage<any>>;
    tagToObject: Map<number, {
        Msg: InternalMessage<any>;
        value: string;
    }>;
} & ConcreteMessageMetadata);
export interface ExternalMessage<T> {
    serialize: (t: T) => object;
    deserialize: (serializedDatum: any) => T;
}
export interface InternalMessage<T> extends ExternalMessage<T> {
    init(): MessageMetadata;
    serializeWithPath: (t: T, path: string[]) => object;
    deserializeWithPath: (serializedDatum: any, path: string[]) => T;
    prototype?: object;
}
export type FieldConfig<T, U = T, W = T> = {
    tag: number;
    wireTag: Uint8Array;
    jsonFullKey?: string;
    default?: T;
    _constructorParam?: U;
    defaultValue?: T;
    typeOfValue: string;
} & ({
    fieldType: FieldType.OPTIONAL | FieldType.REPEATED | FieldType.REQUIRED;
    writeValue(encoder: WriteBuffer, value: W): void;
    readValue(buffer: ReadBuffer): Promise<W>;
    obj?: InternalMessage<any> | EnumUtil<any>;
} | {
    fieldType: FieldType.CONSTANT;
    jsonFullValue?: string;
    value: T;
    defaults: boolean;
    obj?: undefined;
} | {
    fieldType: FieldType.MAP;
    writeKey(encoder: WriteBuffer, value: T): void;
    readKey(buffer: ReadBuffer): Promise<T>;
    writeValue(encoder: WriteBuffer, value: W): void;
    readValue(buffer: ReadBuffer): Promise<W>;
    obj?: InternalMessage<any> | EnumUtil<any>;
    typeOfKey: string;
});
export interface Type<T> {
    typeOfValue: string;
    fixedSize?: number
    defaultValue?: T;
    wireType: WireType;
    writeValue(buffer: WriteBuffer, value: T): void;
    readValue(buffer: ReadBuffer): Promise<T>;
}
export type PropertyTypes<T extends Record<string, FieldConfig<any>>> = {
    [k in keyof T]: T[k] extends FieldConfig<infer U, any, any> ? U : never;
};
export declare class ProtobufError extends Error {
    constructor(message: string);
}
export {};
