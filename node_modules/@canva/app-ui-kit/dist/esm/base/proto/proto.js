import { memoize } from '../memoize';
import { UnreachableError } from '../preconditions';
import { WireType } from './binary/constants';
import { BinaryDecoder } from './binary/decode';
import { readProtobufFrom, readProtobufStream } from './binary/deserialize';
import { BinaryEncoder } from './binary/encode';
import { writeProtobufStream, writeProtobufTo } from './binary/serialize';
import { WriteBuffer } from './binary/write_buffer';
import { FieldType, MessageType } from './internal_types';
const makeType = t => t;
const ProtoType = {
  STRING: makeType({
    typeOfValue: 'string',
    wireType: WireType.DELIMITED,
    writeValue(b, v) {
      const populateSize = b.createSizeReservation();
      BinaryEncoder.writeString(b, v);
      populateSize();
    },
    readValue: async buffer => {
      await buffer.loadBytes(4);
      const size = BinaryDecoder.readUnsignedVarint32(buffer);
      await buffer.loadBytes(size, true);
      return BinaryDecoder.readString(buffer, size);
    }
  }),
  BOOLEAN: makeType({
    typeOfValue: 'boolean',
    defaultValue: false,
    fixedSize: 1,
    wireType: WireType.VARINT,
    writeValue: BinaryEncoder.writeBool,
    readValue: b => b.loadBytes(1, true).then(() => BinaryDecoder.readBool(b))
  }),
  DOUBLE: makeType({
    typeOfValue: 'number',
    defaultValue: 0,
    fixedSize: 8,
    wireType: WireType.FIXED64,
    writeValue: BinaryEncoder.writeDouble,
    readValue: b => b.loadBytes(8, true).then(() => BinaryDecoder.readDouble(b))
  }),
  INT32: makeType({
    typeOfValue: 'number',
    defaultValue: 0,
    wireType: WireType.VARINT,
    writeValue: BinaryEncoder.writeSignedVarint32,
    readValue: b => b.loadBytes(4).then(() => BinaryDecoder.readSignedVarint32(b))
  }),
  INT64: makeType({
    typeOfValue: 'number',
    defaultValue: 0,
    wireType: WireType.VARINT,
    writeValue: BinaryEncoder.writeSignedVarint64,
    readValue: b => b.loadBytes(8).then(() => BinaryDecoder.readSignedVarint64(b))
  })
};
function getWireTag(tag, wireType) {
  const writer = new WriteBuffer(8);
  BinaryEncoder.writeTag(writer, tag, wireType);
  return writer.flush();
}
function constantField(params) {
  const {
    tag,
    jsonFullKeyOrJsonMiniKey,
    jsonFullValue,
    value,
    defaults
  } = params;
  return {
    tag,
    wireTag: getWireTag(tag, WireType.DELIMITED),
    fieldType: FieldType.CONSTANT,
    jsonFullKey: jsonFullKeyOrJsonMiniKey === DISCRIMINATOR_JSON_MINI_KEY ?
    undefined :
    jsonFullKeyOrJsonMiniKey,
    jsonFullValue,
    value,
    defaults,
    typeOfValue: 'string'
  };
}
function requiredField(valueType, jsonFullKey, tag, def) {
  return {
    tag,
    wireTag: getWireTag(tag, valueType.wireType),
    fieldType: FieldType.REQUIRED,
    jsonFullKey,
    default: def != null ? def : valueType.defaultValue,
    writeValue: valueType.writeValue,
    readValue: valueType.readValue,
    defaultValue: valueType.defaultValue,
    typeOfValue: valueType.typeOfValue
  };
}
function optionalField(valueType, jsonFullKey, tag) {
  return {
    tag,
    wireTag: getWireTag(tag, valueType.wireType),
    fieldType: FieldType.OPTIONAL,
    jsonFullKey,
    writeValue: valueType.writeValue,
    readValue: valueType.readValue,
    defaultValue: valueType.defaultValue,
    typeOfValue: valueType.typeOfValue
  };
}
function repeatedField(valueType, jsonFullKey, tag) {
  return {
    tag,
    wireTag: getWireTag(tag, WireType.DELIMITED),
    fieldType: FieldType.REPEATED,
    jsonFullKey,
    writeValue: valueType.writeValue,
    readValue: valueType.readValue,
    typeOfValue: valueType.typeOfValue
  };
}
function mapField(keyType, valueType) {
  return (tagOrJsonFullKey, tagOrObj, maybeObj) => {
    const {
      tag,
      jsonFullKey,
      other1: obj
    } = getOptions(tagOrJsonFullKey, tagOrObj, maybeObj);
    let writeValue;
    let readValue;
    let typeOfValue;
    if (valueType === 'object') {
      writeValue = (b, v) => writeProtobufTo(obj, b, v);
      readValue = b => readProtobufFrom(obj, b);
      typeOfValue = 'object';
    } else if (valueType === 'enum') {
      writeValue = obj.protobufSerialize;
      readValue = obj.protobufDeserialize;
      typeOfValue = 'string';
    } else {
      writeValue = valueType.writeValue;
      readValue = valueType.readValue;
      typeOfValue = valueType.typeOfValue;
    }
    return {
      fieldType: FieldType.MAP,
      tag,
      wireTag: getWireTag(tag, WireType.DELIMITED),
      jsonFullKey,
      obj: obj,
      writeKey: keyType.writeValue,
      readKey: keyType.readValue,
      writeValue,
      readValue,
      typeOfKey: keyType.typeOfValue,
      typeOfValue
    };
  };
}
export class Proto {
  static constantString(jsonFullKeyOrJsonMiniKey, jsonFullValueOrTag, tagOrValue, maybeValue) {
    const {
      tag,
      jsonFullKey: jsonFullValue,
      other1: value
    } = getOptions(jsonFullValueOrTag, tagOrValue, maybeValue);
    return constantField({
      tag,
      jsonFullKeyOrJsonMiniKey,
      jsonFullValue,
      value,
      defaults: false
    });
  }
  static constantStringWithDefault(jsonFullKeyOrJsonMiniKey, jsonFullValueOrTag, tagOrValue, maybeValue) {
    const {
      tag,
      jsonFullKey: jsonFullValue,
      other1: value
    } = getOptions(jsonFullValueOrTag, tagOrValue, maybeValue);
    return constantField({
      tag,
      jsonFullKeyOrJsonMiniKey,
      jsonFullValue,
      value,
      defaults: true
    });
  }
  static requiredObject(tagOrJsonFullKey, tagOrObj, maybeObj) {
    const {
      tag,
      jsonFullKey,
      other1: obj
    } = getOptions(tagOrJsonFullKey, tagOrObj, maybeObj);
    return {
      tag,
      wireTag: getWireTag(tag, WireType.DELIMITED),
      fieldType: FieldType.REQUIRED,
      jsonFullKey,
      obj: obj,
      writeValue: (b, v) => writeProtobufTo(obj, b, v),
      readValue: d => readProtobufFrom(obj, d),
      typeOfValue: 'object'
    };
  }
  static optionalObject(tagOrJsonFullKey, tagOrObj, maybeObj) {
    const {
      tag,
      jsonFullKey,
      other1: obj
    } = getOptions(tagOrJsonFullKey, tagOrObj, maybeObj);
    return {
      tag,
      wireTag: getWireTag(tag, WireType.DELIMITED),
      fieldType: FieldType.OPTIONAL,
      jsonFullKey,
      obj: obj,
      writeValue: (b, v) => writeProtobufTo(obj, b, v),
      readValue: d => readProtobufFrom(obj, d),
      typeOfValue: 'object'
    };
  }
  static repeatedObject(tagOrJsonFullKey, tagOrObj, maybeObj) {
    const {
      tag,
      jsonFullKey,
      other1: obj
    } = getOptions(tagOrJsonFullKey, tagOrObj, maybeObj);
    return {
      tag,
      wireTag: getWireTag(tag, WireType.DELIMITED),
      fieldType: FieldType.REPEATED,
      jsonFullKey,
      obj: obj,
      writeValue: (b, v) => writeProtobufTo(obj, b, v),
      readValue: d => readProtobufFrom(obj, d),
      typeOfValue: 'object'
    };
  }
  static requiredStringEnum(tagOrJsonFullKey, tagOrObj, objOrDef, maybeDef) {
    const {
      tag,
      jsonFullKey,
      other1: obj,
      other2: def
    } = getOptions(tagOrJsonFullKey, tagOrObj, objOrDef, maybeDef);
    return {
      tag,
      wireTag: getWireTag(tag, WireType.VARINT),
      fieldType: FieldType.REQUIRED,
      jsonFullKey,
      obj,
      writeValue: obj.protobufSerialize,
      readValue: obj.protobufDeserialize,
      default: def,
      typeOfValue: 'string'
    };
  }
  static optionalStringEnum(tagOrJsonFullKey, tagOrObj, maybeObj) {
    const {
      tag,
      jsonFullKey,
      other1: obj
    } = getOptions(tagOrJsonFullKey, tagOrObj, maybeObj);
    return {
      tag,
      wireTag: getWireTag(tag, WireType.VARINT),
      fieldType: FieldType.OPTIONAL,
      jsonFullKey,
      obj,
      writeValue: obj.protobufSerialize,
      readValue: obj.protobufDeserialize,
      typeOfValue: 'string'
    };
  }
  static repeatedStringEnum(tagOrJsonFullKey, tagOrObj, maybeObj) {
    const {
      tag,
      jsonFullKey,
      other1: obj
    } = getOptions(tagOrJsonFullKey, tagOrObj, maybeObj);
    return {
      tag,
      wireTag: getWireTag(tag, WireType.VARINT),
      fieldType: FieldType.REPEATED,
      jsonFullKey,
      obj,
      writeValue: obj.protobufSerialize,
      readValue: obj.protobufDeserialize,
      typeOfValue: 'string'
    };
  }
  static createMessage(schema, options = {}) {
    const init = memoize(() => {
      const fields = schema();
      const fieldNames = Object.keys(fields);
      const fieldsByTag = {};
      const constantsByTag = {};
      for (const name of fieldNames) {
        const config = fields[name];
        switch (config.fieldType) {
          case FieldType.CONSTANT:
            constantsByTag[config.tag] = {
              ...config,
              name
            };
            break;
          case FieldType.REQUIRED:
          case FieldType.OPTIONAL:
          case FieldType.REPEATED:
          case FieldType.MAP:
            fieldsByTag[config.tag] = {
              ...config,
              name
            };
            break;
          default:
            throw new UnreachableError(config);
        }
      }
      return {
        type: MessageType.CONCRETE,
        fields,
        fieldMetadata: deriveFieldMetadata(fields, options.dualDeserializationConfig),
        fieldsByTag,
        constantsByTag
      };
    });
    class Message {
      constructor(opts = {}) {
        const {
          fieldMetadata
        } = init();
        for (const metadatum of fieldMetadata) {
          const {
            config: field,
            name: fieldName
          } = metadatum;
          const value = opts[fieldName];
          switch (field.fieldType) {
            case FieldType.CONSTANT:
              this[fieldName] = field.value;
              break;
            case FieldType.REQUIRED:
              this[fieldName] = value == null ? field.default : value;
              break;
            case FieldType.OPTIONAL:
              this[fieldName] = value;
              break;
            case FieldType.REPEATED:
              this[fieldName] = value == null ? [] : value;
              break;
            case FieldType.MAP:
              this[fieldName] = value == null ? new Map() : value;
              break;
            default:
              throw new UnreachableError(field);
          }
        }
      }
      static createUnchecked(opts = {}) {
        return new Message(opts);
      }
      static serialize(message) {
        return Message.serializeWithPath(message, []);
      }
      static deserialize(o) {
        return Message.deserializeWithPath(o, []);
      }
      static deserializeWithPath(o, path) {
        var _a;
        const {
          fieldMetadata
        } = init();
        const result = Object.create(Message.prototype);
        for (const metadatum of fieldMetadata) {
          const {
            config: field,
            name: fieldName,
            primaryJsonKey,
            secondaryJsonKey
          } = metadatum;
          let jsonKey = primaryJsonKey;
          let value = o[jsonKey];
          if (value == null && secondaryJsonKey != null && o[secondaryJsonKey] != null) {
            jsonKey = secondaryJsonKey;
            value = o[jsonKey];
          }
          switch (field.fieldType) {
            case FieldType.OPTIONAL:
              {
                if (value == null) {
                  result[fieldName] = undefined;
                  break;
                } else if (typeof value !== field.typeOfValue) {
                  const keyEncodings = {
                    primaryJsonKey,
                    secondaryJsonKey
                  };
                  throw makeOptionalTypeError(keyEncodings, value, field.typeOfValue, path);
                }
                path.push(jsonKey);
                result[fieldName] = field.obj ? field.obj.deserializeWithPath(value, path) : value;
                path.pop();
                break;
              }
            case FieldType.REQUIRED:
              {
                if (value == null && field.defaultValue != null) {
                  result[fieldName] = field.defaultValue;
                  break;
                } else if (value == null || typeof value !== field.typeOfValue) {
                  const keyEncodings = {
                    primaryJsonKey,
                    secondaryJsonKey
                  };
                  throw makeRequiredTypeError(keyEncodings, value, field.typeOfValue, path);
                }
                path.push(jsonKey);
                result[fieldName] = field.obj ? field.obj.deserializeWithPath(value, path) : value;
                path.pop();
                break;
              }
            case FieldType.CONSTANT:
              {
                const {
                  primaryJsonValue,
                  secondaryJsonValue
                } = metadatum;
                if (value == null && field.defaults) {
                  result[fieldName] = field.value;
                  break;
                }
                if (value === primaryJsonValue) {
                  result[fieldName] = field.value;
                  break;
                }
                if (secondaryJsonValue != null && value === secondaryJsonValue) {
                  result[fieldName] = field.value;
                  break;
                }
                const keyEncodings = {
                  primaryJsonKey,
                  secondaryJsonKey
                };
                const valueEncodings = {
                  primaryJsonValue: primaryJsonValue,
                  secondaryJsonValue
                };
                throw new TypeError(`Expected value ${expectedValues(valueEncodings)} for key ${expectedKeys(keyEncodings)} found: ${JSON.stringify(value)} ${pathTrace(path)}`);
              }
            case FieldType.REPEATED:
              {
                if (value == null) {
                  result[fieldName] = [];
                  break;
                } else if (!Array.isArray(value)) {
                  const keyEncodings = {
                    primaryJsonKey,
                    secondaryJsonKey
                  };
                  throw makeRepeatedTypeError(keyEncodings, value, field.typeOfValue, path);
                }
                const deserializeWithPath = (_a = field.obj) === null || _a === void 0 ? void 0 : _a.deserializeWithPath;
                if (deserializeWithPath) {
                  const values = new Array(value.length);
                  for (let j = 0; j < value.length; ++j) {
                    if (typeof value[j] !== field.typeOfValue) {
                      const keyEncodings = {
                        primaryJsonKey,
                        secondaryJsonKey
                      };
                      throw makeRequiredTypeError(keyEncodings, value[j], field.typeOfValue, [...path, jsonKey], j);
                    }
                    path.push(`${jsonKey}[${j}]`);
                    values[j] = deserializeWithPath(value[j], path);
                    path.pop();
                  }
                  result[fieldName] = values;
                } else {
                  for (let j = 0; j < value.length; ++j) {
                    if (typeof value[j] !== field.typeOfValue) {
                      const keyEncodings = {
                        primaryJsonKey,
                        secondaryJsonKey
                      };
                      throw makeRequiredTypeError(keyEncodings, value[j], field.typeOfValue, [...path, jsonKey], j);
                    }
                  }
                  result[fieldName] = value;
                }
                break;
              }
            case FieldType.MAP:
              {
                if (value == null) {
                  result[fieldName] = new Map();
                  break;
                } else if (typeof value !== 'object') {
                  const keyEncodings = {
                    primaryJsonKey,
                    secondaryJsonKey
                  };
                  throw new TypeError(`Expected Map for key ${expectedKeys(keyEncodings)}, found: ${JSON.stringify(value)} ${pathTrace(path)}`);
                }
                const isNumber = field.typeOfKey === 'number';
                const entries = Object.entries(value);
                const pairs = new Array(entries.length);
                for (let i = 0; i < entries.length; ++i) {
                  const [serializedKey, serializedValue] = entries[i];
                  let deserializedKey;
                  if (isNumber) {
                    deserializedKey = Number(serializedKey);
                    if (isNaN(deserializedKey)) {
                      throw new TypeError(`Expected number map key, found: ${JSON.stringify(serializedKey)} ${pathTrace([...path, jsonKey])}`);
                    }
                  } else {
                    deserializedKey = serializedKey;
                  }
                  if (typeof serializedValue !== field.typeOfValue) {
                    throw new TypeError(`Expected ${field.typeOfValue} map value for map key "${deserializedKey}", found: ${JSON.stringify(value[serializedKey])} ${pathTrace([...path, jsonKey])}`);
                  }
                  path.push(`${jsonKey}["${deserializedKey}"]`);
                  const deserializedValue = field.obj ? field.obj.deserializeWithPath(serializedValue, path) : value[serializedKey];
                  path.pop();
                  pairs[i] = [deserializedKey, deserializedValue];
                }
                result[fieldName] = new Map(pairs);
                break;
              }
            default:
              throw new UnreachableError(field);
          }
        }
        return result;
      }
    }
    Message.init = init;
    Message.serializeWithPath = options.unproducible ? (_message, path) => {
      throw new TypeError(`Unproducible oneof case ${pathTrace(path)}`);
    } : (message, path) => {
      var _a, _b;
      if (message == null || typeof message !== 'object') {
        throw new TypeError(`Expected type object, found: ${JSON.stringify(message)} ${pathTrace(path)}`);
      }
      const {
        fieldMetadata
      } = init();
      const res = {};
      for (const metadatum of fieldMetadata) {
        const {
          config: field,
          name: fieldName,
          primaryJsonKey
        } = metadatum;
        const value = message[fieldName];
        const jsonKey = primaryJsonKey;
        switch (field.fieldType) {
          case FieldType.CONSTANT:
            {
              if (value !== field.value) {
                throw new TypeError(`Expected value ${JSON.stringify(field.value)} for key "${primaryJsonKey}", found: ${JSON.stringify(value)} ${pathTrace(path)}`);
              }
              res[jsonKey] = metadatum.primaryJsonValue;
              break;
            }
          case FieldType.REQUIRED:
            {
              if (field.defaultValue != null && value === field.defaultValue) {
                break;
              }
              path.push(jsonKey);
              const serializedValue = field.obj ? field.obj.serializeWithPath(value, path) : value;
              path.pop();
              if (typeof serializedValue !== field.typeOfValue) {
                throw makeRequiredTypeError({
                  primaryJsonKey
                }, value, field.typeOfValue, path);
              }
              res[jsonKey] = serializedValue;
              break;
            }
          case FieldType.OPTIONAL:
            {
              if (value == null) {
                break;
              }
              path.push(jsonKey);
              const serializedValue = field.obj ? field.obj.serializeWithPath(value, path) : value;
              path.pop();
              if (typeof serializedValue !== field.typeOfValue) {
                throw makeOptionalTypeError({
                  primaryJsonKey
                }, value, field.typeOfValue, path);
              }
              res[jsonKey] = serializedValue;
              break;
            }
          case FieldType.REPEATED:
            {
              if (value == null) {
                break;
              } else if (!Array.isArray(value)) {
                throw makeRepeatedTypeError({
                  primaryJsonKey
                }, value, field.typeOfValue, path);
              } else if (value.length === 0) {
                break;
              }
              const serializeWithPath = (_a = field.obj) === null || _a === void 0 ? void 0 : _a.serializeWithPath;
              if (serializeWithPath) {
                const result = new Array(value.length);
                for (let i = 0; i < value.length; ++i) {
                  path.push(`${jsonKey}[${i}]`);
                  const serializedValue = serializeWithPath(value[i], path);
                  path.pop();
                  if (typeof serializedValue !== field.typeOfValue) {
                    throw makeRequiredTypeError({
                      primaryJsonKey
                    }, serializedValue, field.typeOfValue, [...path, jsonKey], i);
                  }
                  result[i] = serializedValue;
                }
                res[jsonKey] = result;
              } else {
                for (let i = 0; i < value.length; ++i) {
                  if (typeof value[i] !== field.typeOfValue) {
                    throw makeRequiredTypeError({
                      primaryJsonKey
                    }, value[i], field.typeOfValue, [...path, jsonKey], i);
                  }
                }
                res[jsonKey] = value;
              }
              break;
            }
          case FieldType.MAP:
            {
              if (!(value instanceof Map)) {
                throw new TypeError(`Expected Map for key "${primaryJsonKey}", found: ${JSON.stringify(value)} ${pathTrace(path)}`);
              } else if (value.size === 0) {
                break;
              }
              const map = {};
              const serializeWithPath = (_b = field.obj) === null || _b === void 0 ? void 0 : _b.serializeWithPath;
              for (const [key, mapValue] of value) {
                if (typeof key !== field.typeOfKey) {
                  throw new TypeError(`Expected ${field.typeOfKey} map key, found: ${JSON.stringify(key)} ${pathTrace([...path, jsonKey])}`);
                }
                path.push(`${jsonKey}["${key}"]`);
                const serializedValue = serializeWithPath ? serializeWithPath(mapValue, path) : mapValue;
                path.pop();
                if (typeof serializedValue !== field.typeOfValue) {
                  throw new TypeError(`Expected ${field.typeOfValue} map value for map key "${key}", found: ${JSON.stringify(serializedValue)} ${pathTrace([...path, jsonKey])}`);
                }
                map[key] = serializedValue;
              }
              res[jsonKey] = map;
              break;
            }
          default:
            throw new UnreachableError(field);
        }
      }
      return res;
    };
    return Message;
  }
  static createOneOf(schema, commonFields, options = {}) {
    const init = memoize(() => {
      const config = schema();
      const discriminatorKey = Object.keys(config)[0];
      let discriminatorTag;
      let discriminatorJsonKeyEncodings;
      const nameToObject = new Map();
      const serializedToObject = new Map();
      const tagToObject = new Map();
      for (let i = 0; i < config[discriminatorKey].length; i += 2) {
        const tag = config[discriminatorKey][i];
        const msg = config[discriminatorKey][i + 1];
        const msgFields = msg.init().fields;
        const discriminator = msgFields[discriminatorKey];
        if (!discriminator) {
          throw new TypeError(`Missing discriminator.`);
        }
        if (discriminator.fieldType !== FieldType.CONSTANT) {
          throw new TypeError(`Discriminator must be FieldType.CONSTANT, was ${discriminator.fieldType}.}`);
        }
        const caseDiscriminatorJsonKeyEncodings = choosePrimaryAndSecondaryJSONFromConfig(DISCRIMINATOR_JSON_MINI_KEY, discriminator.jsonFullKey, options.dualDeserializationConfig);
        const {
          primary: primaryJsonValue,
          secondary: secondaryJsonValue
        } = choosePrimaryAndSecondaryJSONFromConfig(toJsonMini(tag - 1), discriminator.jsonFullValue, options.dualDeserializationConfig);
        tagToObject.set(tag, {
          Msg: msg,
          value: discriminator.value
        });
        nameToObject.set(discriminator.value, msg);
        serializedToObject.set(primaryJsonValue, msg);
        if (secondaryJsonValue) {
          serializedToObject.set(secondaryJsonValue, msg);
        }
        if (discriminatorJsonKeyEncodings && discriminatorJsonKeyEncodings.primaryJsonKey !== caseDiscriminatorJsonKeyEncodings.primary) {
          throw new TypeError(`oneOf JSON keys are not consistent. ${discriminatorJsonKeyEncodings.primaryJsonKey} ${caseDiscriminatorJsonKeyEncodings.primary}`);
        }
        if (discriminatorJsonKeyEncodings && discriminatorJsonKeyEncodings.secondaryJsonKey !== caseDiscriminatorJsonKeyEncodings.secondary) {
          throw new TypeError(`oneOf secondary JSON keys are not consistent. ${discriminatorJsonKeyEncodings.secondaryJsonKey} ${caseDiscriminatorJsonKeyEncodings.secondary}`);
        }
        discriminatorTag = discriminator.tag;
        const {
          primary: primaryJsonKey,
          secondary: secondaryJsonKey
        } = caseDiscriminatorJsonKeyEncodings;
        discriminatorJsonKeyEncodings = {
          primaryJsonKey,
          secondaryJsonKey
        };
      }
      if (discriminatorJsonKeyEncodings == null || discriminatorTag == null) {
        throw new TypeError('OneOf has no cases.');
      }
      const fields = commonFields();
      const fieldNames = Object.keys(fields);
      const fieldsByTag = {};
      for (const name of fieldNames) {
        fieldsByTag[fields[name].tag] = {
          ...fields[name],
          name
        };
      }
      const defaultObject = options.defaultCase != null ? options.defaultCase() : undefined;
      return {
        type: MessageType.ONE_OF,
        fieldMetadata: deriveFieldMetadata(fields, options.dualDeserializationConfig),
        discriminatorKey,
        nameToObject,
        discriminatorTag,
        discriminatorJsonKeyEncodings,
        serializedToObject,
        defaultObject,
        fields,
        fieldsByTag,
        constantsByTag: {},
        tagToObject
      };
    });
    const serializeWithPath = (t, path) => {
      const {
        discriminatorKey,
        nameToObject
      } = init();
      const type = t[discriminatorKey];
      const obj = nameToObject.get(type);
      if (!obj) {
        throw new TypeError(`Unknown oneof deserialized case: ${JSON.stringify(type)} ${pathTrace(path)}`);
      }
      return obj.serializeWithPath(t, path);
    };
    const deserializeWithPath = (o, path) => {
      const {
        serializedToObject,
        discriminatorJsonKeyEncodings,
        defaultObject
      } = init();
      const {
        primaryJsonKey,
        secondaryJsonKey
      } = discriminatorJsonKeyEncodings;
      let type = o[primaryJsonKey];
      if (type == null && secondaryJsonKey) {
        type = o[secondaryJsonKey];
      }
      if (type == null && defaultObject) {
        return defaultObject.deserializeWithPath(o, path);
      }
      const obj = serializedToObject.get(type);
      if (!obj) {
        throw new TypeError(`Unknown oneof serialized case: ${JSON.stringify(type)} ${pathTrace(path)}`);
      }
      return obj.deserializeWithPath(o, path);
    };
    return {
      init,
      serialize: t => serializeWithPath(t, []),
      serializeWithPath,
      deserialize: o => deserializeWithPath(o, []),
      deserializeWithPath
    };
  }
  static createEnumUtil(schema, baseNumber = 0, options = {}) {
    const init = memoize(() => {
      const config = schema();
      const values = [];
      const serializedToValue = new Map();
      const valueToSerialized = new Map();
      const valueToProtobufSerialized = new Map();
      const protobufSerializedToValue = new Map();
      const unproducible = new Set();
      let i = 0;
      let index = 1;
      while (i < config.length) {
        const value = index++;
        const protobufSerialized = config[i];
        const jsonMiniValue = toJsonMini(protobufSerialized - baseNumber);
        i += 1;
        let jsonFullValue;
        const maybeJsonFullValue = config[i];
        if (typeof maybeJsonFullValue === 'string') {
          jsonFullValue = maybeJsonFullValue;
          i += 1;
        }
        const {
          primary: primaryJsonValue,
          secondary: secondaryJsonValue
        } = choosePrimaryAndSecondaryJSONFromConfig(jsonMiniValue, jsonFullValue, options.dualDeserializationConfig);
        const maybeOptions = config[i];
        if (typeof maybeOptions === 'object' && maybeOptions.unproducible) {
          unproducible.add(value);
          i += 1;
        }
        values.push(value);
        serializedToValue.set(primaryJsonValue, value);
        if (secondaryJsonValue) {
          serializedToValue.set(secondaryJsonValue, value);
        }
        valueToSerialized.set(value, primaryJsonValue);
        valueToProtobufSerialized.set(value, protobufSerialized);
        protobufSerializedToValue.set(protobufSerialized, value);
      }
      return {
        values,
        valueToSerialized,
        valueToProtobufSerialized,
        protobufSerializedToValue,
        serializedToValue,
        unproducible: unproducible.size ? unproducible : undefined
      };
    });
    const getSerialized = (value, map, path) => {
      const {
        unproducible
      } = init();
      if (unproducible && unproducible.has(value)) {
        throw new TypeError(`Unproducible enum value: ${JSON.stringify(value)} ${path ? pathTrace(path) : ''}`);
      }
      const serialized = map.get(value);
      if (serialized == null) {
        throw new TypeError(`Unrecognized deserialized enum value: ${JSON.stringify(value)} ${path ? pathTrace(path) : ''}`);
      }
      return serialized;
    };
    const deserializeWithPath = (jsonValue, path) => {
      const value = init().serializedToValue.get(jsonValue);
      if (value == null) {
        throw new TypeError(`Unrecognized serialized enum value: ${JSON.stringify(jsonValue)} ${pathTrace(path)}`);
      }
      return value;
    };
    return {
      values: () => init().values,
      producibleValues: () => {
        const {
          values,
          unproducible
        } = init();
        if (unproducible == null) {
          return values;
        }
        return values.filter(value => !unproducible.has(value));
      },
      serialize: value => {
        return getSerialized(value, init().valueToSerialized, []);
      },
      serializeWithPath: (value, path) => {
        return getSerialized(value, init().valueToSerialized, path);
      },
      deserialize: jsonValue => {
        return deserializeWithPath(jsonValue, []);
      },
      deserializeWithPath,
      protobufSerialize: (buffer, value) => {
        BinaryEncoder.writeEnum(buffer, getSerialized(value, init().valueToProtobufSerialized));
      },
      async protobufDeserialize(buffer) {
        const {
          protobufSerializedToValue
        } = init();
        await buffer.loadBytes(4);
        return protobufSerializedToValue.get(BinaryDecoder.readEnum(buffer));
      }
    };
  }
}
Proto.requiredDouble = (a, b, c) => {
  const {
    tag,
    jsonFullKey,
    other1
  } = getOptions(a, b, c);
  return requiredField(ProtoType.DOUBLE, jsonFullKey, tag, other1);
};
Proto.requiredInt32 = (a, b, c) => {
  const {
    tag,
    jsonFullKey,
    other1
  } = getOptions(a, b, c);
  return requiredField(ProtoType.INT32, jsonFullKey, tag, other1);
};
Proto.requiredInt64 = (a, b, c) => {
  const {
    tag,
    jsonFullKey,
    other1
  } = getOptions(a, b, c);
  return requiredField(ProtoType.INT64, jsonFullKey, tag, other1);
};
Proto.optionalDouble = (a, b) => {
  const {
    tag,
    jsonFullKey
  } = getOptions(a, b);
  return optionalField(ProtoType.DOUBLE, jsonFullKey, tag);
};
Proto.optionalInt32 = (a, b) => {
  const {
    tag,
    jsonFullKey
  } = getOptions(a, b);
  return optionalField(ProtoType.INT32, jsonFullKey, tag);
};
Proto.optionalInt64 = (a, b) => {
  const {
    tag,
    jsonFullKey
  } = getOptions(a, b);
  return optionalField(ProtoType.INT64, jsonFullKey, tag);
};
Proto.repeatedDouble = (a, b) => {
  const {
    tag,
    jsonFullKey
  } = getOptions(a, b);
  return repeatedField(ProtoType.DOUBLE, jsonFullKey, tag);
};
Proto.repeatedInt32 = (a, b) => {
  const {
    tag,
    jsonFullKey
  } = getOptions(a, b);
  return repeatedField(ProtoType.INT32, jsonFullKey, tag);
};
Proto.repeatedInt64 = (a, b) => {
  const {
    tag,
    jsonFullKey
  } = getOptions(a, b);
  return repeatedField(ProtoType.INT64, jsonFullKey, tag);
};
Proto.requiredString = (a, b, c) => {
  const {
    tag,
    jsonFullKey,
    other1
  } = getOptions(a, b, c);
  return requiredField(ProtoType.STRING, jsonFullKey, tag, other1);
};
Proto.optionalString = (a, b) => {
  const {
    tag,
    jsonFullKey
  } = getOptions(a, b);
  return optionalField(ProtoType.STRING, jsonFullKey, tag);
};
Proto.repeatedString = (a, b) => {
  const {
    tag,
    jsonFullKey
  } = getOptions(a, b);
  return repeatedField(ProtoType.STRING, jsonFullKey, tag);
};
Proto.requiredBoolean = (a, b, c) => {
  const {
    tag,
    jsonFullKey,
    other1
  } = getOptions(a, b, c);
  return requiredField(ProtoType.BOOLEAN, jsonFullKey, tag, other1);
};
Proto.optionalBoolean = (a, b) => {
  const {
    tag,
    jsonFullKey
  } = getOptions(a, b);
  return optionalField(ProtoType.BOOLEAN, jsonFullKey, tag);
};
Proto.repeatedBoolean = (a, b) => {
  const {
    tag,
    jsonFullKey
  } = getOptions(a, b);
  return repeatedField(ProtoType.BOOLEAN, jsonFullKey, tag);
};
Proto.int32Int32Map = mapField(ProtoType.INT32, ProtoType.INT32);
Proto.int32Int64Map = mapField(ProtoType.INT32, ProtoType.INT64);
Proto.int32BoolMap = mapField(ProtoType.INT32, ProtoType.BOOLEAN);
Proto.int32DoubleMap = mapField(ProtoType.INT32, ProtoType.DOUBLE);
Proto.int32StringMap = mapField(ProtoType.INT32, ProtoType.STRING);
Proto.int32StringEnumMap = mapField(ProtoType.INT32, 'enum');
Proto.int32ObjectMap = mapField(ProtoType.INT32, 'object');
Proto.int64Int32Map = mapField(ProtoType.INT64, ProtoType.INT32);
Proto.int64Int64Map = mapField(ProtoType.INT64, ProtoType.INT64);
Proto.int64BoolMap = mapField(ProtoType.INT64, ProtoType.BOOLEAN);
Proto.int64DoubleMap = mapField(ProtoType.INT64, ProtoType.DOUBLE);
Proto.int64StringMap = mapField(ProtoType.INT64, ProtoType.STRING);
Proto.int64StringEnumMap = mapField(ProtoType.INT64, 'enum');
Proto.int64ObjectMap = mapField(ProtoType.INT64, 'object');
Proto.doubleInt32Map = mapField(ProtoType.DOUBLE, ProtoType.INT32);
Proto.doubleInt64Map = mapField(ProtoType.DOUBLE, ProtoType.INT64);
Proto.doubleBoolMap = mapField(ProtoType.DOUBLE, ProtoType.BOOLEAN);
Proto.doubleDoubleMap = mapField(ProtoType.DOUBLE, ProtoType.DOUBLE);
Proto.doubleStringMap = mapField(ProtoType.DOUBLE, ProtoType.STRING);
Proto.doubleStringEnumMap = mapField(ProtoType.DOUBLE, 'enum');
Proto.doubleObjectMap = mapField(ProtoType.DOUBLE, 'object');
Proto.stringInt32Map = mapField(ProtoType.STRING, ProtoType.INT32);
Proto.stringInt64Map = mapField(ProtoType.STRING, ProtoType.INT64);
Proto.stringBooleanMap = mapField(ProtoType.STRING, ProtoType.BOOLEAN);
Proto.stringDoubleMap = mapField(ProtoType.STRING, ProtoType.DOUBLE);
Proto.stringStringMap = mapField(ProtoType.STRING, ProtoType.STRING);
Proto.stringStringEnumMap = mapField(ProtoType.STRING, 'enum');
Proto.stringObjectMap = mapField(ProtoType.STRING, 'object');
Proto.writeProtobufStream = writeProtobufStream;
Proto.readProtobufStream = readProtobufStream;
function deriveFieldMetadata(fields, dualDeserializationConfig) {
  return Object.entries(fields).map(([name, config]) => {
    var _a, _b;
    const fieldEncodings = deriveFieldEncodings(config, dualDeserializationConfig);
    return {
      config,
      name,
      primaryJsonKey: fieldEncodings.keyEncodings.primaryJsonKey,
      secondaryJsonKey: fieldEncodings.keyEncodings.secondaryJsonKey,
      primaryJsonValue: (_a = fieldEncodings.valueEncodings) === null || _a === void 0 ? void 0 : _a.primaryJsonValue,
      secondaryJsonValue: (_b = fieldEncodings.valueEncodings) === null || _b === void 0 ? void 0 : _b.secondaryJsonValue
    };
  });
}
function deriveFieldEncodings(fieldConfig, dualDeserializationConfig) {
  let valueEncodings;
  let jsonMiniKey = toJsonMini(fieldConfig.tag - 1);
  if (fieldConfig.fieldType === FieldType.CONSTANT) {
    const {
      primary: primaryJsonValue,
      secondary: secondaryJsonValue
    } = choosePrimaryAndSecondaryJSONFromConfig(jsonMiniKey, fieldConfig.jsonFullValue, dualDeserializationConfig);
    jsonMiniKey = DISCRIMINATOR_JSON_MINI_KEY;
    valueEncodings = {
      primaryJsonValue,
      secondaryJsonValue
    };
  }
  const {
    primary: primaryJsonKey,
    secondary: secondaryJsonKey
  } = choosePrimaryAndSecondaryJSONFromConfig(jsonMiniKey, fieldConfig.jsonFullKey, dualDeserializationConfig);
  const keyEncodings = {
    primaryJsonKey,
    secondaryJsonKey
  };
  return {
    keyEncodings,
    valueEncodings
  };
}
function choosePrimaryAndSecondaryJSONFromConfig(jsonMini, jsonFull, dualDeserializationConfig) {
  if (!jsonFull) {
    if (dualDeserializationConfig !== undefined) {
      throw new Error("Dual Deserialization config templated but JSON full key/value wasn't");
    }
    return {
      primary: jsonMini
    };
  }
  if (dualDeserializationConfig === undefined) {
    return {
      primary: jsonFull
    };
  } else if (dualDeserializationConfig === DualDeserializationConfig.MINI_PRIMARY_FULL_SECONDARY) {
    return {
      primary: jsonMini,
      secondary: jsonFull
    };
  } else if (dualDeserializationConfig === DualDeserializationConfig.FULL_PRIMARY_MINI_SECONDARY) {
    return {
      primary: jsonFull,
      secondary: jsonMini
    };
  }
  throw new Error("function should have been exhaustive, but wasn't");
}
function makeRepeatedTypeError(keyEncodings, value, expectedType, path) {
  return new TypeError(`Expected repeated ${expectedType} value for key ${expectedKeys(keyEncodings)}, found: ${JSON.stringify(value)} ${pathTrace(path)}`);
}
function makeOptionalTypeError(keyEncodings, value, expectedType, path) {
  return new TypeError(`Expected optional ${expectedType} value for key ${expectedKeys(keyEncodings)}, found: ${JSON.stringify(value)} ${pathTrace(path)}`);
}
function makeRequiredTypeError(keyEncodings, value, expectedType, path, index) {
  const atIndex = index !== undefined ? ` at index ${index}` : '';
  return new TypeError(`Expected ${expectedType} value${atIndex} for key ${expectedKeys(keyEncodings)}, found: ${JSON.stringify(value)} ${pathTrace(path)}`);
}
function expectedKeys(keyEncodings) {
  const {
    primaryJsonKey,
    secondaryJsonKey
  } = keyEncodings;
  if (secondaryJsonKey) {
    return `either "${primaryJsonKey}" OR "${secondaryJsonKey}"`;
  }
  return `"${primaryJsonKey}"`;
}
function expectedValues(valueEncodings) {
  const {
    primaryJsonValue,
    secondaryJsonValue
  } = valueEncodings;
  if (secondaryJsonValue) {
    return `either "${primaryJsonValue}" OR "${secondaryJsonValue}"`;
  }
  return `"${primaryJsonValue}"`;
}
function pathTrace(path) {
  return `(path: .${path.join('.')})`;
}
export { ProtobufError } from './internal_types';
export const DualDeserializationConfig = {
  MINI_PRIMARY_FULL_SECONDARY: 0,
  FULL_PRIMARY_MINI_SECONDARY: 1
};
const DISCRIMINATOR_JSON_MINI_KEY = 'A?';
const JSON_MINI_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';
function toJsonMini(x) {
  if (x < JSON_MINI_ALPHABET.length) {
    return JSON_MINI_ALPHABET.charAt(x);
  } else {
    const builder = [];
    while (x > 0) {
      builder.push(JSON_MINI_ALPHABET.charAt(x % JSON_MINI_ALPHABET.length));
      x = Math.floor(x / JSON_MINI_ALPHABET.length);
    }
    return builder.reverse().join('');
  }
}
function getOptions(tagOrJsonFullKey, tagOrOther1, other1OrOther2, maybeOther2) {
  if (typeof tagOrJsonFullKey === 'string') {
    return {
      jsonFullKey: tagOrJsonFullKey,
      tag: tagOrOther1,
      other1: other1OrOther2,
      other2: maybeOther2
    };
  } else {
    return {
      tag: tagOrJsonFullKey,
      other1: tagOrOther1,
      other2: other1OrOther2
    };
  }
}