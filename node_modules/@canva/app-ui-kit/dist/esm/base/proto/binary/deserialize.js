import { UnreachableError } from '../../preconditions';
import { FieldType, MessageType } from '../internal_types';
import { WireType } from './constants';
import { BinaryDecoder } from './decode';
import { ReadBuffer } from './read_buffer';
export async function readProtobufStream(Msg, stream) {
    return readProtobufFrom(Msg, new ReadBuffer(stream));
}
export async function readProtobufFrom(Msg, buffer) {
    let metaData = Msg.init();
    const values = {};
    await buffer.loadBytes(4);
    const size = BinaryDecoder.readUnsignedVarint32(buffer);
    const bufferEnd = buffer.bytesRead + size;
    while (buffer.bytesRead < bufferEnd) {
        await buffer.loadBytes(4);
        const { tag, wireType } = BinaryDecoder.readTag(buffer);
        if (metaData.type === MessageType.ONE_OF && metaData.tagToObject.has(tag)) {
            Msg = metaData.tagToObject.get(tag).Msg;
            metaData = Msg.init();
        }
        const constConfig = metaData.constantsByTag[tag];
        if (constConfig && values[constConfig.name] == null) {
            BinaryDecoder.readUnsignedVarint32(buffer);
            values[constConfig.name] = constConfig.value;
            continue;
        }
        const fieldConfig = metaData.fieldsByTag[tag];
        if (!fieldConfig) {
            consumeMissingField(wireType, buffer);
        }
        else {
            values[fieldConfig.name] = await readField(fieldConfig, buffer);
        }
    }
    for (const { name: fieldName, config: field } of metaData.fieldMetadata) {
        if (values[fieldName] != null) {
            continue;
        }
        switch (field.fieldType) {
            case FieldType.OPTIONAL:
                break;
            case FieldType.REQUIRED:
                if (field.defaultValue == null) {
                    throw new TypeError(`expected ${field.typeOfValue} for property "${fieldName}" with tag "${field.tag}", but it was not present.`);
                }
                values[fieldName] = field.defaultValue;
                break;
            case FieldType.MAP:
                values[fieldName] = new Map();
                break;
            case FieldType.REPEATED:
                values[fieldName] = [];
                break;
            case FieldType.CONSTANT:
                if (!field.defaults) {
                    throw new TypeError(`expected discriminator for property "${fieldName}" with tag "${field.tag}", but it was not present.`);
                }
                values[fieldName] = field.value;
                break;
            default:
                throw new UnreachableError(field);
        }
    }
    return Object.assign(Object.create(Msg.prototype), values);
}
async function readField(fieldConfig, buffer) {
    switch (fieldConfig.fieldType) {
        case FieldType.OPTIONAL:
        case FieldType.REQUIRED:
            return fieldConfig.readValue(buffer);
        case FieldType.REPEATED:
            await buffer.loadBytes(4);
            const listSize = BinaryDecoder.readUnsignedVarint32(buffer);
            const listEnd = buffer.bytesRead + listSize;
            const array = [];
            while (buffer.bytesRead < listEnd) {
                array.push(await fieldConfig.readValue(buffer));
            }
            return array;
        case FieldType.MAP:
            await buffer.loadBytes(4);
            const mapSize = BinaryDecoder.readUnsignedVarint32(buffer);
            const mapEnd = buffer.bytesRead + mapSize;
            const map = new Map();
            while (buffer.bytesRead < mapEnd) {
                map.set(await fieldConfig.readKey(buffer), await fieldConfig.readValue(buffer));
            }
            return map;
        case FieldType.CONSTANT:
            throw new Error();
        default:
            throw new UnreachableError(fieldConfig);
    }
}
function consumeMissingField(wireType, buffer) {
    switch (wireType) {
        case WireType.INVALID:
            throw new Error('Invalid WireType');
        case WireType.VARINT:
            while (buffer.read() >= 128) {}
            break;
        case WireType.FIXED64:
            for (let i = 0; i < 8; ++i) {
                buffer.read();
            }
            break;
        case WireType.DELIMITED:
            const size = BinaryDecoder.readUnsignedVarint32(buffer);
            for (let i = 0; i < size; ++i) {
                buffer.read();
            }
            break;
        default:
            throw new UnreachableError(wireType);
    }
}
