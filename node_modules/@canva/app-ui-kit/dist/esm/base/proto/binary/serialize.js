import { UnreachableError } from '../../preconditions';
import { FieldType, MessageType } from '../internal_types';
import { WriteBuffer } from './write_buffer';
export function writeProtobufStream(Msg, message, bufferSize = 512) {
    const encoder = new WriteBuffer(bufferSize);
    writeProtobufTo(Msg, encoder, message);
    return new ReadableStream({
        start(controller) {
            controller.enqueue(encoder.flush());
            controller.close();
        },
    });
}
export function writeProtobufTo(InitialMsg, buffer, message) {
    const initData = InitialMsg.init();
    if (initData.type === MessageType.ONE_OF) {
        const type = message[initData.discriminatorKey];
        const CaseMsg = initData.nameToObject.get(type);
        if (!CaseMsg) {
            throw new TypeError(`Unknown oneof deserialized case ${type}.`);
        }
        writeProtobufTo(CaseMsg, buffer, message);
        return;
    }
    const populateSize = buffer.createSizeReservation();
    let oneOfReservedSize;
    for (const { name: fieldName, config: fieldConfig } of initData.fieldMetadata) {
        const value = message[fieldName];
        switch (fieldConfig.fieldType) {
            case FieldType.OPTIONAL:
                if (value == null) {
                    break;
                }
                buffer.writeBytes(fieldConfig.wireTag);
                fieldConfig.writeValue(buffer, value);
                break;
            case FieldType.REQUIRED:
                if (value == null || fieldConfig.defaultValue === value) {
                    break;
                }
                buffer.writeBytes(fieldConfig.wireTag);
                fieldConfig.writeValue(buffer, value);
                break;
            case FieldType.REPEATED: {
                if (!value.length) {
                    break;
                }
                buffer.writeBytes(fieldConfig.wireTag);
                const populateFieldSize = buffer.createSizeReservation();
                for (let i = 0; i < value.length; ++i) {
                    fieldConfig.writeValue(buffer, value[i]);
                }
                populateFieldSize();
                break;
            }
            case FieldType.CONSTANT:
                buffer.writeBytes(fieldConfig.wireTag);
                oneOfReservedSize = buffer.createSizeReservation();
                break;
            case FieldType.MAP: {
                if (!value.size) {
                    break;
                }
                buffer.writeBytes(fieldConfig.wireTag);
                const populateFieldSize = buffer.createSizeReservation();
                for (const [key, val] of value) {
                    fieldConfig.writeKey(buffer, key);
                    fieldConfig.writeValue(buffer, val);
                }
                populateFieldSize();
                break;
            }
            default:
                throw new UnreachableError(fieldConfig);
        }
    }
    oneOfReservedSize === null || oneOfReservedSize === void 0 ? void 0 : oneOfReservedSize();
    populateSize();
}
