import { TypeDeserializer } from './type_deserializer';
export class Deserialization {
    static checkObject(val) {
        if (!Deserialization.isObject(val)) {
            throw new TypeError(`expected an object, found: ${val}`);
        }
        return val;
    }
    static requiredNumber(name, serializedData) {
        return TypeDeserializer.NUMBER.optional(name, serializedData) || 0;
    }
    static repeatedNumber(name, serializedData) {
        return TypeDeserializer.NUMBER.repeated(name, serializedData);
    }
    static optionalNumber(name, serializedData) {
        return TypeDeserializer.NUMBER.optional(name, serializedData);
    }
    static requiredString(name, serializedData) {
        return TypeDeserializer.STRING.required(name, serializedData);
    }
    static optionalString(name, serializedData) {
        return TypeDeserializer.STRING.optional(name, serializedData);
    }
    static repeatedString(name, serializedData) {
        return TypeDeserializer.STRING.repeated(name, serializedData);
    }
    static requiredBoolean(name, serializedData) {
        return TypeDeserializer.BOOLEAN.optional(name, serializedData) || false;
    }
    static optionalBoolean(name, serializedData) {
        return TypeDeserializer.BOOLEAN.optional(name, serializedData);
    }
    static repeatedBoolean(name, serializedData) {
        return TypeDeserializer.BOOLEAN.repeated(name, serializedData);
    }
    static requiredObject(deserialize, name, serializedData) {
        return deserialize(TypeDeserializer.OBJECT.required(name, serializedData));
    }
    static optionalObject(deserialize, name, serializedData) {
        const c = TypeDeserializer.OBJECT.optional(name, serializedData);
        return c ? deserialize(c) : c;
    }
    static repeatedObject(deserialize, name, serializedData) {
        const cs = TypeDeserializer.OBJECT.repeated(name, serializedData);
        return cs ? cs.map(deserialize) : cs;
    }
    static requiredStringEnum(deserialize, name, serializedData) {
        return deserialize(TypeDeserializer.STRING.required(name, serializedData));
    }
    static optionalStringEnum(deserialize, name, serializedData) {
        const s = TypeDeserializer.STRING.optional(name, serializedData);
        return s != null ? deserialize(s) : s;
    }
    static repeatedStringEnum(deserialize, name, serializedData) {
        const ss = TypeDeserializer.STRING.repeated(name, serializedData);
        return ss != null ? ss.map(deserialize) : ss;
    }
    static numberObjectMap(deserialize, name, serializedData) {
        return Deserialization.map(Deserialization.numberMapKey, (name, key, data) => Deserialization.objectMapValue(deserialize, name, key, data), name, serializedData);
    }
    static stringNumberMap(name, serializedData) {
        return Deserialization.map(Deserialization.stringMapKey, Deserialization.numberMapValue, name, serializedData);
    }
    static stringObjectMap(deserialize, name, serializedData) {
        return Deserialization.map(Deserialization.stringMapKey, (name, key, data) => Deserialization.objectMapValue(deserialize, name, key, data), name, serializedData);
    }
    static stringEnumMap(deserialize, name, serializedData) {
        return Deserialization.map(Deserialization.stringMapKey, (name, key, data) => Deserialization.enumMapValue(deserialize, name, key, data), name, serializedData);
    }
    static stringStringMap(name, serializedData) {
        return Deserialization.map(Deserialization.stringMapKey, Deserialization.stringMapValue, name, serializedData);
    }
    static numberNumberMap(name, serializedData) {
        return Deserialization.map(Deserialization.numberMapKey, Deserialization.numberMapValue, name, serializedData);
    }
    static numberStringMap(name, serializedData) {
        return Deserialization.map(Deserialization.numberMapKey, Deserialization.stringMapValue, name, serializedData);
    }
    static map(deserializeKey, deserializeValue, name, serializedData) {
        const val = serializedData[name];
        if (val == null) {
            return undefined;
        }
        else if (typeof val !== 'object') {
            throw new TypeError(`expected map for property "${name}", found: ${JSON.stringify(val)}`);
        }
        else {
            const m = new Map();
            for (const serializedKey of Object.keys(val)) {
                m.set(deserializeKey(name, serializedKey), deserializeValue(name, serializedKey, val));
            }
            return m;
        }
    }
    static numberMapKey(name, serializedKey) {
        const key = Number(serializedKey);
        if (isNaN(key)) {
            throw new TypeError(`expected number key in property "${name}", found: ${serializedKey}`);
        }
        return key;
    }
    static stringMapKey(name, serializedKey) {
        return serializedKey;
    }
    static numberMapValue(name, serializedKey, serializedData) {
        const val = serializedData[serializedKey];
        if (typeof val !== 'number') {
            throw new TypeError(`expected number value in property "${name}", found: ${JSON.stringify(val)}`);
        }
        return val;
    }
    static objectMapValue(deserialize, name, serializedKey, serializedData) {
        const val = serializedData[serializedKey];
        if (!Deserialization.isObject(val)) {
            throw new TypeError(`expected object value in property "${name}", found: ${JSON.stringify(val)}`);
        }
        return deserialize(val);
    }
    static stringMapValue(name, serializedKey, serializedData) {
        const val = serializedData[serializedKey];
        if (typeof val !== 'string') {
            throw new TypeError(`expected string value in property "${name}", found: ${JSON.stringify(val)}`);
        }
        return val;
    }
    static enumMapValue(deserialize, name, serializedKey, serializedData) {
        const val = serializedData[serializedKey];
        if (typeof val !== 'string') {
            throw new TypeError(`expected string value in property "${name}", found: ${JSON.stringify(val)}`);
        }
        return deserialize(val);
    }
    static isObject(o) {
        return o != null && typeof o === 'object';
    }
}
