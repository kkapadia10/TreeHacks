import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import classNames from 'classnames';
import * as React from 'react';
import { BasicButton } from '../../../../../../../base/button/button';
import { CardImageThumbnail } from '../../../../../../../base/card/card';
import { AlertTriangleIcon, MusicIcon, PauseIcon, PlayFilledIcon } from '../../../../icons/icons';
import { AudioCardMessages as Messages } from '../audio.messages';
import { AudioContext } from '../audio_context';
import styles from './audio_cover.css';
export function AudioCover({ url, thumbnailUrl }) {
    const audioContext = React.useContext(AudioContext);
    if (audioContext == null) {
        throw new Error('AudioCover must be used under the AudioContextProvider');
    }
    const audio = React.useRef();
    const [duration, setDuration] = React.useState(0);
    const [currentTime, setCurrentTime] = React.useState(0);
    const [canPlay, setCanPlay] = React.useState(true);
    const [isHovering, setIsHovering] = React.useState(false);
    const isPlaying = audio.current && audio.current === audioContext.playingAudio;
    React.useEffect(() => {
        if (isPlaying) {
            audioContext.stop();
        }
        audio.current = new Audio(url);
        setCanPlay(true);
        audio.current.onerror = () => {
            var _a;
            if (((_a = audio.current) === null || _a === void 0 ? void 0 : _a.src) === url) {
                setDuration(0);
                setCanPlay(false);
                setCurrentTime(0);
            }
        };
        audio.current.onloadedmetadata = () => {
            if (duration === 0 && audio.current && audio.current.src.includes(url)) {
                setDuration(audio.current.duration);
            }
        };
        audio.current.ontimeupdate = () => {
            if (audio.current && audio.current.src.includes(url)) {
                setCurrentTime(audio.current.currentTime);
            }
        };
    }, [url]);
    const playAudio = () => {
        if (!audio.current || !canPlay) {
            return;
        }
        audioContext.play(audio.current);
    };
    const toggleAudio = (event) => {
        event.stopPropagation();
        isPlaying ? audioContext.stop() : playAudio();
    };
    return (_jsxs(BasicButton, { ariaLabel: Messages.playPreview(), className: classNames(styles.audioCover, {
            [styles.audioCoverPlaying]: isPlaying,
        }), onClick: toggleAudio, onMouseEnter: () => setIsHovering(true), onMouseLeave: () => setIsHovering(false), noChildWrapper: true, children: [thumbnailUrl && (_jsx(CardImageThumbnail, { alt: "", url: thumbnailUrl, className: classNames({
                    [styles.audioImagePlaying]: isPlaying,
                }) })), isPlaying && duration > 0 && _jsx(PlayingCircle, { playedPercentage: currentTime / duration }), _jsx("span", { className: styles.audioIcon, children: _jsx(AudioIcon, { canPlay: canPlay, isPlaying: Boolean(isPlaying), hasCoverArt: Boolean(thumbnailUrl), isHovering: isHovering }) })] }));
}
const AudioIcon = ({ canPlay, isPlaying, isHovering, hasCoverArt, }) => {
    if (!canPlay) {
        return _jsx(AlertTriangleIcon, {});
    }
    if (isPlaying) {
        return _jsx(PauseIcon, {});
    }
    if (isHovering) {
        return _jsx(PlayFilledIcon, {});
    }
    if (!hasCoverArt) {
        return _jsx(MusicIcon, {});
    }
    return null;
};
const PlayingCircle = ({ playedPercentage }) => {
    const strokeWidth = parseInt(styles.progressStrokeWidth, 10) || 0;
    const size = 56;
    const radius = (size - strokeWidth) / 2;
    const perimeter = 2 * Math.PI * radius;
    const dashSize = perimeter * playedPercentage;
    return (_jsx("svg", { viewBox: `0 0 ${size} ${size}`, className: styles.playingCircle, children: _jsx("circle", { className: styles.animatedCircle, cx: size / 2, cy: size / 2, r: radius, strokeDasharray: `${dashSize},${perimeter}` }) }));
};
