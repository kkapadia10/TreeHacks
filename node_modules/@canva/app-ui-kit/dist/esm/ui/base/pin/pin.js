import { __decorate } from "tslib";
import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { Preconditions } from '../../../base/preconditions';
import classNames from 'classnames';
import { reaction } from 'mobx';
import { disposeOnUnmount, observer } from 'mobx-react';
import Popper from 'popper.js';
import * as React from 'react';
import { Layer } from '../layer/layer';
import { useDirection } from '../provider/provider';
import styles from './pin.css';
import { DefaultMotionWrapper } from './pin_motion_wrapper';
export const Pin = React.forwardRef((props, ref) => {
  const pinRef = React.useRef(null);
  React.useImperativeHandle(ref, () => ({
    update() {
      var _a;
      (_a = pinRef.current) === null || _a === void 0 ? void 0 : _a.update();
    },
    dangerouslyForceUpdate() {
      var _a;
      (_a = pinRef.current) === null || _a === void 0 ? void 0 : _a.dangerouslyForceUpdate();
    }
  }), []);
  const direction = useDirection();
  return _jsx(_Pin, {
    direction: direction,
    ...props,
    ref: pinRef
  });
});
const popperFactory = (reference, popper, options) => new Popper(reference, popper, options);
const RTLPlacementConversionTable = new Map([['top-start', 'top-end'], ['top-end', 'top-start'], ['right-start', 'left-start'], ['right', 'left'], ['right-end', 'left-end'], ['bottom-end', 'bottom-start'], ['bottom-start', 'bottom-end'], ['left-end', 'right-end'], ['left', 'right'], ['left-start', 'right-start']]);
let _Pin = class _Pin extends React.Component {
  constructor(props) {
    super(props);
    this.contentKey = 0;
    this.onOutsideLayerPointerDown = event => {
      const {
        open,
        onOutsideContentPointerDown,
        onChildrenPointerDown
      } = this.props;
      if (!onOutsideContentPointerDown && !onChildrenPointerDown || !open) {
        return;
      }
      const target = event && event.target;
      if (target && target instanceof this.parentGlobal.Node && this.targetRef && this.targetRef.contains(target)) {
        onChildrenPointerDown && onChildrenPointerDown(event);
        return;
      }
      onOutsideContentPointerDown && onOutsideContentPointerDown(event);
    };
    this.updateTargetRef = targetRef => this.targetRef = targetRef;
    this.updateArrowRef = arrowRef => {
      if (this.arrowRef !== arrowRef) {
        this.arrowRef = arrowRef;
        this.maybeCreatePopper();
        this.update();
      }
    };
    this.updateContentRef = contentRef => {
      if (this.contentRef !== contentRef) {
        this.contentRef = contentRef;
        this.maybeCreatePopper();
        this.update();
      }
    };
    this.onModalMouseDown = () => {
      if (this.props.onOutsideContentPointerDown) {
        window.setTimeout(this.props.onOutsideContentPointerDown, 0);
      }
    };
    disposeOnUnmount(this, [reaction(() => this.props.open, open => open && (this.contentKey = 1 - this.contentKey)), reaction(() => this.props.placement, _ => {
      this.maybeDestroyPopper();
      this.maybeCreatePopper();
    })]);
  }
  componentDidUpdate(prevProps) {
    Preconditions.checkState(prevProps.refObj === this.props.refObj, 'refObj must never be changed');
    if (this.popper && !this.props.open) {
      this.maybeDestroyPopper();
    } else {
      this.update();
    }
  }
  componentWillUnmount() {
    this.maybeDestroyPopper();
  }
  dangerouslyForceUpdate() {
    if (this.popper && this.props.open) {
      this.popper.update();
    }
  }
  update() {
    if (this.popper && this.props.open) {
      this.popper.scheduleUpdate();
    }
  }
  maybeDestroyPopper() {
    if (this.popper) {
      this.popper.disableEventListeners();
      this.popper = undefined;
    }
  }
  maybeCreatePopper() {
    const popperFactory = Preconditions.checkExists(this.props._popperFactory);
    const {
      open,
      refObj,
      positionFixed,
      direction
    } = this.props;
    let {
      placement
    } = this.props;
    if (this.popper || !open || !this.contentRef || !this.arrowRef && this.props.arrow != null) {
      return;
    }
    let targetWrapperRef;
    if (refObj) {
      Preconditions.checkState(!this.targetRef, 'Pin must not contain children when refObj is specified');
      targetWrapperRef = refObj;
    } else if (this.targetRef) {
      Preconditions.checkState(this.targetRef.children.length === 1, 'Pin must contain exactly one child');
      targetWrapperRef = this.targetRef.children[0];
    } else {
      return;
    }
    if (placement && direction === 'RTL' && RTLPlacementConversionTable.has(placement)) {
      placement = RTLPlacementConversionTable.get(placement);
    }
    const options = {
      placement,
      positionFixed,
      modifiers: {
        arrow: {
          element: this.arrowRef || undefined,
          enabled: this.arrowRef != null
        },
        offset: {
          enabled: !!this.props.calculateOffset,
          fn: (data, options) => {
            const offset = this.props.calculateOffset();
            data.offsets.popper.left = Math.round(offset.left);
            data.offsets.popper.top = Math.round(offset.top);
            return data;
          }
        },
        preventOverflow: {
          escapeWithReference: this.props.overflowParent,
          boundariesElement: this.props.overflowBoundariesElement || 'scrollParent'
        }
      }
    };
    if (this.props.onPlacementUpdate) {
      options.onUpdate = this.props.onPlacementUpdate;
    }
    this.popper = popperFactory(targetWrapperRef, this.contentRef, options);
  }
  get parentGlobal() {
    var _a, _b;
    return ((_b = (_a = this.targetRef) === null || _a === void 0 ? void 0 : _a.ownerDocument) === null || _b === void 0 ? void 0 : _b.defaultView) || window;
  }
  render() {
    var _a;
    const {
      open,
      level,
      children,
      content,
      arrow,
      MotionWrapper = DefaultMotionWrapper,
      expandChildren,
      noPointerEventsForDisabledChildren,
      onOutsideContentPointerDown,
      onChildrenPointerDown,
      parentLayer,
      blockOutsidePointerEvents,
      modalBackdrop,
      noPointerEvents
    } = this.props;
    const onOutsideLayerPointerDownHandler = !onOutsideContentPointerDown && !onChildrenPointerDown || !open ? undefined : this.onOutsideLayerPointerDown;
    return _jsxs(_Fragment, {
      children: [children && _jsx("div", {
        className: classNames({
          [styles.noPointerEventsForDisabledChildren]: noPointerEventsForDisabledChildren,
          [styles.expandChildren]: expandChildren
        }),
        ref: this.updateTargetRef,
        children: children
      }), _jsx(MotionWrapper, {
        show: open,
        childRef: {
          current: (_a = this.contentRef) !== null && _a !== void 0 ? _a : null
        },
        children: ({
          style,
          showLayer
        }) => _jsxs(Layer, {
          open: showLayer,
          level: level,
          parentLayer: parentLayer,
          onOutsideLayerPointerDown: onOutsideLayerPointerDownHandler,
          children: [blockOutsidePointerEvents && open &&
          _jsx("div", {
            className: classNames(styles.backdrop, {
              [styles.backdropDark]: modalBackdrop === 'dark'
            }),
            onMouseDown: this.onModalMouseDown
          }), _jsxs("div", {
            ref: this.updateContentRef,
            className: classNames(styles.content, {
              [styles.closed]: !open,
              [styles.noPointerEvents]: noPointerEvents
            }),
            style: style,
            children: [content, arrow && _jsx("div", {
              ref: this.updateArrowRef,
              className: styles.arrow,
              children: arrow
            })]
          }, this.contentKey)]
        })
      })]
    });
  }
};
_Pin.defaultProps = {
  placement: 'top',
  positionFixed: false,
  open: true,
  _popperFactory: popperFactory,
  content: ''
};
_Pin = __decorate([observer], _Pin);