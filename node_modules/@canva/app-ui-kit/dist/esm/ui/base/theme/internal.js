import { makeObservable } from '../../../base/make_observable/make_observable';
import { __decorate } from "tslib";
import { Preconditions, UnreachableError } from '../../../base/preconditions';
import classNames from 'classnames';
import { action, computed, observable } from 'mobx';
import * as React from 'react';
import preloadSelectors from './preload.css';
import styles from './theme.css';
export const stripGlobal = className => {
  var _a;
  return (_a = className === null || className === void 0 ? void 0 : className.replace(/^\s*:global\(\.(.+?)\)\s*$/, '$1')) !== null && _a !== void 0 ? _a : '';
};
let themeClasses;
let themedClass;
function getThemeClassMap() {
  if (themeClasses == null) {
    themeClasses = new Map([['light', stripGlobal(styles.themeLightClass)], ['dark', stripGlobal(styles.themeDark)]]);
  }
  return themeClasses;
}
function getThemedClass() {
  if (themedClass == null) {
    themedClass = stripGlobal(styles.themed);
  }
  return themedClass;
}
export function getThemeClasses(theme) {
  const themeClasses = getThemeClassMap();
  return [getThemedClass(), Preconditions.checkExists(themeClasses.get(theme))];
}
export function getAllPreloadClasses() {
  return [getThemedClass(), ...getThemeClassMap().values(), stripGlobal(preloadSelectors.themePreloadModeClassic)];
}
export class ThemeStore {
  static _makeObservable(instance) {
    makeObservable(instance, {
      parent: observable.ref,
      _appearance: observable.ref,
      themeMapping: observable.deep,
      setParent: action,
      setAppearance: action,
      appearance: computed,
      setThemeMapping: action,
      currentTheme: computed
    });
  }
  constructor() {
    ThemeStore._makeObservable(this);
    this.themeMapping = {};
  }
  setParent(store) {
    this.parent = store;
  }
  setAppearance(appearance) {
    this._appearance = appearance;
  }
  get appearance() {
    var _a, _b;
    return (_a = this._appearance) !== null && _a !== void 0 ? _a : (_b = this.parent) === null || _b === void 0 ? void 0 : _b.appearance;
  }
  setThemeMapping(themeMapping) {
    this.themeMapping = themeMapping;
  }
  get currentTheme() {
    var _a, _b;
    const appearance = this.appearance;
    if (appearance == null) {
      return undefined;
    }
    return (_a = this.themeMapping[appearance]) !== null && _a !== void 0 ? _a : (_b = this.parent) === null || _b === void 0 ? void 0 : _b.currentTheme;
  }
}
export class ThemeData {
  static _makeObservable(instance) {
    makeObservable(instance, {
      classNames: computed,
      className: computed,
      mode: computed
    });
  }
  constructor(store) {
    ThemeData._makeObservable(this);
    this.store = store;
  }
  get classNames() {
    const {
      currentTheme
    } = this.store;
    if (currentTheme == null) {
      return [];
    }
    return getThemeClasses(currentTheme);
  }
  get className() {
    const classes = this.classNames;
    if (classes.length === 0) {
      return undefined;
    }
    return classNames(classes);
  }
  get mode() {
    switch (this.store.appearance) {
      case 'dark':
      case 'light':
        return 'modern';
      case 'classicDark':
      case 'classicLight':
        return 'classic';
      case undefined:
        return undefined;
      default:
        throw new UnreachableError(this.store.appearance);
    }
  }
}
export const rootThemeStore = new ThemeStore();
const rootThemeData = new ThemeData(rootThemeStore);
export const ThemeContext = React.createContext({
  store: rootThemeStore,
  data: rootThemeData
});