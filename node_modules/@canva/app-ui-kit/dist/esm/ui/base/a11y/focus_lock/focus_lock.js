import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import composeRefs from '@seznam/compose-react-refs';
import { exists } from '../../../../base/exists';
import * as mobxReact from 'mobx-react';
import * as React from 'react';
import { useKeyCombinationHandler } from '../../key_combinations/use_key_combination_handler';
import { findAutoFocusElement, FOCUS_GUARD_ATTR, FOCUS_LOCK_EXCEPTED_ATTR, focusWithConditionalDelayHack, getFocusablesInside, } from './dom_utils';
import { FocusLockManagerContextProvider, useFocusLockManager } from './focus_lock_manager';
const FOCUS_GUARD_PROP = {
    [FOCUS_GUARD_ATTR]: true,
};
export const FocusLock = mobxReact.observer(React.forwardRef(function FocusLock({ autoFocus = true, children, className, disabled: propsDisabled = false, lockProps, returnFocus = true, preventScroll = false, makeContainerFocusable = false, onRequestEscape, keyCombinationMap = [], handleKeysOnInputs = true, }, ref) {
    const [browserWindow, setBrowserWindow] = React.useState();
    const previouslyFocusedElement = React.useRef(null);
    const rootRef = React.useRef(null);
    const focusables = React.useRef([]);
    const isFocusablesOutdated = React.useRef(true);
    React.useEffect(() => {
        setBrowserWindow(window);
        previouslyFocusedElement.current = window.document.activeElement;
    }, []);
    React.useLayoutEffect(() => {
        var _a;
        const currentWindow = (_a = rootRef.current) === null || _a === void 0 ? void 0 : _a.ownerDocument.defaultView;
        if (currentWindow && currentWindow !== browserWindow) {
            setBrowserWindow(currentWindow);
            previouslyFocusedElement.current = currentWindow.document.activeElement;
        }
    }, [browserWindow]);
    React.useLayoutEffect(() => {
        if (!propsDisabled && browserWindow) {
            previouslyFocusedElement.current = browserWindow.document.activeElement;
            isFocusablesOutdated.current = true;
        }
    }, [propsDisabled, browserWindow]);
    const { manager } = useFocusLockManager({
        browserWindow,
        disabled: propsDisabled,
    });
    const disabled = propsDisabled || manager.surrenderLock;
    React.useLayoutEffect(() => {
        if (!rootRef.current || disabled) {
            return;
        }
        const observer = new MutationObserver(() => {
            isFocusablesOutdated.current = true;
        });
        observer.observe(rootRef.current, { childList: true, subtree: true });
        return () => {
            observer.disconnect();
        };
    }, [disabled]);
    const regenerateFocusables = React.useCallback(() => {
        if (isFocusablesOutdated.current && rootRef.current) {
            isFocusablesOutdated.current = false;
            focusables.current = getFocusablesInside(rootRef.current);
        }
    }, []);
    const findFirstFocusable = React.useCallback(() => {
        regenerateFocusables();
        if (focusables.current.length > 0) {
            return focusables.current[0];
        }
    }, [regenerateFocusables]);
    const focusFirst = React.useCallback(() => {
        const firstFocusable = findFirstFocusable();
        if (firstFocusable) {
            firstFocusable.focus({ preventScroll });
        }
    }, [preventScroll, findFirstFocusable]);
    const focusLast = React.useCallback(() => {
        regenerateFocusables();
        if (focusables.current.length > 0) {
            focusables.current[focusables.current.length - 1].focus({ preventScroll });
        }
    }, [preventScroll, regenerateFocusables]);
    const onFocusIn = React.useCallback((e) => {
        if (!rootRef.current || e.target == null) {
            return;
        }
        if (isTargetExceptedFromFocusLock(e.target)) {
            return;
        }
        if (e.relatedTarget == null && !rootRef.current.contains(e.target)) {
            focusFirst();
            return;
        }
    }, [focusFirst]);
    const onFocusOut = React.useCallback((e) => {
        if (!rootRef.current || manager.surrenderLock) {
            return;
        }
        if (!e.relatedTarget
            || rootRef.current.contains(e.relatedTarget)
            || isTargetExceptedFromFocusLock(e.relatedTarget)) {
            return;
        }
        if (e.target && rootRef.current.contains(e.target)) {
            e.target.focus({ preventScroll });
            return;
        }
        focusFirst();
    }, [focusFirst, manager, preventScroll]);
    React.useLayoutEffect(() => {
        if (!disabled && browserWindow) {
            browserWindow.document.addEventListener('focusout', onFocusOut, true);
            browserWindow.document.addEventListener('focusin', onFocusIn, true);
            return () => {
                browserWindow.document.removeEventListener('focusout', onFocusOut, true);
                browserWindow.document.removeEventListener('focusin', onFocusIn, true);
            };
        }
    }, [browserWindow, disabled, onFocusIn, onFocusOut]);
    React.useLayoutEffect(() => {
        if (!manager.isReady || browserWindow == null) {
            return;
        }
        if (propsDisabled || manager.surrenderLock || !rootRef.current) {
            return;
        }
        const { activeElement } = browserWindow.document;
        if (rootRef.current.contains(activeElement)) {
            return;
        }
        if (!autoFocus) {
            activeElement === null || activeElement === void 0 ? void 0 : activeElement.blur();
            return;
        }
        const autoFocusElement = (rootRef.current ? findAutoFocusElement(rootRef.current) : null) || findFirstFocusable();
        if (autoFocusElement) {
            focusWithConditionalDelayHack(autoFocusElement, { preventScroll });
        }
    }, [
        autoFocus,
        browserWindow,
        findFirstFocusable,
        manager.isReady,
        manager,
        preventScroll,
        propsDisabled,
    ]);
    const returnFocusRef = React.useRef(returnFocus && !disabled);
    returnFocusRef.current = returnFocus && !disabled;
    React.useEffect(() => {
        if (!propsDisabled) {
            const el = previouslyFocusedElement.current;
            return () => {
                if (returnFocusRef.current && !manager.surrenderLock && el) {
                    el.focus({ preventScroll });
                }
            };
        }
    }, [propsDisabled]);
    const finalKeyCombinationMap = React.useMemo(() => {
        const escapeKeyHandler = onRequestEscape && !disabled
            ? [
                'Escape',
                (e) => {
                    e.stopPropagation();
                    onRequestEscape();
                },
            ]
            : undefined;
        return [escapeKeyHandler, ...keyCombinationMap].filter(exists);
    }, [disabled, keyCombinationMap, onRequestEscape]);
    const { ref: keyHandlerRef } = useKeyCombinationHandler(finalKeyCombinationMap, {
        handleInputs: handleKeysOnInputs,
    });
    return (_jsx(FocusLockManagerContextProvider, { value: manager, children: _jsxs("div", { ...lockProps, className: className, ref: composeRefs(rootRef, ref, keyHandlerRef), tabIndex: makeContainerFocusable ? -1 : undefined, children: [_jsx("div", { onFocus: disabled ? undefined : focusLast, tabIndex: disabled ? undefined : 0, ...FOCUS_GUARD_PROP }), children, _jsx("div", { onFocus: disabled ? undefined : focusFirst, tabIndex: disabled ? undefined : 0, ...FOCUS_GUARD_PROP })] }) }));
}));
function isTargetExceptedFromFocusLock(target) {
    if ('hasAttribute' in target) {
        return target.hasAttribute(FOCUS_LOCK_EXCEPTED_ATTR);
    }
    return false;
}
