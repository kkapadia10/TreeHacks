import * as React from 'react';
import { accessModeState } from '../access_mode_state/access_mode_state';
import { command, option, shift } from '../../key_combinations/key_combination';
import { useKeyCombinationHandler } from '../../key_combinations/use_key_combination_handler';
export function useKeyboardNavigation(size, options = {}) {
    const { direction = 'vertical', mode = 'default', handleInputs = false, extraNavigation = true, onChange, onPrev, onNext, onFirst, onLast, onSelect, onExit, } = options;
    const [index, setIndex] = React.useState(() => -1);
    const sizeRef = React.useRef(size);
    const indexRef = React.useRef(index);
    const onChangeRef = React.useRef(onChange);
    sizeRef.current = size;
    indexRef.current = index;
    onChangeRef.current = onChange;
    const moveTo = React.useCallback((index = -1) => {
        var _a;
        if (indexRef.current !== index) {
            setIndex((indexRef.current = index));
            (_a = onChangeRef.current) === null || _a === void 0 ? void 0 : _a.call(onChangeRef, indexRef.current);
        }
    }, []);
    const moveToFirst = React.useCallback(() => moveTo(0), [moveTo]);
    const moveToLast = React.useCallback(() => moveTo(sizeRef.current - 1), [moveTo]);
    React.useEffect(() => {
        moveTo(size != null ? Math.min(indexRef.current, size - 1) : -1);
    }, [size, moveTo]);
    const _onPrev = React.useCallback((e) => {
        e.preventDefault();
        if (e.isComposing) {
            return;
        }
        const index = indexRef.current;
        let newIndex = Math.max(0, index - 1);
        onPrev === null || onPrev === void 0 ? void 0 : onPrev(e, index);
        if (mode === 'cycle' && newIndex === index) {
            newIndex = sizeRef.current - 1;
        }
        else if (newIndex === 0) {
            onFirst === null || onFirst === void 0 ? void 0 : onFirst(e, index);
        }
        moveTo(newIndex);
        accessModeState.setAccessMode('keyboard');
    }, [onPrev, onFirst, moveTo, mode]);
    const _onNext = React.useCallback((e) => {
        e.preventDefault();
        if (e.isComposing) {
            return;
        }
        const index = indexRef.current;
        const size = sizeRef.current;
        let newIndex = Math.min(size - 1, index + 1);
        onNext === null || onNext === void 0 ? void 0 : onNext(e, index);
        if (mode === 'cycle' && newIndex === index) {
            newIndex = 0;
        }
        else if (newIndex === size - 1) {
            onLast === null || onLast === void 0 ? void 0 : onLast(e, index);
        }
        moveTo(newIndex);
        accessModeState.setAccessMode('keyboard');
    }, [onNext, mode, moveTo, onLast]);
    const _onFirst = React.useCallback((e) => {
        e.preventDefault();
        onFirst === null || onFirst === void 0 ? void 0 : onFirst(e, indexRef.current);
        moveToFirst();
        accessModeState.setAccessMode('keyboard');
    }, [onFirst, moveToFirst]);
    const _onLast = React.useCallback((e) => {
        e.preventDefault();
        onLast === null || onLast === void 0 ? void 0 : onLast(e, indexRef.current);
        moveToLast();
        accessModeState.setAccessMode('keyboard');
    }, [onLast, moveToLast]);
    const _onSelectWithSpace = React.useCallback((e) => {
        onSelect === null || onSelect === void 0 ? void 0 : onSelect(e, indexRef.current);
    }, [onSelect]);
    const _onSelectWithEnter = React.useCallback((e) => {
        if (e.keyCode === 229) {
            return;
        }
        onSelect === null || onSelect === void 0 ? void 0 : onSelect(e, indexRef.current);
    }, [onSelect]);
    const _onExit = React.useCallback((e) => {
        if (e.isComposing) {
            return;
        }
        onExit === null || onExit === void 0 ? void 0 : onExit(e, indexRef.current);
    }, [onExit]);
    const keyCombinationMap = React.useMemo(() => {
        const prevKey = direction === 'vertical' ? 'ArrowUp' : 'previous';
        const nextKey = direction === 'vertical' ? 'ArrowDown' : 'next';
        const map = [
            [prevKey, _onPrev],
            [nextKey, _onNext],
            [' ', _onSelectWithSpace],
            ['Enter', _onSelectWithEnter],
            ['Escape', _onExit],
            ['Tab', _onExit],
            [shift('Tab'), _onExit],
        ];
        if (extraNavigation) {
            map.push(['Home', _onFirst], [option(prevKey), _onFirst], [command(prevKey), _onFirst], ['End', _onLast], [option(nextKey), _onLast], [command(nextKey), _onLast]);
        }
        return map;
    }, [
        direction,
        extraNavigation,
        _onPrev,
        _onNext,
        _onFirst,
        _onLast,
        _onSelectWithEnter,
        _onSelectWithSpace,
        _onExit,
    ]);
    const { ref } = useKeyCombinationHandler(keyCombinationMap, { handleInputs });
    return {
        ref,
        index,
        moveTo,
        moveToFirst,
        moveToLast,
    };
}
export function WithKeyboardNavigation({ children, size, ...props }) {
    return children(useKeyboardNavigation(size, props));
}
