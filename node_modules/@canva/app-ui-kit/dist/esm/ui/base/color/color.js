import { Preconditions } from '../../../base/preconditions';
export class RgbColor {
    constructor(r, g, b) {
        this.r = r;
        this.g = g;
        this.b = b;
        Preconditions.checkArgument(0 <= r && r <= 255, 'invalid r: {}', r);
        Preconditions.checkArgument(0 <= g && g <= 255, 'invalid g: {}', g);
        Preconditions.checkArgument(0 <= b && b <= 255, 'invalid b: {}', b);
    }
    static fromHexString(s) {
        return CssColors.fromHexString(s);
    }
    static fromRgbString(s) {
        return CssColors.fromRgbString(s);
    }
    toRgbaColor(alpha = 1) {
        return new RgbaColor(this.r, this.g, this.b, alpha);
    }
    toHexString() {
        return CssColors.toHexString(this);
    }
    toRgbString() {
        return CssColors.toRgbString(this);
    }
}
export class RgbaColor {
    constructor(r, g, b, a) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
        Preconditions.checkArgument(0 <= r && r <= 255, 'invalid r: {}', r);
        Preconditions.checkArgument(0 <= g && g <= 255, 'invalid g: {}', g);
        Preconditions.checkArgument(0 <= b && b <= 255, 'invalid b: {}', b);
        Preconditions.checkArgument(0 <= a && a <= 1, 'invalid a: {}', a);
    }
    static fromRgbaString(s) {
        return CssColors.fromRgbaString(s);
    }
    toRgb() {
        return new RgbColor(this.r, this.g, this.b);
    }
    toRgbaString() {
        return CssColors.toRgbaString(this);
    }
}
export class LabColor {
    constructor(l, a, b) {
        this.l = l;
        this.a = a;
        this.b = b;
        Preconditions.checkArgument(0 <= l && l <= 100, '{}', l);
    }
}
export class HclColor {
    constructor(h, c, l) {
        this.h = h;
        this.c = c;
        this.l = l;
        Preconditions.checkArgument(0 <= l && l <= 100, '{}', l);
        this.h = normalizeHue(h);
    }
}
export class XyzColor {
    constructor(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
}
export class HslColor {
    constructor(h, s, l) {
        this.h = h;
        this.s = s;
        this.l = l;
        Preconditions.checkArgument(0 <= s && s <= 100, 'invalid s: {}', s);
        Preconditions.checkArgument(0 <= l && l <= 100, 'invalid l: {}', l);
        this.h = normalizeHue(h);
    }
}
export class CssColors {
    static fromString(s) {
        if (s.match(HEX_RE)) {
            return CssColors.fromHexString(s);
        }
        else if (s.match(SHORT_HEX_RE)) {
            return CssColors.fromShortHexString(s);
        }
        else if (s.match(RGB_RE)) {
            return CssColors.fromRgbString(s);
        }
        else if (s.match(RGBA_RE)) {
            return CssColors.fromRgbaString(s);
        }
        else if (s.match(HSL_RE)) {
            return CssColors.fromHslString(s);
        }
        else {
            throw new Error(`unrecognized color: ${s}`);
        }
    }
    static fromShortHexString(s) {
        const match = SHORT_HEX_RE.exec(s);
        if (!match) {
            throw new Error(`invalid hexadecimal triplet color: ${s}`);
        }
        return new RgbColor(fromHex(match[1] + match[1]), fromHex(match[2] + match[2]), fromHex(match[3] + match[3]));
    }
    static fromHexString(s) {
        const match = HEX_RE.exec(s);
        if (!match) {
            throw new Error(`invalid hexadecimal color: ${s}`);
        }
        return new RgbColor(fromHex(match[1]), fromHex(match[2]), fromHex(match[3]));
    }
    static fromRgbString(s) {
        const match = RGB_RE.exec(s);
        if (!match) {
            throw new Error(`invalid rgb color: ${s}`);
        }
        return new RgbColor(+match[1], +match[2], +match[3]);
    }
    static fromRgbaString(s) {
        const match = RGBA_RE.exec(s);
        if (!match) {
            throw new Error(`invalid rgba color: ${s}`);
        }
        return new RgbaColor(+match[1], +match[2], +match[3], +match[4]);
    }
    static fromHslString(str) {
        const matches = str.match(HSL_RE);
        if (!matches) {
            throw new Error(`invalid hsla color: ${str}`);
        }
        const [h, s, l] = [matches[2], matches[4], matches[6]];
        const a = matches[8].length ? matches[8] : '1';
        const hue = parseFloat(h) / 360;
        const saturation = percentToNorm(s);
        const lightness = percentToNorm(l);
        const alpha = parseFloat(a);
        const [r, g, b] = hslToRgb([hue, saturation, lightness]);
        return new RgbaColor(normToU8(r), normToU8(g), normToU8(b), alpha);
    }
    static toHexString(c) {
        return `#${toHex(Math.round(c.r))}${toHex(Math.round(c.g))}${toHex(Math.round(c.b))}`;
    }
    static toRgbString(c) {
        return `rgb(${Math.round(c.r)},${Math.round(c.g)},${Math.round(c.b)})`;
    }
    static toRgbaString(c) {
        return `rgba(${Math.round(c.r)},${Math.round(c.g)},${Math.round(c.b)},${c.a})`;
    }
    constructor() { }
}
export class Conversion {
    constructor() { }
    static toLab(c) {
        if (c instanceof RgbColor) {
            const xyz = Conversion.rgbToXyz(c);
            return Conversion.xyzToLab(xyz);
        }
        else if (c instanceof XyzColor) {
            return Conversion.xyzToLab(c);
        }
        else if (c instanceof HclColor) {
            return Conversion.hclToLab(c);
        }
        else if (c instanceof HslColor) {
            const rgb = Conversion.hslToRgb(c);
            return Conversion.toLab(rgb);
        }
        else if (typeof c === 'string') {
            const rgb = Conversion.hexToRgb(c);
            const xyz = Conversion.rgbToXyz(rgb);
            return Conversion.xyzToLab(xyz);
        }
        return c;
    }
    static toRgb(c) {
        if (c instanceof XyzColor) {
            return Conversion.xyzToRgb(c);
        }
        else if (c instanceof LabColor) {
            const xyz = Conversion.labToXyz(c);
            return Conversion.xyzToRgb(xyz);
        }
        else if (c instanceof HclColor) {
            const lab = Conversion.hclToLab(c);
            const xyz = Conversion.labToXyz(lab);
            return Conversion.xyzToRgb(xyz);
        }
        else if (c instanceof HslColor) {
            return Conversion.hslToRgb(c);
        }
        else if (typeof c === 'string') {
            return Conversion.hexToRgb(c);
        }
        return c;
    }
    static toHcl(c) {
        if (c instanceof RgbColor) {
            const xyz = Conversion.rgbToXyz(c);
            const lab = Conversion.xyzToLab(xyz);
            return Conversion.labToHcl(lab);
        }
        else if (c instanceof LabColor) {
            return Conversion.labToHcl(c);
        }
        else if (c instanceof XyzColor) {
            const xyz = Conversion.xyzToLab(c);
            return Conversion.labToHcl(xyz);
        }
        else if (c instanceof HslColor) {
            const rgb = Conversion.hslToRgb(c);
            return Conversion.toHcl(rgb);
        }
        else if (typeof c === 'string') {
            const rgb = Conversion.hexToRgb(c);
            const xyz = Conversion.rgbToXyz(rgb);
            const lab = Conversion.xyzToLab(xyz);
            return Conversion.labToHcl(lab);
        }
        return c;
    }
    static toHsl(c) {
        if (c instanceof RgbColor) {
            return Conversion.rgbToHsl(c);
        }
        else if (c instanceof HclColor) {
            const rgb = Conversion.toRgb(c);
            return Conversion.rgbToHsl(rgb);
        }
        else if (c instanceof LabColor) {
            const rgb = Conversion.toRgb(c);
            return Conversion.rgbToHsl(rgb);
        }
        else if (c instanceof XyzColor) {
            const rgb = Conversion.toRgb(c);
            return Conversion.rgbToHsl(rgb);
        }
        else if (typeof c === 'string') {
            const rgb = Conversion.hexToRgb(c);
            return Conversion.rgbToHsl(rgb);
        }
        return c;
    }
    static toXyz(c) {
        if (c instanceof RgbColor) {
            return Conversion.rgbToXyz(c);
        }
        else if (c instanceof LabColor) {
            return Conversion.labToXyz(c);
        }
        else if (c instanceof HclColor) {
            const lab = Conversion.hclToLab(c);
            return Conversion.labToXyz(lab);
        }
        else if (c instanceof HslColor) {
            const rgb = Conversion.hslToRgb(c);
            return Conversion.toXyz(rgb);
        }
        else if (typeof c === 'string') {
            const rgb = Conversion.hexToRgb(c);
            return Conversion.rgbToXyz(rgb);
        }
        return c;
    }
    static toHex(c) {
        return Conversion.toRgb(c).toHexString();
    }
    static hslToRgb(c) {
        const [r, g, b] = hslToRgb([c.h / 360, c.s / 100, c.l / 100]);
        return new RgbColor(r * 255, g * 255, b * 255);
    }
    static rgbToHsl(c) {
        const [r, g, b] = [c.r / 255, c.g / 255, c.b / 255];
        const min = Math.min(r, g, b);
        const max = Math.max(r, g, b);
        const range = max - min;
        const lightness = (min + max) / 2;
        let saturation;
        if (range === 0) {
            saturation = 0;
        }
        else if (lightness <= 0.5) {
            saturation = (max - min) / (max + min);
        }
        else {
            saturation = (max - min) / (2 - max - min);
        }
        let hue;
        if (range === 0) {
            hue = 0;
        }
        else if (max === r) {
            hue = ((g - b) / range) * 60;
        }
        else if (max === g) {
            hue = ((b - r) / range) * 60 + 120;
        }
        else {
            hue = ((r - g) / range) * 60 + 240;
        }
        return new HslColor(hue, saturation * 100, lightness * 100);
    }
    static hclToLab(c) {
        const hRad = (c.h * Math.PI) / 180;
        const a = Math.cos(hRad) * c.c;
        const b = Math.sin(hRad) * c.c;
        return new LabColor(c.l, a, b);
    }
    static labToHcl(c) {
        const { a, b } = c;
        const hue = (Math.atan2(b, a) * 180) / Math.PI;
        const chroma = Math.sqrt(a ** 2 + b ** 2);
        return new HclColor(hue, chroma, c.l);
    }
    static labToXyz(c) {
        const { D50, κ, ε } = LAB_CONSTANTS;
        const { l, a, b } = c;
        const fy = (l + 16) / 116;
        const fx = fy + a / 500;
        const fz = fy - b / 200;
        let x = fx ** 3 > ε ? fx ** 3 : (116 * fx - 16) / κ;
        let y = l > κ * ε ? ((l + 16) / 116) ** 3 : l / κ;
        let z = fz ** 3 > ε ? fz ** 3 : (116 * fz - 16) / κ;
        x *= D50.x;
        y *= D50.y;
        z *= D50.z;
        return new XyzColor(x, y, z);
    }
    static xyzToLab(c) {
        const { D50, κ, ε } = LAB_CONSTANTS;
        let { x, y, z } = c;
        x /= D50.x;
        y /= D50.y;
        z /= D50.z;
        const f = (v) => (v > ε ? Math.cbrt(v) : (κ * v + 16) / 116);
        const fx = f(x);
        const fy = f(y);
        const fz = f(z);
        const l = 116 * fy - 16;
        const a = 500 * (fx - fy);
        const b = 200 * (fy - fz);
        return new LabColor(l, a, b);
    }
    static xyzToRgb(c) {
        const x = c.x / 100;
        const y = c.y / 100;
        const z = c.z / 100;
        let r = 3.1338561 * x - 1.6168667 * y - 0.4906146 * z;
        let g = -0.9787684 * x + 1.9161415 * y + 0.033454 * z;
        let b = 0.0719453 * x - 0.2289914 * y + 1.4052427 * z;
        const delinearize = (v) => v <= 0.0031308 ? v * 12.92 : 1.055 * v ** (1 / 2.4) - 0.055;
        r = delinearize(r);
        g = delinearize(g);
        b = delinearize(b);
        r = Math.round(r * 255);
        g = Math.round(g * 255);
        b = Math.round(b * 255);
        const clamp = (v) => Math.max(Math.min(v, 255), 0);
        r = clamp(r);
        g = clamp(g);
        b = clamp(b);
        return new RgbColor(r, g, b);
    }
    static rgbToXyz(c) {
        let { r, g, b } = c;
        r /= 255;
        g /= 255;
        b /= 255;
        const linearize = (v) => (v <= 0.04045 ? v / 12.92 : ((v + 0.055) / 1.055) ** 2.4);
        r = linearize(r);
        g = linearize(g);
        b = linearize(b);
        let x = 0.4360747 * r + 0.3850649 * g + 0.1430804 * b;
        let y = 0.2225045 * r + 0.7168786 * g + 0.0606169 * b;
        let z = 0.0139322 * r + 0.0971045 * g + 0.7141733 * b;
        x *= 100;
        y *= 100;
        z *= 100;
        return new XyzColor(x, y, z);
    }
    static hexToRgb(c) {
        Preconditions.checkArgument(/^#[0-9a-f]{6}$/.test(c), 'non-compliant hex code');
        return RgbColor.fromHexString(c);
    }
}
const LAB_CONSTANTS = Object.freeze({
    D50: new XyzColor(96.42, 100, 82.51),
    κ: 24389 / 27,
    ε: 216 / 24389,
});
export class Difference {
    constructor() { }
    static de2000(color1, color2, kL = 1, kC = 1, kH = 1) {
        Preconditions.checkArgument(kL > 0);
        Preconditions.checkArgument(kC > 0);
        Preconditions.checkArgument(kH > 0);
        const { l: l1, a: a1, b: b1 } = Conversion.toLab(color1);
        const { l: l2, a: a2, b: b2 } = Conversion.toLab(color2);
        const lBarPrime = (l1 + l2) / 2;
        const c1 = Math.hypot(a1, b1);
        const c2 = Math.hypot(a2, b2);
        const cBar = (c1 + c2) / 2;
        const g = 0.5 * (1 - Math.sqrt(cBar ** 7 / (cBar ** 7 + 25 ** 7)));
        const a1Prime = a1 * (1 + g);
        const a2Prime = a2 * (1 + g);
        const c1Prime = Math.hypot(a1Prime, b1);
        const c2Prime = Math.hypot(a2Prime, b2);
        const cBarPrime = (c1Prime + c2Prime) / 2;
        const h1Prime = normalizeHue(radiansToDegrees(Math.atan2(b1, a1Prime)));
        const h2Prime = normalizeHue(radiansToDegrees(Math.atan2(b2, a2Prime)));
        const hBarPrime = Math.abs(h1Prime - h2Prime) > 180 ? (h1Prime + h2Prime + 360) / 2 : (h1Prime + h2Prime) / 2;
        const t = 1
            - 0.17 * Math.cos(degreesToRadians(hBarPrime - 30))
            + 0.24 * Math.cos(degreesToRadians(2 * hBarPrime))
            + 0.32 * Math.cos(degreesToRadians(3 * hBarPrime + 6))
            - 0.2 * Math.cos(degreesToRadians(4 * hBarPrime - 63));
        const ΔhPrime = Math.abs(h2Prime - h1Prime) <= 180
            ? h2Prime - h1Prime
            : h2Prime <= h1Prime
                ? h2Prime - h1Prime + 360
                : h2Prime - h1Prime - 360;
        const ΔLPrime = l2 - l1;
        const ΔCPrime = c2Prime - c1Prime;
        const ΔHPrime = 2 * Math.sqrt(c1Prime * c2Prime) * Math.sin(degreesToRadians(ΔhPrime / 2));
        const sL = 1 + (0.015 * (lBarPrime - 50) ** 2) / Math.sqrt(20 + (lBarPrime - 50) ** 2);
        const sC = 1 + 0.045 * cBarPrime;
        const sH = 1 + 0.015 * cBarPrime * t;
        const Δθ = 30 * Math.exp(-1 * ((hBarPrime - 275) / 25) ** 2);
        const rC = 2 * Math.sqrt(cBarPrime ** 7 / (cBarPrime ** 7 + 25 ** 7));
        const rT = -rC * Math.sin(degreesToRadians(2 * Δθ));
        return Math.sqrt((ΔLPrime / (kL * sL)) ** 2
            + (ΔCPrime / (kC * sC)) ** 2
            + (ΔHPrime / (kH * sH)) ** 2
            + (ΔCPrime / (kC * sC)) * (ΔHPrime / (kH * sH)) * rT);
    }
    static wcagContrast(c1, c2) {
        const l1 = Lightness.relativeLuminance(c1);
        const l2 = Lightness.relativeLuminance(c2);
        return l1 > l2 ? (l1 + 0.05) / (l2 + 0.05) : (l2 + 0.05) / (l1 + 0.05);
    }
    static apcaContrast(foreground, background) {
        const luminanceForApca = (color) => {
            const gamma = 2.4;
            const { r, g, b } = Conversion.toRgb(color);
            const gammaCorrection = (x) => Math.pow(x / 255.0, gamma);
            const rWeight = 0.2126729;
            const gWeight = 0.7151522;
            const bWeight = 0.072175;
            return (rWeight * gammaCorrection(r) + gWeight * gammaCorrection(g) + bWeight * gammaCorrection(b));
        };
        const positivePolarityBackgroundContrastExponent = 0.56;
        const positivePolarityForegroundContrastExponent = 0.57;
        const negativePolarityForegroundContrastExponent = 0.62;
        const negativePolarityBackgroundContrastExponent = 0.65;
        const blackLuminanceThreshold = 0.022;
        const contrastMin = 0.001;
        const deltaLuminanceMin = 0.0005;
        const contrastScaleFactor = 1.14;
        const contrastOffset = 0.027;
        const luminanceSoftClampExponent = 1.414;
        let foregroundLuminance = luminanceForApca(foreground);
        let backgroundLuminance = luminanceForApca(background);
        if (foregroundLuminance <= blackLuminanceThreshold) {
            foregroundLuminance += Math.pow(blackLuminanceThreshold - foregroundLuminance, luminanceSoftClampExponent);
        }
        if (backgroundLuminance <= blackLuminanceThreshold) {
            backgroundLuminance += Math.pow(blackLuminanceThreshold - backgroundLuminance, luminanceSoftClampExponent);
        }
        if (Math.abs(backgroundLuminance - foregroundLuminance) < deltaLuminanceMin) {
            return 0.0;
        }
        let contrast;
        if (backgroundLuminance > foregroundLuminance) {
            contrast =
                (Math.pow(backgroundLuminance, positivePolarityBackgroundContrastExponent)
                    - Math.pow(foregroundLuminance, positivePolarityForegroundContrastExponent))
                    * contrastScaleFactor;
            contrast = contrast < contrastMin ? 0.0 : contrast - contrastOffset;
        }
        else {
            contrast =
                (Math.pow(backgroundLuminance, negativePolarityBackgroundContrastExponent)
                    - Math.pow(foregroundLuminance, negativePolarityForegroundContrastExponent))
                    * contrastScaleFactor;
            contrast = contrast > -contrastMin ? 0.0 : contrast + contrastOffset;
        }
        return contrast * 100.0;
    }
}
export class Lightness {
    constructor() { }
    static relativeLuminance(color) {
        let { r, g, b } = Conversion.toRgb(color);
        const toLinear = (x) => (x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4);
        r /= 255;
        g /= 255;
        b /= 255;
        return 0.2126 * toLinear(r) + 0.7152 * toLinear(g) + 0.0722 * toLinear(b);
    }
    static relativeLuminanceToLightness(Y) {
        const { κ, ε } = LAB_CONSTANTS;
        return Y <= ε ? κ * Y : 116 * Math.cbrt(Y) - 16;
    }
}
function normalizeHue(h) {
    return h - Math.floor(h / 360) * 360;
}
function degreesToRadians(a) {
    return (a * Math.PI) / 180;
}
function radiansToDegrees(a) {
    return (a * 180) / Math.PI;
}
const SHORT_HEX_RE = /^#?([0-9a-f]{1})([0-9a-f]{1})([0-9a-f]{1})$/i;
const HEX_RE = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i;
const RGB_RE = /^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/;
const RGBA_RE = /^rgba\((\d+),\s*(\d+),\s*(\d+),\s*([0-9]*\.?[0-9]+)\)$/;
const HSL_RE = /^hsl(a?)\((\d{1,3})([ /,]+)(\d{1,3}%)([ /,]+)(\d{1,3}%)([ /,]*)([\d.]*)\)$/;
function toHex(n) {
    return (0x100 + n).toString(16).slice(-2);
}
function fromHex(s) {
    return parseInt(s, 16);
}
function percentToNorm(p) {
    return parseFloat(p.substring(0, p.length - 1)) / 100;
}
function normToU8(n) {
    return Math.round(n * 255);
}
function hslToRgb([h, s, l]) {
    if (s === 0) {
        return [l, l, l];
    }
    const saturated = tripletFromHue(h);
    const topBound = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const bottomBound = 2 * l - topBound;
    return [
        lerp(bottomBound, topBound, saturated[0]),
        lerp(bottomBound, topBound, saturated[1]),
        lerp(bottomBound, topBound, saturated[2]),
    ];
}
function lerp(a, b, mix) {
    return a + (b - a) * mix;
}
function tripletFromHue(hue) {
    hue = (hue + 1) % 1;
    const segmentProgress = (hue * 6) % 1;
    if (hue < 1 / 6) {
        return [1, segmentProgress, 0];
    }
    else if (hue < 2 / 6) {
        return [1 - segmentProgress, 1, 0];
    }
    else if (hue < 3 / 6) {
        return [0, 1, segmentProgress];
    }
    else if (hue < 4 / 6) {
        return [0, 1 - segmentProgress, 1];
    }
    else if (hue < 5 / 6) {
        return [segmentProgress, 0, 1];
    }
    else {
        return [1, 0, 1 - segmentProgress];
    }
}
