import { makeObservable } from '../../../../base/make_observable/make_observable';
import { __decorate } from "tslib";
import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import classNames from 'classnames';
import * as mobx from 'mobx';
import * as mobxReact from 'mobx-react';
import * as React from 'react';
import { Box } from '../../box/box';
import { Button } from '../../button/button';
import { AlphaSlider } from '../alpha_slider/alpha_slider';
import { ColorCodeInput } from '../color_code_input/color_code_input';
import { HueSlider } from '../hue_slider/hue_slider';
import { SatValPicker } from '../sat_val_picker/sat_val_picker';
import { DraggableView } from '../../draggable/draggable_view';
import { EyedropperIcon } from '../../icons/eyedropper/icon';
import { TrashSingleIcon } from '../../icons/trash_single/icon';
import { Sheet } from '../../sheet/sheet';
import { ColorPickerMessages } from '../color_picker.messages';
import styles from './internal_color_picker.css';
export const InternalColorPicker = React.memo(props => {
  const {
    color,
    sizingMode = 'fill',
    isSheet = sizingMode === 'fill',
    autoFocusHexInput = 'on-desktop',
    onStartEyedropper,
    onDeleteColor
  } = props;
  const {
    onChangeStart,
    onChangeComplete,
    onInputChange,
    onHueChange,
    onSatValChange,
    onAlphaChange
  } = props;
  const EyeDropperButton = React.useMemo(() => onStartEyedropper ? () => _jsx(EyedropperButton, {
    onStartEyedropper: onStartEyedropper,
    isSheet: isSheet
  }) : undefined, [onStartEyedropper, isSheet]);
  const DeleteColorButton = React.useMemo(() => onDeleteColor ? () => _jsx(DeleteColorButtonImpl, {
    onDeleteColor: onDeleteColor
  }) : undefined, [onDeleteColor]);
  if (sizingMode === 'fixed') {
    return _jsxs(_Fragment, {
      children: [_jsx(ColorPickerBody, {
        color: color,
        onChangeStart: onChangeStart,
        onChangeComplete: onChangeComplete,
        onHueChange: onHueChange,
        onSatValChange: onSatValChange,
        onAlphaChange: onAlphaChange
      }), _jsx(ColorPickerInputGroup, {
        autoFocusHexInput: autoFocusHexInput,
        color: color,
        hexInputSizingMode: "fill",
        onInputChange: onInputChange,
        onAlphaChange: onAlphaChange,
        EyeDropperButton: EyeDropperButton,
        DeleteColorButton: DeleteColorButton
      })]
    });
  }
  return _jsxs(_Fragment, {
    children: [_jsx("div", {
      className: styles.colorPickerHeader,
      children: _jsx(ColorPickerInputGroup, {
        color: color,
        hexInputSizingMode: "fixed",
        withColoredBox: true,
        onInputChange: onInputChange,
        onAlphaChange: onAlphaChange,
        EyeDropperButton: EyeDropperButton,
        DeleteColorButton: DeleteColorButton
      })
    }), _jsx(Box, {
      padding: "2u",
      children: _jsx(ColorPickerBody, {
        color: color,
        showDivider: true,
        onChangeStart: onChangeStart,
        onChangeComplete: onChangeComplete,
        onHueChange: onHueChange,
        onSatValChange: onSatValChange,
        onAlphaChange: onAlphaChange
      })
    })]
  });
});
const ColorPickerInputGroup = React.memo(props => _jsxs("div", {
  className: styles.colorInputSection,
  children: [props.DeleteColorButton && _jsx(props.DeleteColorButton, {}), _jsx("div", {
    className: classNames(styles.colorCodeInput, {
      [styles.fixedWithoutAlpha]: props.hexInputSizingMode === 'fixed' && props.onAlphaChange == null,
      [styles.fixedWithAlpha]: props.hexInputSizingMode === 'fixed' && props.onAlphaChange != null,
      [styles.fill]: props.hexInputSizingMode === 'fill'
    }),
    children: _jsx(ColorCodeInput, {
      autoFocus: props.autoFocusHexInput,
      color: props.color.toRgb().toHexString(),
      alpha: props.color.alpha,
      onAlphaChange: props.onAlphaChange,
      onChange: props.onInputChange,
      withSwatch: props.withColoredBox,
      ariaLabel: ColorPickerMessages.colorCodeInputLabel()
    })
  }), props.EyeDropperButton && _jsx(props.EyeDropperButton, {})]
}));
const ColorPickerBody = React.memo(props => _jsxs(_Fragment, {
  children: [_jsx(SatValPicker, {
    color: props.color,
    onChange: props.onSatValChange,
    onChangeStart: props.onChangeStart,
    onChangeComplete: props.onChangeComplete,
    Draggable: DraggableView
  }), props.showDivider && _jsx("div", {
    className: styles.divider
  }), _jsx(HueSlider, {
    hue: props.color.h,
    onDragStart: props.onChangeStart,
    onDragEnd: props.onChangeComplete,
    onChange: props.onHueChange,
    ariaLabel: ColorPickerMessages.colorCodeHueLabel()
  }), props.onAlphaChange && _jsx(AlphaSlider, {
    alpha: props.color.alpha,
    color: props.color.toRgb().toHexString(),
    onDragStart: props.onChangeStart,
    onDragEnd: props.onChangeComplete,
    onChange: props.onAlphaChange,
    ariaLabel: ColorPickerMessages.colorCodeAlphaLabel()
  })]
}));
let EyedropperButton = class EyedropperButton extends React.PureComponent {
  static _makeObservable(instance) {
    makeObservable(instance, {
      active: mobx.observable.ref,
      onStartEyedropper: mobx.action.bound
    });
  }
  constructor() {
    super(...arguments);
    EyedropperButton._makeObservable(this);
    this.active = false;
  }
  render() {
    const {
      isSheet
    } = this.props;
    return _jsxs(_Fragment, {
      children: [_jsx(Button, {
        variant: "tertiary",
        icon: EyedropperIcon,
        active: this.active,
        className: styles.eyedropperButton,
        tooltipLabel: ColorPickerMessages.eyedropperTooltip(),
        onClick: this.onStartEyedropper
      }), isSheet && _jsx(Sheet, {
        content: null,
        open: this.active
      })]
    });
  }
  onStartEyedropper(event) {
    this.active = true;
    this.props.onStartEyedropper(event).finally(mobx.action(() => this.active = false));
  }
};
EyedropperButton = __decorate([mobxReact.observer], EyedropperButton);
const DeleteColorButtonImpl = props => _jsx(Button, {
  variant: "tertiary",
  icon: TrashSingleIcon,
  className: styles.deleteColorButton,
  tooltipLabel: ColorPickerMessages.deleteColorTooltip(),
  onClick: props.onDeleteColor
});