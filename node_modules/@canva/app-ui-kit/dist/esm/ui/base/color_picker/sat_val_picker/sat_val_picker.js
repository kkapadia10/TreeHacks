import { jsx as _jsx } from "react/jsx-runtime";
import * as React from 'react';
import { Component } from 'react';
import { HsvColor } from '../hsv_color/hsv_color';
import styles from './sat_val_picker.css';
export class SatValPicker extends Component {
    constructor() {
        super(...arguments);
        this.captureRef = (ref) => {
            this.pickerRef = ref || undefined;
            ref === null || ref === void 0 ? void 0 : ref.addEventListener('touchmove', event => event.stopPropagation());
        };
        this.changing = false;
        this.stopChanging = () => {
            this.changing = false;
            if (this.props.onChangeComplete) {
                this.props.onChangeComplete();
            }
        };
        this.onKeyDown = (event) => {
            const INCREMENT = 0.01;
            const oldColor = this.props.color;
            let { s, v } = oldColor;
            switch (event.key) {
                case 'ArrowUp':
                    v += INCREMENT;
                    break;
                case 'ArrowDown':
                    v -= INCREMENT;
                    break;
                case 'ArrowLeft':
                    s -= INCREMENT;
                    break;
                case 'ArrowRight':
                    s += INCREMENT;
                    break;
                default:
                    return;
            }
            event.preventDefault();
            const clamp = (n) => Math.min(Math.max(0, n), 1);
            const newColor = new HsvColor(oldColor.h, clamp(s), clamp(v), oldColor.alpha);
            this.onChange(newColor);
        };
        this.onKeyUp = () => {
            this.stopChanging();
        };
        this.onMouseUp = () => {
            this.stopChanging();
        };
        this.onMouseDown = event => {
            if (event.button !== 0) {
                return;
            }
            this.pickerRef.focus();
            this.moveKnob(mouseToKnobCoords(this.pickerRef.getBoundingClientRect(), event));
        };
        this.onDragMove = (event) => {
            this.moveKnob(mouseToKnobCoords(this.pickerRef.getBoundingClientRect(), event));
        };
        this.onDragEnd = (event) => {
            this.stopChanging();
        };
    }
    render() {
        const { color, Draggable } = this.props;
        const knobPosition = {
            width: `${color.s * 100}%`,
            height: `${100 - color.v * 100}%`,
        };
        return (_jsx(
            Draggable,
            { onMouseDown: this.onMouseDown, onDragMove: this.onDragMove, onDragEnd: this.onDragEnd, children: ({
                onMouseDown,
                onTouchStart
            }) => (
                (_jsx(
                    "div",
                    { className: styles.root, onMouseDown: onMouseDown, onTouchStart: onTouchStart, onMouseUp: this.onMouseUp, onKeyDown: this.onKeyDown, onKeyUp: this.onKeyUp, ref: this.captureRef, 
                        tabIndex: 0, style: { backgroundColor: `hsl(${color.h * 360}, 100%, 50%)` }, children: _jsx("div", { className: styles.whiteGradient, children: _jsx("div", { className: styles.blackGradient, children: _jsx("div", { className: styles.knobPositioner, style: knobPosition, children: _jsx("div", { className: styles.knob, style: {
                                            backgroundColor: color.toRgb().toHexString(),
                                        } }) }) }) }) }
                ))) }
        ));
    }
    moveKnob(knob) {
        const newColor = new HsvColor(
        this.props.color.h, 
        knob.leftPercent, 
        1 - knob.topPercent, 
        this.props.color.alpha);
        this.onChange(newColor);
    }
    onChange(newColor) {
        const { onChange, onChangeStart, color: oldColor } = this.props;
        if (!this.changing) {
            this.changing = true;
            onChangeStart && onChangeStart();
        }
        if (!newColor.equals(oldColor)) {
            onChange(newColor);
        }
    }
}
export function mouseToKnobCoords(pickerRect, { clientX, clientY }) {
    const clamp = (val) => Math.min(1, Math.max(0, val));
    return {
        leftPercent: clamp((clientX - pickerRect.left) / pickerRect.width),
        topPercent: clamp((clientY - pickerRect.top) / pickerRect.height),
    };
}
