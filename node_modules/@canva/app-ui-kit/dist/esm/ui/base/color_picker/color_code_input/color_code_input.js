import { makeObservable } from '../../../../base/make_observable/make_observable';
import { __decorate } from "tslib";
import { jsx as _jsx } from "react/jsx-runtime";
import * as mobx from 'mobx';
import * as mobxReact from 'mobx-react';
import * as React from 'react';
import { RgbaColor, RgbColor } from '../../color/color';
import { TextDecorator } from '../../form/input/decorators/text_decorator';
import { NumberInput } from '../../form/input/number_input';
import { TextInput } from '../../form/input/text_input';
import { Swatch } from '../../swatch/swatch';
import styles from './color_code_input.css';
import { ColorCodeInputMessages } from './color_code_input.messages';
let ColorCodeInput = class ColorCodeInput extends React.Component {
  static _makeObservable(instance) {
    makeObservable(instance, {
      inputValue: mobx.observable.ref,
      onChange: mobx.action.bound,
      onAlphaChange: mobx.action.bound
    });
  }
  constructor() {
    super(...arguments);
    ColorCodeInput._makeObservable(this);
    this.input = React.createRef();
    this.inputValue = this.props.color;
    this.recentlyBlurred = false;
    this.onFocus = () => {
      if (!this.recentlyBlurred) {
        setTimeout(() => {
          var _a;
          return (_a = this.input.current) === null || _a === void 0 ? void 0 : _a.select();
        });
      }
    };
    this.onBlur = () => {
      this.recentlyBlurred = true;
      setTimeout(() => this.recentlyBlurred = false, 0);
    };
  }
  render() {
    const value = fudgeHex(this.inputValue) === this.props.color ? this.inputValue : this.props.color;
    return this.renderInput(value);
  }
  renderInput(value) {
    const shouldRenderAlpha = this.props.onAlphaChange != null;
    const {
      r,
      g,
      b
    } = RgbColor.fromHexString(fudgeHex(value));
    const valueWithAlpha = new RgbaColor(r, g, b, this.props.alpha).toRgbaString();
    return _jsx(TextInput, {
      inputClassName: styles.input,
      start: this.props.withSwatch ? _jsx(Swatch, {
        size: "xxsmall",
        fill: [valueWithAlpha]
      }) : undefined,
      value: value,
      end: shouldRenderAlpha && this.renderAlphaInput(),
      disableSpellcheck: true,
      onChange: this.onChange,
      onFocus: this.onFocus,
      onBlur: this.onBlur,
      ref: this.input,
      textAlignCenter: !shouldRenderAlpha,
      autoFocus: this.props.autoFocus,
      ariaLabel: this.props.ariaLabel,
      ariaLabelledBy: this.props.ariaLabelledBy,
      ariaDescribedBy: this.props.ariaDescribedBy
    });
  }
  renderAlphaInput() {
    const alpha = this.props.alpha == null ? 1 : this.props.alpha;
    const value = Math.round(alpha * 100);
    const percentageDecoration = _jsx(TextDecorator, {
      children: "%"
    });
    return _jsx("div", {
      className: styles.numInput,
      children: _jsx(NumberInput, {
        value: value,
        borderless: true,
        textAlignCenter: true,
        end: percentageDecoration,
        max: 100,
        min: 0,
        onChange: this.onAlphaChange,
        ariaLabel: ColorCodeInputMessages.alphaInputLabel()
      })
    });
  }
  onChange(code) {
    const inputLength = code.length;
    code = code.replace(/[^0-9a-f]/gi, '');
    const lengthDiff = inputLength - code.length;
    code = `#${code.slice(0, 6)}`;
    this.inputValue = code;
    this.props.onChange(fudgeHex(code));
    const inputRef = this.input.current;
    if (inputRef) {
      const cursorPosition = inputRef.selectionStart - lengthDiff + 1;
      inputRef.value = code;
      inputRef.selectionStart = cursorPosition;
      inputRef.selectionEnd = cursorPosition;
    }
  }
  onAlphaChange(alpha) {
    var _a, _b;
    const value = isNaN(alpha) ? 0 : Math.max(0, Math.min(100, alpha)) / 100;
    (_b = (_a = this.props).onAlphaChange) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  }
};
ColorCodeInput = __decorate([mobxReact.observer], ColorCodeInput);
export { ColorCodeInput };
const fudgeHex = hex => {
  hex = hex.toLowerCase().replace(/[^0-9a-f]/g, '').slice(0, 6);
  hex = hex || 'ffffff';
  if (hex.length <= 3) {
    hex += '0'.repeat(3 - hex.length);
    hex = hex[0].repeat(2) + hex[1].repeat(2) + hex[2].repeat(2);
  } else if (hex.length < 6) {
    hex += '0'.repeat(6 - hex.length);
  }
  return `#${hex}`;
};