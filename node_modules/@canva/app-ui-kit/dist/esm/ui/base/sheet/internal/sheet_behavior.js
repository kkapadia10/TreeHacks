import { makeObservable } from '../../../../base/make_observable/make_observable';
import { __decorate } from "tslib";
import { Preconditions, UnreachableError } from '../../../../base/preconditions';
import * as mobx from 'mobx';
import { PanRecognizer } from '../../gestures/gesture_recognizer';
const UPPER_SNAP_MULTIPLIER = 0.8;
const LOWER_SNAP_MULTIPLIER = 0.2;
const VELOCITY_THRESHOLD = 1;
const DEFAULT_SHEET_PEEK_HEIGHT = window.innerHeight * 0.44;
export class BottomSheetDragBehavior {
  static _makeObservable(instance) {
    makeObservable(instance, {
      sheetState: mobx.observable.ref,
      _hasTransition: mobx.observable.ref,
      _containerSize: mobx.observable.ref,
      _viewPortSize: mobx.observable.ref,
      _isPanning: mobx.observable.ref,
      _isSwiping: mobx.observable.ref,
      containerTransition: mobx.computed,
      containerMaxSizeInPeek: mobx.computed,
      isSwiping: mobx.computed,
      containerTransform: mobx.computed,
      transparentOverlay: mobx.computed,
      resetToPreviousSheetState: mobx.action.bound,
      setContainerHeightToContentHeight: mobx.action.bound,
      configureBounds: mobx.action,
      closeSheet: mobx.action.bound,
      onEventStart: mobx.action.bound,
      onMoveVertical: mobx.action.bound,
      onEndVertical: mobx.action.bound,
      animateToSheetState: mobx.action.bound,
      onViewportHeightChanges: mobx.action.bound,
      updateSheetState: mobx.action
    });
  }
  get containerTransition() {
    return this._hasTransition ? '' : 'none';
  }
  get containerMaxSizeInPeek() {
    if (this._isPanning || this.sheetState !== 'peek' || !this._containerSize) {
      return '';
    }
    return `${this._containerSize}px`;
  }
  get isSwiping() {
    return this._isSwiping || false;
  }
  get containerTransform() {
    if (!this._containerSize) {
      return '';
    }
    let size = this.snapSize;
    if (this._isPanning) {
      size = Math.min(this._viewPortSize - this.viewportTopOffset, this._containerSize);
    }
    return `translateY(-${size}px)`;
  }
  get transparentOverlay() {
    return this.sheetState !== 'expanded' && this.transparentOverlayOnPeek;
  }
  get hasPeekState() {
    return !!this.peekSizePx;
  }
  constructor(_window, onStateChanged, peekSizePx = DEFAULT_SHEET_PEEK_HEIGHT, transparentOverlayOnPeek = false, offsetForViewportHeight, onPanning, calculateNextState = calculateNextStateImpl) {
    BottomSheetDragBehavior._makeObservable(this);
    this._window = _window;
    this.onStateChanged = onStateChanged;
    this.peekSizePx = peekSizePx;
    this.transparentOverlayOnPeek = transparentOverlayOnPeek;
    this.onPanning = onPanning;
    this.calculateNextState = calculateNextState;
    this.sheetState = 'collapsed';
    this._hasTransition = true;
    this._viewPortSize = this._window.innerHeight;
    this._initialOpenSheetState = this.hasPeekState ? 'peek' : 'expanded';
    this.previousStaticSheetState = 'expanded';
    this.enableDragging = true;
    this.minSize = 0;
    this.midSize = 0;
    this.maxSize = 0;
    this.currentOpenState = false;
    this.recognizer = new PanRecognizer({
      minDistance: 4,
      direction: 'vertical',
      onStart: () => {
        if (!this.enableDragging) {
          return;
        }
        if (this.onPanning) {
          this.onPanning(true);
        }
        this.onEventStart();
      },
      onMove: e => {
        if (!this.enableDragging) {
          return;
        }
        if (isVerticalDirection(e)) {
          this.onMoveVertical(e);
        }
      },
      onEnd: e => {
        if (!this.enableDragging) {
          return;
        }
        if (this.onPanning) {
          this.onPanning(false);
        }
        this.onEndVertical(e);
      }
    });
    this.viewportTopOffset = offsetForViewportHeight || 0;
  }
  setInitialOpenSheetState(state) {
    this._initialOpenSheetState = state;
  }
  setEnableDragging(enable) {
    this.enableDragging = enable;
  }
  resetToPreviousSheetState() {
    if (this.sheetState !== 'collapsed') {
      this.updateSheetState(this.previousStaticSheetState);
    }
    this._containerSize = this.snapSize;
  }
  setContainerHeightToContentHeight(contentHeight) {
    this.contentHeight = contentHeight;
    if (contentHeight) {
      this.updateSheetState('peek');
    }
    this._containerSize = this.snapSize;
  }
  configureBounds(bound, open) {
    if (bound.height == null) {
      return;
    }
    if (this.currentOpenState !== open || this.maxSize < bound.height) {
      const size = Math.min(this._viewPortSize - this.viewportTopOffset, bound.height);
      this.maxSize = size;
      this.midSize = Math.min(this.peekSizePx, size);
      this.minSize = this.minSize > 0 ? this.minSize * size / 100 : 0;
      if (open) {
        this.updateSheetState(this.midSize >= this.maxSize ? 'expanded' : this._initialOpenSheetState);
        this._containerSize = this.snapSize;
      } else {
        this.updateSheetState('collapsed');
      }
    }
    this.currentOpenState = open;
  }
  closeSheet() {
    this.currentOpenState = false;
    this.updateSheetState('collapsed');
    this._containerSize = undefined;
  }
  onEventStart() {
    this._isPanning = true;
    if (this.hasPeekState) {
      Preconditions.checkArgument(this.midSize > 0, 'the peek height is not defined');
    }
    Preconditions.checkArgument(this.maxSize > 0, 'the max height is not defined');
  }
  onMoveVertical(e) {
    const deltaSize = this.snapSize - e.distanceY;
    this._hasTransition = false;
    const prevContainerSize = this._containerSize;
    this._containerSize = this.clampBetweenMinAndMaxSize(deltaSize);
    if (this._containerSize !== prevContainerSize) {
      this._isSwiping = true;
    }
  }
  onEndVertical(e) {
    this._isPanning = false;
    this._isSwiping = false;
    const direction = e.distanceY < 0 ? 'up' : 'down';
    const {
      hasPeekState,
      maxSize,
      midSize,
      contentHeight
    } = this;
    const deltaSize = this.snapSize - e.distanceY - e.velocityY;
    const velocity = Math.abs(e.velocityY);
    const state = this.calculateNextState({
      direction,
      deltaSize,
      velocity,
      hasPeekState,
      maxSize: contentHeight !== null && contentHeight !== void 0 ? contentHeight : maxSize,
      midSize: contentHeight != null ? contentHeight / 2 : midSize
    });
    const nextState = contentHeight != null && state === 'expanded' ? 'peek' : state;
    this.updateSheetState(nextState);
    this._hasTransition = true;
    this._containerSize = this.snapSize;
  }
  animateToSheetState(state) {
    if (state === 'peek' && !this.hasPeekState) {
      throw new Error();
    }

    this.updateSheetState(state);
    this._hasTransition = true;
    this._containerSize = this.snapSize;
  }
  onViewportHeightChanges(viewportHeight) {
    this.maxSize = viewportHeight - this.viewportTopOffset;
    this._containerSize = Math.min(this.snapSize, this.maxSize);
    this._viewPortSize = viewportHeight;
  }
  updateSheetState(state) {
    if (this.sheetState === state) {
      return;
    }
    if (this.contentHeight == null && state !== 'collapsed') {
      this.previousStaticSheetState = state;
    }
    this.sheetState = state;
    this.onStateChanged && this.onStateChanged(state);
  }
  get snapSize() {
    if (this.contentHeight != null) {
      return this.contentHeight;
    }
    switch (this.sheetState) {
      case 'peek':
        return this.midSize;
      case 'collapsed':
        return this.minSize;
      case 'expanded':
        return this.maxSize;
      default:
        throw new UnreachableError(this.sheetState);
    }
  }
  clampBetweenMinAndMaxSize(nextSheetSize) {
    var _a;
    return Math.min((_a = this.contentHeight) !== null && _a !== void 0 ? _a : this.maxSize, Math.max(this.minSize, nextSheetSize));
  }
}
export function isVerticalDirection(e) {
  return e.direction === 'up' || e.direction === 'down' || e.direction === 'none';
}
export function calculateNextStateImpl(
  {
    direction,
    deltaSize,
    velocity,
    hasPeekState,
    midSize,
    maxSize
  }
) {
  let threshold = 0;
  switch (direction) {
    case 'up':
    case 'right':
      if (hasPeekState) {
        if (deltaSize <= midSize) {
          threshold = LOWER_SNAP_MULTIPLIER * midSize;
          if (deltaSize >= threshold || velocity >= VELOCITY_THRESHOLD) {
            return 'peek';
          } else {
            return 'collapsed';
          }
        } else {
          threshold = UPPER_SNAP_MULTIPLIER * (maxSize - midSize);
          if (maxSize - deltaSize <= threshold || velocity >= VELOCITY_THRESHOLD) {
            return 'expanded';
          } else {
            return 'peek';
          }
        }
      } else {
        threshold = LOWER_SNAP_MULTIPLIER * maxSize;
        if (deltaSize >= threshold || velocity >= VELOCITY_THRESHOLD) {
          return 'expanded';
        } else {
          return 'collapsed';
        }
      }
    case 'down':
    case 'left':
      if (hasPeekState) {
        if (deltaSize >= midSize) {
          threshold = UPPER_SNAP_MULTIPLIER * (maxSize - midSize);
          if (deltaSize - midSize <= threshold || velocity >= VELOCITY_THRESHOLD) {
            return 'peek';
          } else {
            return 'expanded';
          }
        } else {
          threshold = UPPER_SNAP_MULTIPLIER * midSize;
          if (deltaSize <= threshold || velocity >= VELOCITY_THRESHOLD) {
            return 'collapsed';
          } else {
            return 'peek';
          }
        }
      } else {
        threshold = UPPER_SNAP_MULTIPLIER * maxSize;
        if (deltaSize <= threshold || velocity >= VELOCITY_THRESHOLD) {
          return 'collapsed';
        } else {
          return 'expanded';
        }
      }
    default:
      throw new UnreachableError(direction);
  }
}