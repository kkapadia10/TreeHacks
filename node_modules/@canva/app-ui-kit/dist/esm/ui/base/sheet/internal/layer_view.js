import { makeObservable } from '../../../../base/make_observable/make_observable';
import { __decorate } from "tslib";
import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { Preconditions, UnreachableError } from '../../../../base/preconditions';
import classNames from 'classnames';
import * as mobx from 'mobx';
import * as mobxReact from 'mobx-react';
import * as React from 'react';
import Measure, { withContentRect } from 'react-measure';
import { PanRecognizer } from '../../gestures/gesture_recognizer';
import { GestureRecognizerView } from '../../gestures/gesture_recognizer_view';
import { getSafeAreaInsets } from '../../platform_quirks/get_safe_area_insets';
import { Overlay } from './overlay';
import styles from './sheet.css';
import { SheetMessages } from './sheet.messages';
import { isVerticalDirection } from './sheet_behavior';
export const ANIMATION_TIME = parseInt(styles.animationTime, 10);
const HANDLE_HEIGHT = parseInt(styles.handleSize, 10);
const DRAGGING_THRESHOLD_MULTIPLIER = 0.2;
const VELOCITY_THRESHOLD = 1;
let LayerViewUnMeasured = class LayerViewUnMeasured extends React.Component {
  static _makeObservable(instance) {
    makeObservable(instance, {
      viewContainerStyle: mobx.observable.struct,
      updateViewContainerStyle: mobx.action.bound,
      onPreviousTransitionEnd: mobx.action,
      onContainerTransitionEnd: mobx.action
    });
  }
  constructor() {
    super(...arguments);
    LayerViewUnMeasured._makeObservable(this);
    this.containerRef = React.createRef();
    this.viewContainerStyle = {
      width: this.props.window.innerWidth,
      height: this.props.window.innerHeight,
      top: 0,
      left: 0
    };
    this.viewportResizeDirection = 0;
    this.trackedMeasure = 0;
    this.visibleAreaSize = 0;
    this.initialTransform = '';
    this.initialMaxHeight = '';
    this.onDraggableHandlePanStart = () => {
      var _a;
      if (!((_a = this.props.layer.current) === null || _a === void 0 ? void 0 : _a.props.enableLayerDraggable) || !this.containerRef.current) {
        return;
      }
      this.initialTransform = this.containerRef.current.style.transform;
      this.initialMaxHeight = this.containerRef.current.style.maxHeight;
      this.containerRef.current.style.maxHeight = '';
      this.containerRef.current.style.transition = 'none';
    };
    this.onDraggableHandlePanMove = e => {
      var _a;
      if (!((_a = this.props.layer.current) === null || _a === void 0 ? void 0 : _a.props.enableLayerDraggable) || !this.containerRef.current) {
        return;
      }
      if (isVerticalDirection(e)) {
        const nextSize = this.visibleAreaSize - e.distanceY;
        const clampedNextSize = Math.max(0, Math.min(this.measuredSize, nextSize));
        this.containerRef.current.style.transform = `translateY(-${clampedNextSize}px)`;
      }
    };
    this.onDraggableHandlePanEnd = e => {
      var _a;
      if (!((_a = this.props.layer.current) === null || _a === void 0 ? void 0 : _a.props.enableLayerDraggable) || !this.containerRef.current) {
        return;
      }
      this.containerRef.current.style.transition = '';
      this.containerRef.current.style.transform = this.initialTransform;
      this.containerRef.current.style.maxHeight = this.initialMaxHeight;
      const {
        onLayerDraggingThresholdTriggered
      } = this.props.layer.current.props;
      const direction = e.distanceY < 0 ? 'opening' : 'closing';
      const draggingThreshold = this.visibleAreaSize * DRAGGING_THRESHOLD_MULTIPLIER;
      const passedDraggingThreshold = Math.abs(e.distanceY) > draggingThreshold;
      const passedVelocityThreshold = Math.abs(e.velocityY) > VELOCITY_THRESHOLD;
      if (passedDraggingThreshold || passedVelocityThreshold) {
        onLayerDraggingThresholdTriggered && onLayerDraggingThresholdTriggered({
          direction
        });
      }
    };
    this.recognizers = this.props.layer.from === 'bottom' ? [new PanRecognizer({
      minDistance: 4,
      direction: 'vertical',
      onStart: this.onDraggableHandlePanStart,
      onMove: this.onDraggableHandlePanMove,
      onEnd: this.onDraggableHandlePanEnd
    })] : undefined;
    this.contentParentLayerContainer = this.createLayerContainer();
    this.viewContainerRef = ref => {
      var _a;
      (_a = this.viewContainerReactionDisposer) === null || _a === void 0 ? void 0 : _a.call(this);
      if (ref == null) {
        return;
      }
      ref.appendChild(this.contentParentLayerContainer);
      this.viewContainerReactionDisposer = mobx.reaction(() => this.props.layer.current, (currentLayer, previousLayer) => {
        if (previousLayer != null) {
          previousLayer.parentLayerContainer = undefined;
        }
        if (currentLayer != null) {
          currentLayer.parentLayerContainer = this.contentParentLayerContainer;
        }
      }, {
        fireImmediately: true
      });
    };
    this.previousContentRef = ref => {
      const {
        previous
      } = this.props.layer;
      const element = previous && previous.contentElement;
      if (ref && element) {
        const elementToAdd = this.maybeGetRecognizers(previous) ? applySheetContainerStylesTo(element, this.sheetContentContainerStyles) : element;
        ref.appendChild(elementToAdd);
        this.maybeTriggerTopOfLayerChange(previous, false);
      }
    };
    this.currentContentRef = ref => {
      const {
        layer,
        measureRef
      } = this.props;
      const {
        current
      } = layer;
      const element = current && current.contentElement;
      if (ref && element) {
        const elementToAdd = this.maybeGetRecognizers(current) ? applySheetContainerStylesTo(element, this.sheetContentContainerStyles) : element;
        ref.appendChild(elementToAdd);
        this.maybeTriggerTopOfLayerChange(current, true);
      }
      measureRef(ref);
      layer.currentMounted = !!ref;
      this.currentRef = ref || undefined;
    };
    this.previousOuterContentRef = ref => {
      const element = this.props.layer.previous && this.props.layer.previous.outerElement;
      ref && element && ref.appendChild(element);
    };
    this.currentOuterContentRef = ref => {
      const element = this.props.layer.current && this.props.layer.current.outerElement;
      ref && element && ref.appendChild(element);
    };
    this.onPreviousTransitionEnd = () => {
      this.props.layer.previous = undefined;
    };
    this.onContainerTransitionEnd = () => {
      this.props.onLayerClose(this.props.layer);
    };
    this.onSafeAreaResize = () => {
      const {
        layer,
        measure
      } = this.props;
      if (!layer.currentMounted) {
        return;
      }
      measure();
    };
  }
  get didViewportResize() {
    return this.viewportResizeDirection !== 0;
  }
  get safeAreaInsetTop() {
    const current = this.props.layer.current;
    const hasHandle = !!this.maybeGetRecognizers(current);
    return current == null || current.applyInsetStyles || hasHandle ? getSafeAreaInsets().top : 0;
  }
  get maxVisibleSize() {
    const {
      current
    } = this.props.layer;
    if (!(current === null || current === void 0 ? void 0 : current.props.enableLayerDraggable)) {
      return undefined;
    }
    return current.props.maxVisibleSizePx;
  }
  get measuredSize() {
    var _a;
    const {
      layer,
      contentRect
    } = this.props;
    const {
      width,
      height
    } = contentRect.bounds;
    const measuredSize = (_a = layer.isHorizontal ? width : height) !== null && _a !== void 0 ? _a : 0;
    return Math.max(0, measuredSize);
  }
  get viewportSize() {
    const {
      props: {
        layer
      },
      viewContainerStyle: {
        width,
        height
      }
    } = this;
    return layer.isHorizontal ? width : height;
  }
  maybeGetRecognizers(sheet) {
    if (sheet == null) {
      return;
    }
    const {
      props: {
        enableLayerDraggable
      },
      sheetDragInternal
    } = sheet;
    return enableLayerDraggable ? this.recognizers : sheetDragInternal === null || sheetDragInternal === void 0 ? void 0 : sheetDragInternal.recognizers;
  }
  render() {
    const {
      contentRect,
      layer
    } = this.props;
    const {
      current,
      previous,
      hasOuterContent,
      enableAnimations
    } = layer;
    const {
      style,
      className
    } = this.getContainerStyles();
    const outerContentStyles = this.getOuterContentStyles();
    const sheetBehavior = current && current.sheetDragInternal && current.sheetDragInternal.sheetBehavior;
    const overlayOpacity = (sheetBehavior === null || sheetBehavior === void 0 ? void 0 : sheetBehavior.transparentOverlay) ? 'transparent' : current === null || current === void 0 ? void 0 : current.props.overlayOpacity;
    const showOverlay = Boolean(current && current.show && current.props.overlay
    && contentRect && contentRect.bounds && contentRect.bounds.width != null);
    return _jsxs(_Fragment, {
      children: [_jsx(Overlay, {
        ariaLabel: (current === null || current === void 0 ? void 0 : current.props.closeSheetText) || SheetMessages.closeSheetText(),
        show: showOverlay,
        opacity: overlayOpacity,
        transitionTimeout: enableAnimations ? ANIMATION_TIME : 0,
        onClick: current === null || current === void 0 ? void 0 : current.props.onRequestClose
      }), _jsxs("div", {
        id: current === null || current === void 0 ? void 0 : current.props.id,
        role: (current === null || current === void 0 ? void 0 : current.props.role) || undefined,
        "aria-roledescription": current === null || current === void 0 ? void 0 : current.props.ariaRoleDescription,
        className: styles.viewContainer,
        style: this.viewContainerStyle,
        ref: this.viewContainerRef,
        children: [hasOuterContent && _jsxs("div", {
          className: classNames(styles.outerContainer, !enableAnimations && styles.disableAnimations),
          style: outerContentStyles,
          children: [previous && _jsx("div", {
            className: current ? styles.hiddenSheet : styles.visibleSheet,
            ref: this.previousOuterContentRef
          }, previous.id), current && _jsx("div", {
            className: previous ? styles.hiddenSheet : styles.visibleSheet,
            ref: this.currentOuterContentRef
          }, current.id)]
        }), _jsxs("div", {
          className: className,
          style: style,
          onTransitionEnd: this.onContainerTransitionEnd,
          ref: this.containerRef,
          children: [previous && _jsx("div", {
            className: current ? styles.hiddenSheet : styles.visibleSheet,
            style: previous.contentStyles,
            onTransitionEnd: this.onPreviousTransitionEnd,
            ref: this.previousContentRef,
            children: _jsx(DragHandle, {
              recognizers: this.maybeGetRecognizers(previous),
              contrastHandle: previous.props.overlay
            })
          }, previous.id), current && _jsx("div", {
            className: previous ? styles.hiddenSheet : styles.visibleSheet,
            tabIndex: -1,
            style: current.contentStyles,
            ref: this.currentContentRef,
            children: _jsx(DragHandle, {
              recognizers: this.maybeGetRecognizers(current),
              contrastHandle: current.props.overlay
            })
          }, current.id), (current === null || current === void 0 ? void 0 : current.applyInsetStyles) && !current.props.sheetContainsTextInput && _jsx(Measure, {
            bounds: true,
            onResize: this.onSafeAreaResize,
            children: ({
              measureRef
            }) => _jsx("div", {
              ref: measureRef,
              className: styles.safeAreaObserver
            })
          })]
        })]
      })]
    });
  }
  componentDidMount() {
    const {
      visualViewport
    } = this.props.window;
    if (visualViewport) {
      this.updateViewContainerStyle();
      visualViewport.addEventListener('resize', this.updateViewContainerStyle);
      visualViewport.addEventListener('scroll', this.updateViewContainerStyle);
      mobxReact.disposeOnUnmount(this, () => {
        visualViewport.removeEventListener('resize', this.updateViewContainerStyle);
        visualViewport.removeEventListener('scroll', this.updateViewContainerStyle);
      });
    }
    mobxReact.disposeOnUnmount(this, [mobx.autorun(
    () => {
      var _a;
      const {
        layer: {
          current
        }
      } = this.props;
      const sheetBehavior = (_a = current === null || current === void 0 ? void 0 : current.sheetDragInternal) === null || _a === void 0 ? void 0 : _a.sheetBehavior;
      const {
        current: containerElement
      } = this.containerRef;
      if (!sheetBehavior || !containerElement) {
        return;
      }
      containerElement.style.transform = sheetBehavior.containerTransform;
      containerElement.style.transition = sheetBehavior.containerTransition;
    }, {
      scheduler: requestAnimationFrame
    }), mobx.reaction(() => {
      var _a;
      return (_a = this.props.layer.current) === null || _a === void 0 ? void 0 : _a.show;
    }, shown => {
      const {
        current: containerElement
      } = this.containerRef;
      if (shown || !containerElement) {
        return;
      }
      containerElement.style.transition = '';
    }),
    mobx.reaction(() => {
      var _a, _b, _c;
      return (_c = (_b = (_a = this.props.layer.current) === null || _a === void 0 ? void 0 : _a.sheetDragInternal) === null || _b === void 0 ? void 0 : _b.sheetBehavior) === null || _c === void 0 ? void 0 : _c.containerMaxSizeInPeek;
    }, maxSize => {
      const {
        current: containerElement
      } = this.containerRef;
      if (maxSize || !containerElement) {
        return;
      }
      containerElement.style.maxHeight = '';
    }, {
      scheduler: requestAnimationFrame
    }),
    mobx.reaction(() => {
      var _a, _b, _c;
      return (_c = (_b = (_a = this.props.layer.current) === null || _a === void 0 ? void 0 : _a.sheetDragInternal) === null || _b === void 0 ? void 0 : _b.sheetBehavior) === null || _c === void 0 ? void 0 : _c.containerMaxSizeInPeek;
    }, maxSize => {
      const {
        current: containerElement
      } = this.containerRef;
      if (!maxSize || !containerElement) {
        return;
      }
      containerElement.style.maxHeight = maxSize;
    }, {
      delay: ANIMATION_TIME
    })]);
  }
  updateViewContainerStyle() {
    const visualViewport = Preconditions.checkExists(this.props.window.visualViewport);
    this.viewportResizeDirection = this.props.layer.isHorizontal ? visualViewport.width - this.viewContainerStyle.width : visualViewport.height - this.viewContainerStyle.height;
    this.viewportResizeDirection < 0 && (this.trackedMeasure = this.measuredSize);
    this.viewContainerStyle = {
      left: visualViewport.offsetLeft,
      top: visualViewport.offsetTop,
      width: visualViewport.width,
      height: visualViewport.height
    };
    const {
      layer: {
        current
      }
    } = this.props;
    const sheetBehavior = current && current.sheetDragInternal && current.sheetDragInternal.sheetBehavior;
    if (sheetBehavior) {
      sheetBehavior.onViewportHeightChanges(visualViewport.height);
    }
  }
  componentDidUpdate() {
    var _a, _b;
    const {
      layer: {
        current,
        previous
      },
      contentRect: {
        bounds
      }
    } = this.props;
    const onContentResize = !previous && current && current.props.onContentResize;
    const handleHeight = (current === null || current === void 0 ? void 0 : current.props.enableLayerDraggable) ? HANDLE_HEIGHT : 0;
    if (onContentResize && bounds && bounds.height !== handleHeight) {
      onContentResize(bounds);
    }
    const globalWindow = window;
    const {
      window: propWindow
    } = this.props;
    if (this.didViewportResize && current && current.show && current.props.overlay && isInputElement(propWindow.document.activeElement, globalWindow)) {
      (_b = (_a = propWindow.document.activeElement) === null || _a === void 0 ? void 0 : _a.scrollIntoView) === null || _b === void 0 ? void 0 : _b.call(_a, {
        block: 'center',
        inline: 'center'
      });
    }
    window.requestAnimationFrame(() => this.viewportResizeDirection = 0);
    if (this.currentRef && current && current.autoFocusOnOpen && this.currentFocused !== current.id) {
      this.currentFocused = current.id;
      this.currentRef.focus();
    } else if (!current || !current.props.open) {
      this.currentFocused = undefined;
    }
    if (current && current.sheetDragInternal) {
      const sheetBehavior = current.sheetDragInternal.sheetBehavior;
      sheetBehavior && bounds && sheetBehavior.configureBounds(bounds, !!current.props.open);
    }
  }
  maybeTriggerTopOfLayerChange(sheet, onTop) {
    sheet && sheet.props.onTopOfLayerChange && sheet.props.onTopOfLayerChange(onTop);
  }
  createLayerContainer() {
    const element = this.props.window.document.createElement('div');
    element.classList.add(styles.layerContainer);
    return element;
  }
  getContainerSize() {
    var _a;
    const {
      layer
    } = this.props;
    if (!(layer.current && layer.current.show)) {
      return 0;
    }
    const measuredSize = this.measuredSize;
    if (measuredSize <= 0) {
      return 0;
    }
    const viewportSizeWithOffset = layer.isHorizontal ? this.viewportSize : this.viewportSize - this.safeAreaInsetTop;
    if (layer.current.props.enableLayerDraggable && this.viewportResizeDirection > 0) {
      return Math.min(viewportSizeWithOffset, Math.max(this.trackedMeasure, measuredSize));
    }
    const peekSizePx = (_a = layer.current && layer.current.sheetDragInternal && layer.current.sheetDragInternal.sheetBehavior && layer.current.sheetDragInternal.sheetBehavior.peekSizePx) !== null && _a !== void 0 ? _a : 0;
    if (peekSizePx > 0) {
      return peekSizePx;
    }
    if (this.maxVisibleSize != null) {
      return Math.min(viewportSizeWithOffset, Math.min(measuredSize, this.maxVisibleSize));
    }
    return Math.min(viewportSizeWithOffset, measuredSize);
  }
  get sheetContentContainerStyles() {
    const {
      layer: {
        current
      }
    } = this.props;
    const backgroundColor = current === null || current === void 0 ? void 0 : current.props.backgroundColor;
    const isFullScreen = current === null || current === void 0 ? void 0 : current.isFullscreen;
    const smallRoundedCorners = !isFullScreen && (current === null || current === void 0 ? void 0 : current.roundedCorners) === 'small';
    const largeRoundedCorners = !isFullScreen && (current === null || current === void 0 ? void 0 : current.roundedCorners) === 'large';
    const hasHandle = !!this.maybeGetRecognizers(current);
    const className = classNames(styles.contentContainer, {
      [styles.borderRadius]: smallRoundedCorners,
      [styles.borderRadiusLarge]: largeRoundedCorners,
      [styles.hasShadow]: current === null || current === void 0 ? void 0 : current.props.hasShadow,
      [styles.hasHandle]: hasHandle
    });
    return {
      className,
      style: {
        backgroundColor
      }
    };
  }
  getContainerStyles() {
    var _a, _b;
    const {
      layer
    } = this.props;
    const {
      current,
      from,
      enableAnimations
    } = layer;
    const isFullScreen = current === null || current === void 0 ? void 0 : current.isFullscreen;
    const sheetContainerStyles = !this.maybeGetRecognizers(current) ? this.sheetContentContainerStyles : undefined;
    const backgroundColor = sheetContainerStyles && sheetContainerStyles.style.backgroundColor;
    const size = this.getContainerSize();
    this.visibleAreaSize = size;
    const viewportWithOffset = this.viewportSize - this.safeAreaInsetTop;
    const containerMaxSizeInPeek = (_b = (_a = current === null || current === void 0 ? void 0 : current.sheetDragInternal) === null || _a === void 0 ? void 0 : _a.sheetBehavior) === null || _b === void 0 ? void 0 : _b.containerMaxSizeInPeek;
    const maxPeekHeight = containerMaxSizeInPeek === '' ? undefined : containerMaxSizeInPeek;
    const maxFullHeight = this.maxVisibleSize ? `${Math.min(viewportWithOffset, this.maxVisibleSize)}px` : viewportWithOffset;
    const maxHeight = maxPeekHeight !== null && maxPeekHeight !== void 0 ? maxPeekHeight : maxFullHeight;
    const isSheetVisible = size > 0;
    const commonClassNames = classNames(sheetContainerStyles === null || sheetContainerStyles === void 0 ? void 0 : sheetContainerStyles.className, current === null || current === void 0 ? void 0 : current.themeClass, {
      [styles.applyInsets]: (current === null || current === void 0 ? void 0 : current.applyInsetStyles) && !(current === null || current === void 0 ? void 0 : current.props.sheetContainsTextInput),
      [styles.containsTextInput]: current === null || current === void 0 ? void 0 : current.props.sheetContainsTextInput,
      [styles.disableAnimations]: !enableAnimations,
      [styles.slideIn]: !this.didViewportResize && isSheetVisible,
      [styles.slideOut]: !this.didViewportResize && !isSheetVisible,
      [styles.displayOverflow]: (current === null || current === void 0 ? void 0 : current.props.enableOverflow) === true
    });
    switch (from) {
      case 'top':
        return {
          style: {
            transform: `translateY(${size}px)`,
            backgroundColor
          },
          className: classNames(styles.top, commonClassNames)
        };
      case 'bottom':
        return {
          style: !enableAnimations && isFullScreen ? {
            top: 0,
            backgroundColor
          } : {
            transform: `translateY(-${size}px)`,
            backgroundColor,
            maxHeight
          },
          className: classNames(styles.bottom, commonClassNames, {
            [styles.top]: isFullScreen && !enableAnimations
          })
        };
      case 'left':
        return {
          style: {
            transform: `translateX(${size}px)`,
            backgroundColor
          },
          className: classNames(styles.left, commonClassNames)
        };
      case 'right':
        return {
          style: {
            transform: `translateX(-${size}px)`,
            backgroundColor
          },
          className: classNames(styles.right, commonClassNames)
        };
      default:
        throw new UnreachableError(from);
    }
  }
  getOuterContentStyles() {
    const {
      from,
      isHorizontal
    } = this.props.layer;
    const size = this.getContainerSize();
    return isHorizontal ? {
      width: `calc(100% - ${size}px)`,
      top: 0,
      bottom: 0,
      left: from === 'left' ? undefined : 0,
      right: from === 'right' ? undefined : 0
    } : {
      height: `calc(100% - ${size}px)`,
      left: 0,
      right: 0,
      top: from === 'top' ? undefined : 0,
      bottom: from === 'bottom' ? undefined : 0
    };
  }
};
LayerViewUnMeasured = __decorate([mobxReact.observer], LayerViewUnMeasured);
const DragHandle = React.memo(({
  recognizers,
  contrastHandle
}) => {
  if (!recognizers) {
    return null;
  }
  return _jsx(GestureRecognizerView, {
    recognizers: recognizers,
    children: ({
      gestureRef
    }) => _jsx("div", {
      ref: gestureRef,
      className: styles.handle,
      children: _jsx("div", {
        className: classNames(styles.handleTab, {
          [styles.contrast]: contrastHandle
        })
      })
    })
  });
});
const applySheetContainerStylesTo = (element, styles) => {
  var _a;
  const {
    className,
    style
  } = styles;
  element.className = classNames(element.className, className);
  element.style.backgroundColor = (_a = style.backgroundColor) !== null && _a !== void 0 ? _a : '';
  return element;
};
export const LayerView = withContentRect('bounds')(LayerViewUnMeasured);
function isInputElement(element, _window) {
  return element instanceof _window.HTMLTextAreaElement || element instanceof _window.HTMLInputElement && element.type !== 'submit';
}