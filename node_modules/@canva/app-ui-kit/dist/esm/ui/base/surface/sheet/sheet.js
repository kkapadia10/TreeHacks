var _a, _b;
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import composeRefs from '@seznam/compose-react-refs';
import { Preconditions, UnreachableError } from '../../../../base/preconditions';
import classNames from 'classnames';
import * as React from 'react';
import { CSSTransition } from 'react-transition-group';
import { getVirtualKeyboardOverlayHeight } from '../../device_capabilities/keyboard';
import { Layer } from '../../layer/layer';
import { Spacer } from '../../layout/spacer/spacer';
import { getSafeAreaInsets } from '../../platform_quirks/get_safe_area_insets';
import { useEnableAnimations } from '../../provider/provider';
import { useStableFunction } from '../../stable_function/stable_function';
import { ContentContainer } from '../internal/content_container';
import { useSheetControls, useSheetDrag, useSheetScroll } from './behavior';
import { useContentScrollable } from './internal/content_scrollable';
import { useViewportHeightDifference } from './internal/viewport_difference';
import { useVisualViewport } from './internal/visual_viewport';
import styles, { customProperties } from './sheet.css';
export const Sheet = React.forwardRef(function Sheet({ open, onCloseComplete, ...inner }, ref) {
    const Wrapper = useEnableAnimations() ? TransitionWrapper : StaticWrapper;
    return (_jsx(Wrapper, { open: open, onCloseComplete: onCloseComplete, children: _jsx(SheetInner, { ...inner, handleRef: ref }) }));
});
const TRANSITION_DURATION = parseInt(styles.transitionTime, 10);
const TRANSITION_CLASS_NAMES = {
    appear: styles.transitioning,
    enter: styles.transitioning,
    exit: styles.transitioning,
    appearActive: styles.visible,
    appearDone: styles.visible,
    enterActive: styles.visible,
    enterDone: styles.visible,
};
function TransitionWrapper({ open: propOpen, onCloseComplete, children }) {
    const [transitionOpen, setTransitionOpen] = React.useState(propOpen);
    const nodeRef = React.useRef(null);
    return (_jsx(Layer, { open: propOpen || transitionOpen, children: _jsx(CSSTransition, { in: propOpen, appear: true, timeout: TRANSITION_DURATION, classNames: TRANSITION_CLASS_NAMES, onEnter: () => setTransitionOpen(true), onExited: () => {
                setTransitionOpen(false);
                onCloseComplete === null || onCloseComplete === void 0 ? void 0 : onCloseComplete();
            }, nodeRef: nodeRef, children: _jsx("div", { ref: nodeRef, children: children }) }) }));
}
function StaticWrapper({ open, onCloseComplete, children }) {
    const prevOpen = React.useRef(open);
    React.useEffect(() => {
        if (prevOpen.current && !open) {
            onCloseComplete === null || onCloseComplete === void 0 ? void 0 : onCloseComplete();
        }
        prevOpen.current = open;
    }, [open, onCloseComplete]);
    return (_jsx(Layer, { open: open, children: _jsx("div", { className: styles.visible, children: children }) }));
}
const heightMap = {
    ['half']: 52,
    ['full']: 100,
};
const dismissPoint = { type: 'fixed', height: 0 };
const isSafari = !!((_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent.match(/AppleWebKit\//))
    && !((_b = window.navigator) === null || _b === void 0 ? void 0 : _b.userAgent.match(/(Chrome|Chromium)\//));
function resolveHeight(height) {
    if (height === 'auto') {
        height = { autoUpTo: 'full' };
    }
    return typeof height === 'string'
        ? { type: 'fixed', height: heightMap[height] }
        : { type: 'auto', height: heightMap[height.autoUpTo] };
}
function SheetInner({ handleRef, height = 'auto', scrollToResizeBelow, onRequestClose, backdropVisible = true, handleSafeAreaInsetBottom = true, id, children, ...contentContainerProps }) {
    var _a, _b;
    const heights = Array.isArray(height) ? height : [height];
    Preconditions.checkArgument(heights.length > 0, 'Sheets require at least one height value');
    const snapPoints = [
        ...heights.map(resolveHeight),
        ...(onRequestClose != null ? [dismissPoint] : []),
    ];
    const [snapPointIndex, setSnapPointIndex] = useStabilizedSnapPoint(snapPoints);
    const containerRef = React.useRef(null);
    const contentRef = React.useRef(null);
    React.useImperativeHandle(handleRef, () => ({
        setHeight: height => {
            const newPoint = resolveHeight(height);
            const newIndex = snapPoints.findIndex(point => pointsEqual(point, newPoint));
            Preconditions.checkArgument(newIndex !== -1);
            setSnapPointIndex(newIndex);
        },
        scrollTo: options => { var _a; return (_a = contentRef.current) === null || _a === void 0 ? void 0 : _a.scrollTo(options); },
    }));
    const { resizing, controls } = useSheetControls({
        snapPoints,
        snapPointIndex,
        setSnapPointIndex: index => {
            setSnapPointIndex(index);
            if (onRequestClose != null && snapPoints[index] === dismissPoint) {
                onRequestClose();
            }
        },
        getScrollHeight: () => {
            const el = containerRef.current;
            if (el == null) {
                return 0;
            }
            const snapHeight = el.style.getPropertyValue(customProperties.snapHeight);
            const isAuto = el.classList.contains(styles.auto);
            el.style.setProperty(customProperties.snapHeight, '100%');
            el.classList.add(styles.auto);
            const scrollHeight = el.scrollHeight;
            el.style.setProperty(customProperties.snapHeight, snapHeight);
            el.classList.toggle(styles.auto, isAuto);
            return scrollHeight;
        },
        setOffset: offset => {
            const el = containerRef.current;
            if (el == null) {
                return;
            }
            el.style.transform = offset != null ? `translateY(${-offset}px)` : '';
        },
    });
    const viewportDifferenceHeight = useViewportHeightDifference();
    const visualViewport = useVisualViewport();
    const virtualKeyboardHeight = getVirtualKeyboardOverlayHeight() + 'px';
    const hasHandle = heights.length > 1;
    const snapPoint = snapPoints[snapPointIndex];
    const snapHeight = calculateSnapHeight(snapPoint, resizing, (_b = (_a = containerRef.current) === null || _a === void 0 ? void 0 : _a.clientHeight) !== null && _b !== void 0 ? _b : 0);
    const safariTransition = useEnableAnimations() && isSafari;
    return (_jsx(
        "div",
        { className: classNames(styles.sheetContainer, backdropVisible && styles.backdrop, 
            safariTransition && styles.safariTransition), style: {
                [customProperties.virtualKeyboardHeight]: virtualKeyboardHeight,
            }, children: _jsx("div", { className: styles.safeAreaHandler, style: {
                    [customProperties.viewportDifferenceHeight]: viewportDifferenceHeight,
                }, children: _jsxs("div", { className: classNames(styles.contentContainer, snapPoint.type === 'auto' && styles.auto, resizing && styles.resizing), style: {
                        [customProperties.snapHeight]: snapHeight,
                        [customProperties.visualViewportHeight]: visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.height,
                    }, ref: containerRef, children: [backdropVisible && onRequestClose != null && (_jsx("div", { role: "none", className: styles.dismissArea, onClick: onRequestClose })), hasHandle ? _jsx(SheetDragHandle, { controls: controls }) : _jsx(Spacer, { size: "3u" }), _jsx(SheetContent, { ref: contentRef, scrollToResizeBelow: scrollToResizeBelow && resolveHeight(scrollToResizeBelow), controls: controls, handleSafeAreaInsetBottom: handleSafeAreaInsetBottom, id: id, ...contentContainerProps, children: children })] }) }) }
    ));
}
function useStabilizedSnapPoint(snapPoints) {
    const [rawIndex, rawSetIndex] = React.useState(0);
    const currentPoint = snapPoints[rawIndex];
    const previousPoint = React.useRef(currentPoint);
    const setSnapPointIndex = useStableFunction((index) => {
        rawSetIndex(index);
        previousPoint.current = snapPoints[index];
    });
    let snapPointIndex = rawIndex;
    if (!pointsEqual(currentPoint, previousPoint.current)) {
        snapPointIndex = snapPoints.findIndex(point => pointsEqual(point, previousPoint.current));
        if (snapPointIndex === -1) {
            snapPointIndex = 0;
        }
        setSnapPointIndex(snapPointIndex);
    }
    return [snapPointIndex, setSnapPointIndex];
}
const pointsEqual = (a, b) => a != null && b != null && a.type === b.type && a.height === b.height;
function calculateSnapHeight(snapPoint, resizing, containerHeight) {
    switch (snapPoint.type) {
        case 'fixed':
            return snapPoint.height + '%';
        case 'auto':
            if (!resizing) {
                return snapPoint.height + '%';
            }
            return containerHeight - getSafeAreaInsets().bottom + 'px';
        default:
            throw new UnreachableError(snapPoint);
    }
}
function SheetDragHandle({ controls }) {
    const { dragRef } = useSheetDrag({ controls });
    return (_jsx("div", { className: styles.dragHandleContainer, ref: dragRef, children: _jsx("div", { className: styles.dragHandle }) }));
}
const SheetContent = React.forwardRef(function SheetContent({ controls, scrollToResizeBelow, handleSafeAreaInsetBottom, id, children, ...contentContainerProps }, ref) {
    const { contentRef } = useSheetScroll({ controls, scrollToResizeBelow });
    const { hasScroll, contentScrollRef } = useContentScrollable();
    const imperativeScrollRef = useImperativeScrollRef(ref);
    return (_jsx(
        ContentContainer,
        { ref: composeRefs(contentRef, contentScrollRef, imperativeScrollRef), id: id, className: classNames(styles.content, {
                [styles.handleSafeAreaInsetBottom]: handleSafeAreaInsetBottom,
                [styles.noTouchAction]: !hasScroll,
            }), ...contentContainerProps, children: children }
    ));
});
function useImperativeScrollRef(ref) {
    const innerRef = React.useRef(null);
    React.useImperativeHandle(ref, () => ({
        scrollTo: (options) => {
            const el = innerRef === null || innerRef === void 0 ? void 0 : innerRef.current;
            if (el == null) {
                return;
            }
            if (typeof options === 'number') {
                el.scrollTo(0, options);
            }
            else {
                el.scrollTo(options);
            }
        },
    }));
    return innerRef;
}
