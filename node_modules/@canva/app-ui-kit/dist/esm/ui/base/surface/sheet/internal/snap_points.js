import { Preconditions, UnreachableError } from '../../../../../base/preconditions';
import * as React from 'react';
import { getSafeAreaInsets } from '../../../platform_quirks/get_safe_area_insets';
import { useStableFunction } from '../../../stable_function/stable_function';
export function useResolvedSnapPoints({ snapPoints, getScrollHeight, }) {
    const resolved = React.useRef();
    const get = useStableFunction(() => {
        if (resolved.current != null) {
            return resolved.current;
        }
        const scrollHeight = snapPoints.some(snapPoint => snapPoint.type === 'auto')
            ? getScrollHeight()
            : 0;
        const pending = [];
        for (let index = 0; index < snapPoints.length; index++) {
            const height = resolveSnapPoint(snapPoints[index], scrollHeight);
            const resolvedIndex = pending.findIndex(point => point.height === height);
            if (resolvedIndex === -1) {
                pending.push({ height, indices: [index] });
            }
            else {
                pending[resolvedIndex].indices.push(index);
            }
        }
        resolved.current = pending;
        return resolved.current;
    });
    const clear = useStableFunction(() => {
        resolved.current = undefined;
    });
    return {
        snapPointControls: { get, clear },
    };
}
function resolveSnapPoint(snapPoint, elHeight) {
    const { top, bottom } = getSafeAreaInsets();
    const availableHeight = window.innerHeight - top - bottom;
    const percentHeight = (availableHeight / 100) * snapPoint.height + bottom;
    switch (snapPoint.type) {
        case 'fixed':
            return percentHeight;
        case 'auto':
            return Math.min(elHeight, percentHeight);
        default:
            throw new UnreachableError(snapPoint);
    }
}
export function pointForIndex(points, snapPointIndex) {
    return Preconditions.checkExists(points.find(point => point.indices.includes(snapPointIndex)));
}
