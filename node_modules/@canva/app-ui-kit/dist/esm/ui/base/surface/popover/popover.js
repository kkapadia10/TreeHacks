import { jsx as _jsx } from "react/jsx-runtime";
import composeRefs from '@seznam/compose-react-refs';
import classNames from 'classnames';
import * as React from 'react';
import Measure from 'react-measure';
import { CSSTransition } from 'react-transition-group';
import { getSpaceValue } from '../../metrics/metrics';
import { Pin } from '../../pin/pin';
import { useEnableAnimations } from '../../provider/provider';
import { ContentContainer } from '../internal/content_container';
import styles, { customProperties } from './popover.css';
const WIDTH_CLASS = {
    ['16u']: styles.width16U,
    ['32u']: styles.width32U,
    ['40u']: styles.width40U,
    ['45u']: styles.width45U,
    ['52u']: styles.width52U,
    ['reference']: styles.widthReference,
    auto: undefined,
};
export const isReferenceObject = (reference) => {
    const refObj = reference;
    return refObj && typeof refObj.getBoundingClientRect === 'function';
};
export function Popover(
    { id: idProp, open, onRequestClose, onCloseComplete, blockOutsidePointerEvents = false, reference, placement = 'auto', width = 'auto', widthMode = 'fixed', offset = '1u', children, ...contentContainerProps }
) {
    const defaultId = React.useId();
    const id = idProp || defaultId;
    const customOffsetProvided = typeof offset === 'object';
    const PinComponent = useEnableAnimations() ? TransitionPin : StaticPin;
    const contentContainerRef = React.useRef(null);
    const contentContainerClassName = classNames(styles.content, WIDTH_CLASS[width], widthMode === 'maximum' && styles.widthModeMaximum, customOffsetProvided && styles.customOffset);
    const onPlacementUpdate = React.useCallback(data => {
        if (contentContainerRef.current == null) {
            return;
        }
        contentContainerRef.current.style.setProperty(customProperties.referenceWidth, `${Math.floor(data.offsets.reference.width)}px`);
    }, []);
    const finalPlacement = placement === 'auto' ? 'bottom-start' : placement;
    const offsetStyle = customOffsetProvided
        ? {
            marginTop: offset.top,
            [customProperties.offsetSpace]: offset.start,
        }
        : {
            [customProperties.offsetSpace]: getSpaceValue(offset),
        };
    const pinRef = React.useRef(null);
    const contentHeightRef = React.useRef(0);
    const updatePinPosition = React.useCallback(() => {
        pinRef.current && pinRef.current.dangerouslyForceUpdate();
    }, []);
    const onResize = React.useCallback((contentRect) => {
        var _a, _b;
        const contentHeight = (_b = (_a = contentRect.client) === null || _a === void 0 ? void 0 : _a.height) !== null && _b !== void 0 ? _b : 0;
        if (contentHeightRef.current !== contentHeight) {
            contentHeightRef.current = contentHeight;
            updatePinPosition();
        }
    }, [updatePinPosition]);
    const content = (_jsx(Measure, { onResize: onResize, client: true, children: ({ measureRef }) => {
            return (_jsx(ContentContainer, { ref: composeRefs(contentContainerRef, measureRef), className: contentContainerClassName, style: offsetStyle, id: id, onRequestEscape: onRequestClose, ...contentContainerProps, children: children }));
        } }));
    const refObj = isReferenceObject(reference) ? reference : undefined;
    return (_jsx(PinComponent, { ref: pinRef, placement: finalPlacement, open: open, onOutsideContentPointerDown: onRequestClose, onCloseComplete: onCloseComplete, blockOutsidePointerEvents: blockOutsidePointerEvents, onPlacementUpdate: onPlacementUpdate, content: content, overflowBoundariesElement: "viewport", positionFixed: true, refObj: refObj, children: typeof reference === 'function'
            ? reference({
                ariaControls: open ? id : undefined,
                active: open,
                disclosure: true,
                ariaHasPopup: contentContainerProps.role,
            })
            : !isReferenceObject(reference) && reference }));
}
const TRANSITION_DURATION = parseInt(styles.transitionTime, 10);
const TRANSITION_CLASS_NAMES = {
    appear: styles.visible,
    appearActive: styles.visible,
    appearDone: styles.visible,
    enter: styles.visible,
    enterActive: styles.visible,
    enterDone: styles.visible,
    exit: styles.hidden,
    exitActive: styles.hidden,
    exitDone: styles.hidden,
};
const TransitionPin = React.forwardRef(function TransitionPin({ open, onCloseComplete, ...props }, ref) {
    const [transitionOpen, setTransitionOpen] = React.useState(open);
    const nodeRef = React.useRef(null);
    return (_jsx(Pin, { ...props, ref: ref, open: open || transitionOpen, content: _jsx(CSSTransition, { in: open, appear: true, timeout: TRANSITION_DURATION, classNames: TRANSITION_CLASS_NAMES, onEnter: () => setTransitionOpen(true), onExited: () => {
                setTransitionOpen(false);
                onCloseComplete === null || onCloseComplete === void 0 ? void 0 : onCloseComplete();
            }, nodeRef: nodeRef, children: _jsx("div", { ref: nodeRef, children: props.content }) }) }));
});
const StaticPin = React.forwardRef(function StaticPin({ open, onCloseComplete, ...props }, ref) {
    const prevOpen = React.useRef(open);
    React.useEffect(() => {
        if (prevOpen.current && !open) {
            onCloseComplete === null || onCloseComplete === void 0 ? void 0 : onCloseComplete();
        }
        prevOpen.current = open;
    }, [open, onCloseComplete]);
    return (_jsx(Pin, { ...props, ref: ref, open: open, content: _jsx("div", { className: styles.visible, children: props.content }) }));
});
