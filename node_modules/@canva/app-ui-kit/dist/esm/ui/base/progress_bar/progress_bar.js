import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { Preconditions } from '../../../base/preconditions';
import classNames from 'classnames';
import * as React from 'react';
import Measure from 'react-measure';
import { useEnableAnimations } from '../provider/provider';
import styles, { customProperties } from './progress_bar.css';
export const TRANSITION_END_TIMEOUT_MS = parseInt(styles.widthTransitionDurationMs, 10) + 100 || 2000;
const bubbleStyles = [styles.bubble0, styles.bubble1, styles.bubble2, styles.bubble3];
const bubbleTTLs = [2000, 3000, 4000, 2000];
const bubbleUpdateInterval = 1000;
const bubblePerPixelRatio = 0.13;
export const ProgressBar = (props) => {
    const { value, ariaLabel, size = 'medium', tone = 'info', disableAnimations, onProgressAnimationEnd, disableBubbles, } = props;
    const [bubbles, setBubbles] = React.useState([]);
    const enableAnimations = useEnableAnimations();
    const privateFields = React.useRef({
        bubbleUpdateTimer: 0,
        currentProgressValueTransitionEndHandled: false,
        onProgressAnimationEndTimeout: 0,
        width: 0,
    });
    const updateBubbles = React.useCallback(() => {
        const now = Date.now();
        const valueWidth = (privateFields.current.width / 100) * value;
        const requiredBubblesAmount = Math.ceil(valueWidth * bubblePerPixelRatio);
        const requiredBubblesAmountDelta = requiredBubblesAmount - bubbles.length;
        const newBubblesAmount = requiredBubblesAmountDelta < 0
            ? requiredBubblesAmount
            : Math.ceil(bubbles.length + requiredBubblesAmountDelta / 2);
        let bubblesChanged = false;
        const newBubbles = Array.from({ length: newBubblesAmount }, (_, i) => {
            const bubble = bubbles[i];
            if (bubble === undefined || now > bubbleTTLs[bubble.type] + bubble.start) {
                bubblesChanged = true;
                return {
                    swap: bubble ? !bubble.swap : false,
                    type: Math.floor(Math.random() * bubbleStyles.length),
                    position: Math.floor(Math.random() * valueWidth),
                    start: now,
                };
            }
            return bubble;
        });
        if (bubblesChanged) {
            setBubbles(newBubbles);
        }
        window.clearTimeout(privateFields.current.bubbleUpdateTimer);
        privateFields.current.bubbleUpdateTimer = window.setTimeout(updateBubbles, bubbleUpdateInterval);
    }, [bubbles, value]);
    const onProgressTransitionEnd = React.useCallback(() => {
        window.clearTimeout(privateFields.current.onProgressAnimationEndTimeout);
        if (!privateFields.current.currentProgressValueTransitionEndHandled) {
            privateFields.current.currentProgressValueTransitionEndHandled = true;
            onProgressAnimationEnd && onProgressAnimationEnd(value);
        }
    }, [onProgressAnimationEnd, value]);
    React.useEffect(() => {
        const bubbleUpdateTimer = privateFields.current.bubbleUpdateTimer;
        return () => {
            window.clearTimeout(bubbleUpdateTimer);
        };
    }, []);
    React.useEffect(() => {
        if (enableAnimations && !disableBubbles) {
            updateBubbles();
        }
        validateProgressValue(value);
        privateFields.current.currentProgressValueTransitionEndHandled = false;
        window.clearTimeout(privateFields.current.onProgressAnimationEndTimeout);
        privateFields.current.onProgressAnimationEndTimeout = window.setTimeout(onProgressTransitionEnd, TRANSITION_END_TIMEOUT_MS);
    }, [value, disableBubbles, onProgressTransitionEnd, updateBubbles, enableAnimations]);
    const onResize = (contentRect) => {
        if (contentRect.entry) {
            privateFields.current.width = contentRect.entry.width;
        }
    };
    const valueBackgroundStyle = {
        transform: `scaleX(${value / 100})`,
    };
    return (_jsx(Measure, { onResize: onResize, children: ({ measureRef }) => (_jsx("div", { ref: measureRef, className: classNames(styles.progressBar, {
                [styles.small]: size === 'small',
                [styles.critical]: tone === 'critical',
                [styles.animate]: !disableAnimations && enableAnimations,
            }), role: "progressbar", "aria-label": ariaLabel, "aria-valuemin": 0, "aria-valuenow": value, "aria-valuemax": 100, children: _jsx("div", { className: styles.valueContainer, style: { [customProperties.valueContainerOffset]: `${value - 100}%` }, children: _jsxs("div", { className: styles.valueContainer, style: { [customProperties.valueContainerOffset]: `${100 - value}%` }, children: [_jsx("div", { className: styles.valueBackground, style: valueBackgroundStyle, onTransitionEnd: onProgressTransitionEnd }), bubbles.map(({ position, type, swap }, i) => (_jsx("div", { className: classNames(bubbleStyles[type], {
                                [styles.bubbleSwap]: swap,
                            }), style: { [customProperties.bubbleSide]: `${position}px` } }, i)))] }) }) })) }));
};
function validateProgressValue(value) {
    Preconditions.checkState(value >= 0 && value <= 100, `value must be in [0, 100]; got ${value}`);
}
