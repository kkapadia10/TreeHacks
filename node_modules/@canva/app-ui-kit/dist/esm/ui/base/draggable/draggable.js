import { makeObservable } from '../../../base/make_observable/make_observable';
import { __decorate } from "tslib";
import { Preconditions, UnreachableError } from '../../../base/preconditions';
import { action, reaction } from 'mobx';
import { ClientPosition } from './client_position';
import { DragHandler } from './drag_handler';
import { MouseTracker } from './mouse_tracker';
import { TouchTracker } from './touch_tracker';
export class Draggable {
  static _makeObservable(instance) {
    makeObservable(instance, {
      stopInProgressDrag: action.bound
    });
  }
  constructor(opts) {
    Draggable._makeObservable(this);
    this.opts = opts;
    this.onMouseDown = e => {
      const {
        canDrag,
        simulateDragMove
      } = this.opts;
      if (e.button !== 0) {
        return;
      }
      if (isInputElement(e.target)) {
        return;
      }
      if (this.tracker) {
        this.tracker.stop();
      }
      if (canDrag && !canDrag(e)) {
        return;
      }
      if (!this.opts.focusable) {
        e.preventDefault();
      }
      const cursorReactionCallbacks = this.getCursorReactionCallbacks();
      const holdToDrag = this.opts.holdToDrag === 'always';
      const drag = new DragHandler(ClientPosition.fromEvent(e), this.getDragCallbacks('mouse'), holdToDrag, cursorReactionCallbacks.didStart, cursorReactionCallbacks.willStop);
      this.tracker = new MouseTracker(drag, simulateDragMove, this.onTrackerStopped);
    };
    this.onTouchStart = e => {
      const {
        canDrag
      } = this.opts;
      if (this.tracker) {
        switch (this.tracker.type) {
          case 'touch':
            return;
          case 'mouse':
            this.tracker.stop();
            break;
          default:
            throw new UnreachableError(this.tracker);
        }
      }
      if (canDrag) {
        const {
          clientX,
          clientY,
          pageX,
          pageY
        } = e.changedTouches[0];
        const modifiers = DragHandler.modifiersFromEvent(e);
        if (!canDrag({
          clientX,
          clientY,
          pageX,
          pageY,
          ...modifiers
        })) {
          return;
        }
      }
      const holdToDrag = this.opts.holdToDrag === 'always' || this.opts.holdToDrag === 'touch-only';
      const drag = new DragHandler(ClientPosition.fromEvent(e.changedTouches[0]), this.getDragCallbacks('touch'), holdToDrag);
      this.tracker = new TouchTracker(drag, e.changedTouches[0], holdToDrag, this.onTrackerStopped);
    };
    this.onTrackerStopped = () => {
      this.tracker = undefined;
    };
  }
  getCursorReactionCallbacks() {
    const {
      cursorOverride,
      toggleCursorClassName = (c, e) => document.body.classList.toggle(c, e)
    } = this.opts;
    if (!cursorOverride) {
      return {};
    }
    let disposeCursorReaction;
    let oldCursorClassName;
    return {
      didStart: () => {
        disposeCursorReaction = reaction(() => cursorOverride.get(), newCursorClassName => {
          oldCursorClassName && toggleCursorClassName(oldCursorClassName, false);
          toggleCursorClassName(newCursorClassName, true);
          oldCursorClassName = newCursorClassName;
        }, {
          fireImmediately: true
        });
      },
      willStop: () => {
        oldCursorClassName && toggleCursorClassName(oldCursorClassName, false);
        disposeCursorReaction && disposeCursorReaction();
      }
    };
  }
  getDragCallbacks(dragType) {
    let pendingDragMove;
    const processDragMove = () => {
      var _a, _b;
      const event = Preconditions.checkExists(pendingDragMove).event;
      (_b = (_a = this.opts).onDragMove) === null || _b === void 0 ? void 0 : _b.call(_a, event);
      pendingDragMove = undefined;
    };
    return {
      onDragStart: e => {
        this.opts.onDragStart && this.opts.onDragStart(e, this.stopInProgressDrag, dragType);
      },
      onDragMove: e => {
        var _a, _b;
        if (this.opts.unthrottleEvents) {
          (_b = (_a = this.opts).onDragMove) === null || _b === void 0 ? void 0 : _b.call(_a, e);
          return;
        }
        if (pendingDragMove) {
          pendingDragMove.event = e;
        } else {
          const {
            raf = window.requestAnimationFrame
          } = this.opts;
          const requestId = raf(processDragMove);
          pendingDragMove = {
            requestId,
            event: e
          };
        }
      },
      onDragEnd: e => {
        if (pendingDragMove) {
          const {
            caf = window.cancelAnimationFrame
          } = this.opts;
          caf(pendingDragMove.requestId);
          processDragMove();
        }
        this.opts.onDragEnd && this.opts.onDragEnd(e);
      },
      onDragKeyChange: e => {
        if (pendingDragMove) {
          const {
            caf = window.cancelAnimationFrame
          } = this.opts;
          caf(pendingDragMove.requestId);
          processDragMove();
        }
        this.opts.onKeyChange && this.opts.onKeyChange(e);
      }
    };
  }
  stopInProgressDrag() {
    this.tracker && this.tracker.stop();
  }
}
function isInputElement(element) {
  return element instanceof HTMLTextAreaElement || element instanceof HTMLInputElement && element.type !== 'submit' || element instanceof HTMLElement && element.isContentEditable;
}