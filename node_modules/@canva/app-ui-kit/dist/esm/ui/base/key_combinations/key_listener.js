import { Preconditions } from '../../../base/preconditions';
import { isElementInput } from '../dom/input/input';
import { KeyMap } from './key_map';
const eventKinds = ['keydown', 'keyup', 'keypress'];
export class KeyListener {
    constructor(element, opt) {
        this.element = element;
        this.opt = opt;
        this.events = {
            ['keydown']: [],
            ['keyup']: [],
            ['keypress']: [],
        };
    }
    static getEnglishKey(event) {
        const eventKey = event.key != null && KeyMap.englishKeys.has(event.key)
            ? event.key.toLowerCase()
            : KeyMap.codeToKey[event.code];
        if (eventKey == null) {
            return event.key;
        }
        if (event.shiftKey && !event.code.startsWith('Numpad') && eventKey >= 'a' && eventKey <= 'z') {
            return KeyMap.shiftMap[eventKey] ? KeyMap.shiftMap[eventKey] : eventKey;
        }
        return eventKey;
    }
    static isKeyMatch(event, trigger) {
        const eventKey = trigger.ignoreKeyboardLayout === false ? event.key : KeyListener.getEnglishKey(event);
        const isModifiersOtherThanShiftMatch = (event.altKey === !!trigger.altKey || eventKey === 'Alt')
            && (event.ctrlKey === !!trigger.ctrlKey || eventKey === 'Control')
            && (event.metaKey === !!trigger.metaKey || eventKey === 'Meta');
        if (!isModifiersOtherThanShiftMatch) {
            return false;
        }
        const specialChars = new Set(['*', '+']);
        if (eventKey === trigger.key) {
            if (KeyMap.reverseShiftMap[trigger.key] != null) {
                return specialChars.has(trigger.key) ? event.shiftKey === !!trigger.shiftKey : true;
            }
            return event.shiftKey === !!trigger.shiftKey || eventKey === 'Shift';
        }
        else if (KeyMap.shiftMap[trigger.key] != null && trigger.shiftKey) {
            return specialChars.has(KeyMap.shiftMap[trigger.key])
                ? false
                : eventKey === KeyMap.shiftMap[trigger.key];
        }
        return false;
    }
    addListener(kind, trigger, callback) {
        const triggerClone = { ...trigger };
        const handler = ev => {
            if (KeyListener.isKeyMatch(ev, triggerClone) && !this.shouldIgnoreEvent(ev)) {
                callback(ev);
            }
        };
        this.element.addEventListener(kind, handler);
        this.events[kind].push(handler);
    }
    shouldIgnoreEvent(ev) {
        const eventTarget = Preconditions.checkExists(ev.target, 'event target must exist');
        const ownerDocument = Preconditions.checkExists(eventTarget.ownerDocument, 'event target must be node and ownerDocument must exist');
        if (ev.keyCode === 229) {
            return true;
        }
        return this.opt.ignoreInput && isElementInput(eventTarget, ownerDocument.defaultView);
    }
    reset() {
        for (const eventType of eventKinds) {
            this.events[eventType].forEach(handler => this.element.removeEventListener(eventType, handler));
            this.events[eventType] = [];
        }
    }
}
let keyListenerOnBody;
export function addListenerOnBody(kind, trigger, callback) {
    if (keyListenerOnBody == null) {
        keyListenerOnBody = new KeyListener(document.body, { ignoreInput: true });
    }
    keyListenerOnBody.addListener(kind, trigger, callback);
}
