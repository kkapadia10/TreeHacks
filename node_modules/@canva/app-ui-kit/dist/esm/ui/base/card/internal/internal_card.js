import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import classNames from 'classnames';
import { observer } from 'mobx-react';
import * as React from 'react';
import { accessModeState } from '../../a11y/access_mode_state/access_mode_state';
import { BadgeContainer, ExtendedBadgeVisibilityTrigger, } from '../../badge/badge_container/badge_container';
import { BasicButtonLink } from '../../button/button';
import { Spacer } from '../../layout/layout';
import { baseUnit } from '../../metrics/metrics';
import { useEnableAnimations } from '../../provider/provider';
import styles from '../card.css';
import { CardBottomBadge } from '../decorators/card_bottom_badge';
import { CardButtonGroup } from '../decorators/card_button';
import { CardCheckbox } from '../decorators/card_checkbox';
import { CardContent } from './card_content';
import { useCardConfiguration, useCardEventHandlers } from './card_context';
export const InternalCardWithDetails = observer(function InternalCardWithDetails(props) {
    const { avatar, title, description, preTitle, containerClassName, ...internalCardProps } = props;
    const { onMouseEnter, onMouseLeave } = useCardEventHandlers();
    const titleId = React.useId();
    const descriptionId = React.useId();
    const cardButtonAriaLabelledBy = props.buttonAriaLabelledBy || (!!title && !props.buttonAriaLabel ? titleId : undefined);
    const hasDetails = !!(title || description || preTitle || avatar);
    if (!hasDetails) {
        return _jsx(InternalCard, { ...internalCardProps, containerClassName: containerClassName });
    }
    return (_jsxs(ExtendedBadgeVisibilityTrigger, { className: classNames(styles.article, containerClassName), onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, role: "group", ariaLabelledBy: title ? titleId : undefined, ariaDescribedBy: description ? descriptionId : undefined, children: [_jsx(InternalCard, { buttonAriaLabelledBy: cardButtonAriaLabelledBy, trackHoverState: false, ...internalCardProps }), _jsx(Spacer, { size: "1u", direction: "vertical" }), _jsx(CardContent, { title: title, description: description, preTitle: preTitle, avatar: avatar, titleId: titleId, descriptionId: descriptionId })] }));
});
export const InternalCard = observer(function InternalCard(props) {
    const { children, ariaControls, ariaHasPopup, ariaExpanded, ariaLabel, buttonAriaLabel, buttonAriaLabelledBy, onClick, href, target, draggable, onDragStart, onContextMenu, buttonId, buttonRef, trackHoverState = true, containerClassName, outerClassName, innerClassName, outerStyle, innerStyle, selected, selectionIsPrimaryAction, } = props;
    const enableAnimations = useEnableAnimations();
    const { sharp, size, disabled, border } = useCardConfiguration();
    const { thumbnails, decorators } = partitionChildren(children);
    const checkbox = decorators.find(decorator => decorator.type === CardCheckbox);
    const _selected = checkbox ? !!checkbox.props.selected : selected;
    const hasInnerDiv = innerStyle || innerClassName;
    const contents = (_jsxs(BadgeContainer, { className: classNames(styles.cardArea, containerClassName, {
            [styles.animated]: enableAnimations,
            [styles.cardBorder]: border && !hasInnerDiv,
            [styles.roundBorders]: !sharp,
            [styles.disabled]: disabled,
        }), paddingStyle: size === 'medium' ? 'standard' : 'compact', ariaLabel: ariaLabel, role: decorators.length ? 'group' : undefined, children: [hasInnerDiv
                ? (_jsx("div", { className: classNames(innerClassName, {
                        [styles.cardBorder]: border,
                        [styles.roundBorders]: !sharp,
                    }), style: innerStyle, children: thumbnails }))
                : thumbnails, _jsx(InternalCardButton, { href: href, target: target, onClick: onClick, ariaControls: ariaControls, ariaHasPopup: ariaHasPopup, ariaExpanded: ariaExpanded, buttonAriaLabel: buttonAriaLabel, buttonAriaLabelledBy: buttonAriaLabelledBy, ariaPressed: selectionIsPrimaryAction ? _selected || false : undefined, trackHoverState: trackHoverState, buttonId: buttonId, buttonRef: buttonRef, disabled: disabled, draggable: draggable, onDragStart: onDragStart, onContextMenu: onContextMenu }), decorators] }));
    if (selectionIsPrimaryAction || checkbox || outerStyle || outerClassName) {
        return (_jsx("div", { style: outerStyle, className: classNames(outerClassName, styles.outerWrapper, {
                [styles.selectable]: selectionIsPrimaryAction || checkbox,
                [styles.selectableBorderOnHover]: selectionIsPrimaryAction,
                [styles.selected]: _selected,
                [styles.animated]: enableAnimations,
                [styles.roundBorders]: !sharp,
            }), children: contents }));
    }
    return contents;
});
export const InternalHorizontalCard = observer((props) => {
    const { title, description, preTitle, ariaControls, ariaHasPopup, ariaExpanded, buttonAriaLabel, onClick, href, target, draggable, onDragStart, onContextMenu, buttonId, buttonRef, children, thumbnailSize, selected, selectionIsPrimaryAction, bleedX, } = props;
    const enableAnimations = useEnableAnimations();
    const { sharp, disabled, size, hasHoverEffect, border, } = useCardConfiguration();
    const { onMouseEnter, onMouseLeave } = useCardEventHandlers();
    const { thumbnails, decorators } = partitionChildren(children);
    const checkbox = decorators.find(decorator => decorator.type === CardCheckbox);
    const _selected = checkbox ? !!checkbox.props.selected : selected;
    const titleId = React.useId();
    const descriptionId = React.useId();
    const cardButtonAriaLabelledBy = props.buttonAriaLabelledBy || (!!title && !props.buttonAriaLabel ? titleId : undefined);
    const predefinedThumbnailSizes = {
        small: baseUnit * 7,
        medium: baseUnit * 9,
    };
    const thumbnailHeight = thumbnailSize
        ? typeof thumbnailSize === 'number'
            ? thumbnailSize
            : predefinedThumbnailSizes[thumbnailSize]
        : predefinedThumbnailSizes[size];
    return (_jsx(ExtendedBadgeVisibilityTrigger, { tagName: "div", role: "group", className: classNames(styles.horizontalCard, {
            [styles.cardHoverTrigger]: hasHoverEffect || selectionIsPrimaryAction,
            [styles.selectable]: checkbox || selectionIsPrimaryAction,
            [styles.selectableBorderOnHover]: selectionIsPrimaryAction,
            [styles.selected]: _selected,
            [styles.animated]: enableAnimations,
            [styles.disabled]: disabled,
            [styles.roundBorders]: hasHoverEffect,
            [styles.bleedX]: bleedX,
        }), onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, ariaLabelledBy: title ? titleId : undefined, ariaDescribedBy: description ? descriptionId : undefined, children: _jsxs(BadgeContainer, { paddingStyle: size === 'medium' ? 'standard' : 'compact', className: styles.cardArea, children: [_jsxs("div", { className: styles.article, children: [_jsx("div", { style: {
                                height: `${thumbnailHeight}px`,
                                width: `${thumbnailHeight}px`,
                            }, className: classNames(styles.thumbnailContainer, {
                                [styles.cardBorder]: border,
                                [styles.roundBorders]: !sharp,
                            }), children: thumbnails }), _jsx(Spacer, { size: "1.5u", direction: "horizontal" }), _jsx(CardContent, { title: title, description: description, preTitle: preTitle, titleId: titleId, descriptionId: descriptionId })] }), _jsx(InternalCardButton, { href: href, target: target, onClick: onClick, ariaControls: ariaControls, ariaHasPopup: ariaHasPopup, ariaExpanded: ariaExpanded, buttonAriaLabel: buttonAriaLabel, buttonAriaLabelledBy: cardButtonAriaLabelledBy, trackHoverState: true, buttonId: buttonId, buttonRef: buttonRef, disabled: disabled, draggable: draggable, onDragStart: onDragStart, onContextMenu: onContextMenu }), decorators] }) }));
});
export const CardDecorator = ({ children }) => _jsx(_Fragment, { children: children });
const InternalCardButton = observer(function InternalCardButton(props) {
    const { ariaControls, ariaHasPopup, ariaExpanded, buttonAriaLabelledBy, href, target, buttonAriaLabel, draggable, disabled, onDragStart, buttonId, buttonRef, trackHoverState, onContextMenu, } = props;
    const cardEventHandlers = useCardEventHandlers();
    const eventHandlers = {
        ...cardEventHandlers,
        onMouseEnter: trackHoverState ? cardEventHandlers.onMouseEnter : undefined,
        onMouseLeave: trackHoverState ? cardEventHandlers.onMouseLeave : undefined,
    };
    if (!(href || props.onClick)) {
        if (eventHandlers.onMouseEnter || eventHandlers.onMouseLeave) {
            return (_jsx(
                "div",
                { role: "none", className: styles.cardButton, onMouseEnter: eventHandlers.onMouseEnter, onMouseLeave: eventHandlers.onMouseLeave }
            ));
        }
        return null;
    }
    if (href) {
        return (_jsx(BasicButtonLink, { href: href, target: target, className: styles.cardButton, onClick: props.onClick, ariaControls: ariaControls, ariaHasPopup: ariaHasPopup, disclosure: !!ariaHasPopup, active: ariaExpanded, ariaLabelledBy: buttonAriaLabelledBy, ariaLabel: buttonAriaLabel, disabled: disabled, draggable: draggable, onMouseEnter: eventHandlers.onMouseEnter, onMouseLeave: eventHandlers.onMouseLeave, onDragStart: onDragStart, onContextMenu: onContextMenu, buttonRef: buttonRef }));
    }
    const onClick = (e) => {
        var _a;
        if (!disabled) {
            (_a = props.onClick) === null || _a === void 0 ? void 0 : _a.call(props, e);
        }
    };
    const onKeyUp = (e) => {
        if (!disabled && e.key === ' ') {
            e.preventDefault();
            onClick(e);
        }
    };
    const onKeyDown = (e) => {
        if (!disabled) {
            if (e.key === ' ') {
                e.preventDefault();
            }
            else if (e.key === 'Enter') {
                e.preventDefault();
                onClick(e);
            }
        }
    };
    return (_jsx("div", { role: "button", "aria-disabled": disabled || undefined, "aria-controls": props.ariaControls, "aria-haspopup": props.ariaHasPopup, "aria-expanded": props.ariaExpanded, "aria-pressed": props.ariaPressed, "aria-label": props.buttonAriaLabelledBy ? undefined : props.buttonAriaLabel, "aria-labelledby": props.buttonAriaLabelledBy, className: classNames(styles.divButton, styles.cardButton, {
            [styles.hideOutline]: accessModeState.isMouseMode,
        }), draggable: draggable, id: buttonId, onClick: onClick, onContextMenu: onContextMenu, onMouseDown: eventHandlers.onMouseDown, onMouseUp: eventHandlers.onMouseUp, onMouseEnter: eventHandlers.onMouseEnter, onMouseLeave: eventHandlers.onMouseLeave, onFocus: eventHandlers.onFocus, onBlur: eventHandlers.onBlur, onKeyUp: onKeyUp, onKeyDown: onKeyDown, onDragStart: onDragStart, ref: buttonRef, tabIndex: 0 }));
});
function partitionChildren(children) {
    const thumbnails = [];
    const decorators = [];
    React.Children.toArray(children).forEach((child) => {
        if (React.isValidElement(child)) {
            if (isCardDecorator(child)) {
                decorators.push(child);
            }
            else {
                thumbnails.push(child);
            }
        }
    });
    return { thumbnails, decorators };
}
const cardDecorators = [CardBottomBadge, CardButtonGroup, CardCheckbox, CardDecorator];
const isCardDecorator = ({ type }) => cardDecorators.includes(type);
