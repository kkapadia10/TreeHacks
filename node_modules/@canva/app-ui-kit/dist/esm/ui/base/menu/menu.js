import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { Preconditions } from '../../../base/preconditions';
import classNames from 'classnames';
import { observer } from 'mobx-react';
import * as React from 'react';
import { accessModeState } from '../a11y/access_mode_state/access_mode_state';
import { Box } from '../box/box';
import { BasicButton, Button } from '../button/button';
import { useControllableValue } from '../controllable_value/controllable_value';
import { Divider } from '../divider/divider';
import { ChevronDownIcon } from '../icons/chevron_down/icon';
import { ChevronRightIcon } from '../icons/chevron_right/icon';
import { Column, Columns, Rows, Spacer } from '../layout/layout';
import { InheritColor, Text } from '../typography/typography';
import styles from './menu.css';
import { MenuMessages } from './menu.messages';
const MenuContext = React.createContext(undefined);
export const Menu = React.forwardRef(function Menu(props, ref) {
    var _a;
    const navigationRole = props.role === 'navigation';
    const [hasToggleMenu, setHasToggleMenu] = React.useState(false);
    const menuClassName = classNames(styles.menu, !navigationRole && props.className, {
        [styles.rounded]: props.variant === 'rounded',
        [styles.bleedX]: !!props.bleedX,
        [styles.spacing]: props.spacing === '1u' || (props.variant === 'rounded' && props.spacing !== '0'),
        [styles.horizontal]: props.role !== 'listbox' && props.direction === 'horizontal',
        [styles.hasToggleMenu]: hasToggleMenu,
    });
    const content = (_jsx(Box, { id: props.id, ariaActiveDescendant: props.ariaActiveDescendant, ariaMultiSelectable: props.ariaMultiSelectable, ariaLabel: props.ariaLabel, ariaLabelledBy: props.ariaLabelledBy, tagName: (_a = props.tagName) !== null && _a !== void 0 ? _a : 'ul', role: props.role === 'navigation' ? 'list' : props.role, ref: ref, className: menuClassName, children: props.children }));
    const maybeWrappedContent = navigationRole
        ? _jsx("nav", { className: navigationRole && props.className, children: content })
        : content;
    const context = React.useMemo(() => ({
        menuRole: props.role,
        menuDirection: props.role !== 'listbox' ? props.direction : undefined,
        menuVariant: props.variant,
        menuSpacing: props.spacing,
        registerToggleMenu: () => setHasToggleMenu(true),
    }), [props.role, props.direction, props.variant, props.spacing]);
    return _jsx(MenuContext.Provider, { value: context, children: maybeWrappedContent });
});
Menu.displayName = 'Menu';
function getMenuItemRoles(menuRole) {
    switch (menuRole) {
        case 'menu':
        case 'menubar':
            return { boxRole: 'none', buttonRole: 'menuitem' };
        case 'listbox':
        case 'group':
            return { boxRole: 'option', buttonRole: undefined };
        default:
            return { boxRole: undefined, buttonRole: undefined };
    }
}
export const MenuItem = React.memo(function MenuItem({ id, buttonId, children, className, active, disabled, disclosure, draggable, onFocus, onBlur, onMouseEnter, onMouseLeave, tabIndex, start, end, label, description, lineClamp, buttonRef, focusRef, tooltipLabel, ariaLabel, ariaLabelledBy, ariaHasPopup, ariaControls, ariaSelected, href, target, onClick, }) {
    const context = Preconditions.checkExists(React.useContext(MenuContext), 'MenuItem should not be used outside of a Menu');
    const { boxRole, buttonRole } = getMenuItemRoles(context.menuRole);
    return (_jsx(Box, { tagName: "li", id: id, role: boxRole, className: styles.menuItem, ariaDisabled: disabled, ariaSelected: ariaSelected, children: _jsx(MenuItemButton, { id: buttonId, role: buttonRole, tabIndex: tabIndex, buttonRef: buttonRef, focusRef: focusRef, className: className, href: href, target: target, onClick: onClick, start: start, end: end, label: label, description: description, lineClamp: lineClamp, alignment: context.menuDirection === 'horizontal' ? 'center' : 'start', active: active, disabled: disabled, disclosure: disclosure, draggable: draggable, onFocus: onFocus, onBlur: onBlur, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, tooltipLabel: tooltipLabel, ariaLabel: ariaLabel, ariaLabelledBy: ariaLabelledBy, ariaHasPopup: ariaHasPopup, ariaControls: ariaControls, children: children }) }));
});
MenuItem.displayName = 'MenuItem';
export const MenuItemButton = observer(function MenuItemButton({ id, role, alignment, children, className, active, disabled, draggable, disclosure, onFocus, onBlur, onMouseEnter, onMouseLeave, tabIndex, start, end, label, description, lineClamp, buttonRef, focusRef, tooltipLabel, ariaLabel, ariaLabelledBy, ariaHasPopup, ariaControls, ariaSelected, ...props }) {
    const hideOutline = accessModeState.isMouseMode;
    const labelId = React.useId();
    const descriptionId = React.useId();
    const buttonClassName = classNames(styles.menuItemButton, {
        [styles.hideOutline]: hideOutline,
    }, className);
    const buttonOrLinkProps = props.href
        ? { type: 'link', href: props.href, target: props.target, onClick: props.onClick }
        : { onClick: props.onClick };
    const contentNodes = [];
    if (children && typeof children !== 'string' && typeof children !== 'number') {
        contentNodes.push(children);
    }
    else {
        const text = label !== null && label !== void 0 ? label : children;
        text !== undefined
            && contentNodes.push(_jsx(Text, { id: label ? labelId : undefined, tagName: "span", tone: InheritColor, alignment: alignment, lineClamp: lineClamp, children: text }, contentNodes.length));
        label
            && description
            && contentNodes.push(_jsx(Text, { id: descriptionId, tagName: "span", size: "small", tone: "tertiary", alignment: alignment, children: description }, contentNodes.length));
    }
    const content = contentNodes.length > 1
        ? (_jsx(Rows, { tagName: "span", spacing: "0", children: contentNodes }))
        : contentNodes;
    return (_jsx(BasicButton, { id: id, role: role, tabIndex: tabIndex, buttonRef: buttonRef, focusRef: focusRef, className: buttonClassName, noChildWrapper: true, alignment: "start", active: active, disabled: disabled, draggable: draggable, disclosure: disclosure, onFocus: onFocus, onBlur: onBlur, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, tooltipLabel: tooltipLabel, ariaLabel: ariaLabel, ariaLabelledBy: label ? labelId : ariaLabelledBy, ariaDescribedBy: description ? descriptionId : undefined, ariaHasPopup: ariaHasPopup, ariaControls: ariaControls, ...buttonOrLinkProps, children: start || end
            ? (_jsxs(Columns, { tagName: "span", alignY: "center", spacing: "1u", children: [start ? renderDecorator(typeof start === 'function' ? start() : start) : null, _jsx(Column, { tagName: "span", children: content }), end ? renderDecorator(typeof end === 'function' ? end() : end) : null] }))
            : content }));
});
const renderDecorator = (decorator) => React.isValidElement(decorator) && decorator.type === React.Fragment
    ? (_jsx(_Fragment, { children: React.Children.map(decorator.props.children, (child) => child && renderDecorator(child)) }))
    : (_jsx(Column, { tagName: "span", width: "content", children: decorator }));
export const MenuDivider = React.memo(function MenuDivider({ id, children, }) {
    const context = Preconditions.checkExists(React.useContext(MenuContext), 'MenuDivider should not be used outside of a Menu');
    const dividerDirection = context.menuDirection === 'horizontal' ? 'vertical' : 'horizontal';
    return (_jsxs("li", { role: "none", id: id, children: [_jsx("div", { className: styles.menuDivider, children: _jsx(Divider, { direction: dividerDirection }) }), children && (_jsx(Text, { size: "small", weight: "bold", tagName: "div", tone: "secondary", className: styles.menuDividerText, children: children }))] }));
});
MenuDivider.displayName = 'MenuDivider';
export const ToggleMenu = React.forwardRef(function ToggleMenu({ id, menuId: menuIdProp, labelId: labelIdProp, label, labelNode, disabled, draggable, start, end, active, buttonRef, tooltipLabel, href, onClick, onToggleClick, toggleLabel, defaultExpanded, expanded: expandedProp, buttonClassName, ...props }, ref) {
    const [expanded, setExpanded] = useControllableValue({
        value: expandedProp,
        defaultValue: defaultExpanded,
        onChange: onToggleClick,
    });
    const toggleExpanded = React.useCallback(() => setExpanded(!expanded), [expanded, setExpanded]);
    const context = React.useContext(MenuContext);
    React.useEffect(() => {
        context === null || context === void 0 ? void 0 : context.registerToggleMenu();
    }, [context]);
    const Icon = expanded ? ChevronDownIcon : ChevronRightIcon;
    const generatedMenuId = React.useId();
    const menuId = menuIdProp !== null && menuIdProp !== void 0 ? menuIdProp : generatedMenuId;
    const generatedLabelId = React.useId();
    const labelId = labelIdProp !== null && labelIdProp !== void 0 ? labelIdProp : generatedLabelId;
    const toggleButtonProps = {
        onClick: toggleExpanded,
        disclosure: true,
        ariaControls: expanded ? menuId : undefined,
        active: expanded,
    };
    const showSeparateToggleButton = href || onClick;
    const menuItemClickProps = showSeparateToggleButton
        ? {
            href,
            onClick,
        }
        : {
            className: styles.activeOverride,
            ...toggleButtonProps,
        };
    return (_jsxs(Box, { ref: ref, tagName: context ? 'li' : 'div', id: id, className: styles.toggleMenuBox, children: [_jsx(MenuItemButton, { id: labelId, className: buttonClassName, active: active, disabled: disabled, start: _jsxs(_Fragment, { children: [showSeparateToggleButton
                            ? _jsx(Spacer, { size: "1u", direction: "horizontal" })
                            : (_jsxs(Box, { tagName: "span", className: styles.toggleMenuIconBox, children: [_jsx(Spacer, { size: "1u", direction: "horizontal" }), _jsx(Icon, { size: "small", className: styles.toggleMenuIcon })] })), start] }), end: end, lineClamp: 1, buttonRef: buttonRef, tooltipLabel: tooltipLabel, ariaLabel: labelNode ? label : undefined, draggable: draggable, ...menuItemClickProps, children: labelNode || label }), showSeparateToggleButton && (_jsx(Button, { className: classNames(styles.activeOverride, styles.toggleButton), variant: "tertiary", iconSize: "small", icon: Icon, ariaLabel: (toggleLabel !== null && toggleLabel !== void 0 ? toggleLabel : expanded)
                    ? MenuMessages.collapseMenu(label)
                    : MenuMessages.expandMenu(label), disabled: disabled, ...toggleButtonProps })), expanded && props.children && (_jsx(Menu, { id: menuId, ariaLabelledBy: labelId, variant: context === null || context === void 0 ? void 0 : context.menuVariant, spacing: context === null || context === void 0 ? void 0 : context.menuSpacing, ...props }))] }));
});
