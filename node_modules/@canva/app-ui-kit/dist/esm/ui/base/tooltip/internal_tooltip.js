var TriggeredTooltip_1;
import { __decorate } from "tslib";
import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import classNames from 'classnames';
import * as mobx from 'mobx';
import * as mobxReact from 'mobx-react';
import * as React from 'react';
import { useIsMouseAccessMode } from '../a11y/access_mode_state/access_mode_state';
import { useIdentifiers } from '../a11y/identifier/identifier';
import { useIsMouseInput } from '../a11y/pointer_input_state/pointer_input_state';
import { ScreenReaderContent } from '../a11y/screen_reader_content/screen_reader_content';
import { LayerLevel } from '../layer/layer';
import { Rows } from '../layout/layout';
import { Pin } from '../pin/pin';
import { createPinMotionWrapper } from '../pin/pin_motion_wrapper';
import { PixelDensityResponsiveImage } from '../responsive_image/responsive_image';
import { Shortcut } from '../shortcut/shortcut';
import { ThemeBoundary } from '../theme/theme';
import { Text } from '../typography/typography';
import styles from './tooltip.css';
import { TooltipPresenter } from './tooltip_presenter';
function isRenderTrigger(children) {
  return typeof children === 'function';
}
const MOTION_DURATION_MS = 150;
const FADE_IN_DELAY = 150;
const FADE_OUT_DELAY = 0;
export function InternalTooltip(props) {
  const {
    label,
    description,
    disabled = false,
    mode
  } = props;
  const timer = React.useRef(undefined);
  const [open, setOpen] = React.useState(false);
  const openRef = React.useRef(false);
  const withDelay = React.useCallback((cb, delay) => {
    window.clearTimeout(timer.current);
    if (!delay) {
      return Promise.resolve(cb());
    }
    return new Promise(resolve => {
      timer.current = window.setTimeout(() => {
        cb();
        resolve();
      }, delay);
    });
  }, []);
  const showTooltip = React.useCallback((delay = FADE_IN_DELAY) => {
    return withDelay(() => setOpen(true), delay);
  }, [withDelay]);
  const hideTooltip = React.useCallback(() => {
    return withDelay(() => setOpen(false), FADE_OUT_DELAY);
  }, [withDelay]);
  const onDocumentKeydown = React.useCallback(e => {
    if (e.key === 'Escape' && openRef.current) {
      e.stopPropagation();
      hideTooltip();
    }
  }, [hideTooltip]);
  React.useEffect(() => {
    document.addEventListener('keydown', onDocumentKeydown, {
      capture: true
    });
    return () => {
      document.removeEventListener('keydown', onDocumentKeydown, {
        capture: true
      });
    };
  }, [onDocumentKeydown]);
  React.useEffect(() => {
    openRef.current = open;
  }, [open]);
  React.useEffect(() => {
    if (disabled) {
      hideTooltip();
    }
  }, [disabled, hideTooltip]);
  const screenReaderLabel = description != null ? `${label}: ${description}` : label;
  if (mode === 'toggletip') {
    return _jsx(BaseToggleTip, {
      ...props,
      hideTooltip: hideTooltip,
      open: open,
      screenReaderLabel: screenReaderLabel,
      showTooltip: showTooltip,
      disabled: disabled
    });
  }
  return _jsx(BaseTooltip, {
    ...props,
    hideTooltip: hideTooltip,
    open: open,
    screenReaderLabel: screenReaderLabel,
    showTooltip: showTooltip,
    disabled: disabled
  });
}
function BaseTooltip({
  children,
  closeOnClick = true,
  disabled,
  forwardedRef,
  hideTooltip,
  open,
  screenReaderLabel,
  showTooltip,
  ...props
}) {
  const [tooltipId] = useIdentifiers(1);
  const isMouseInput = useIsMouseInput();
  const isMouseAccessMode = useIsMouseAccessMode();
  const showTooltipIfMouseInput = React.useCallback(() => {
    if (disabled || !isMouseInput) {
      return;
    }
    showTooltip();
  }, [disabled, showTooltip, isMouseInput]);
  const showTooltipIfKeyboardMode = React.useCallback(() => {
    if (disabled || isMouseAccessMode) {
      return;
    }
    showTooltip(0);
  }, [disabled, showTooltip, isMouseAccessMode]);
  const renderedChildren = React.useMemo(() => {
    if (isRenderTrigger(children)) {
      return children({
        onBlur: hideTooltip,
        onFocus: showTooltipIfKeyboardMode,
        onMouseDown: closeOnClick ? hideTooltip : undefined,
        onMouseEnter: showTooltipIfMouseInput,
        onMouseLeave: hideTooltip,
        tabIndex: 0,
        tooltipId
      });
    }
  }, [children, closeOnClick, hideTooltip, showTooltipIfKeyboardMode, showTooltipIfMouseInput, tooltipId]);
  if (isRenderTrigger(children)) {
    return (_jsxs(_Fragment, {
        children: [_jsx(StatelessTooltip, {
          ...props,
          open: open,
          children: renderedChildren
        }), _jsx(ScreenReaderContent, {
          id: tooltipId,
          children: screenReaderLabel
        })]
      }));
  }
  return closeOnClick ?
  _jsx("div", {
    onMouseEnter: showTooltipIfMouseInput,
    onMouseLeave: hideTooltip,
    onMouseDown: hideTooltip,
    ref: forwardedRef,
    children: _jsx(StatelessTooltip, {
      ...props,
      children: children,
      open: open
    })
  }) : _jsx("div", {
    onMouseEnter: showTooltipIfMouseInput,
    onMouseLeave: hideTooltip,
    ref: forwardedRef,
    children: _jsx(StatelessTooltip, {
      ...props,
      children: children,
      open: open
    })
  });
}
function BaseToggleTip({
  open,
  hideTooltip,
  showTooltip,
  children,
  screenReaderLabel,
  ...props
}) {
  const [renderScreenReaderLabel, setRenderScreenReaderLabel] = React.useState(false);
  const showToggletip = React.useCallback(async e => {
    e.currentTarget.focus({
      preventScroll: true
    });
    setRenderScreenReaderLabel(false);
    await showTooltip(0);
    setTimeout(() => setRenderScreenReaderLabel(true), 50);
  }, [showTooltip, setRenderScreenReaderLabel]);
  const renderedChildren = React.useMemo(() => {
    return children({
      onClick: showToggletip,
      onBlur: hideTooltip
    });
  }, [children, hideTooltip, showToggletip]);
  return (_jsxs(_Fragment, {
      children: [_jsx(StatelessTooltip, {
        ...props,
        open: open,
        children: renderedChildren
      }), _jsx(ScreenReaderContent, {
        role: "status",
        ariaRelevant: "all",
        children: renderScreenReaderLabel ? screenReaderLabel : ''
      })]
    }));
}
let TriggeredTooltip = TriggeredTooltip_1 = class TriggeredTooltip extends React.Component {
  constructor() {
    super(...arguments);
    this.presenter = new TooltipPresenter();
  }
  render() {
    const {
      state,
      ...rest
    } = this.props;
    return _jsx(StatelessTooltip, {
      ...rest,
      open: state.open,
      mode: "tooltip"
    });
  }
  componentDidMount() {
    mobxReact.disposeOnUnmount(this, mobx.autorun(() => {
      if (this.props.autoclose && this.props.state.open) {
        this.presenter.hideTooltip(this.props, TriggeredTooltip_1.fadeOutDelay);
      }
    }));
  }
};
TriggeredTooltip.defaultProps = {
  autoclose: true
};
TriggeredTooltip.fadeOutDelay = 2000;
TriggeredTooltip = TriggeredTooltip_1 = __decorate([mobxReact.observer], TriggeredTooltip);
export { TriggeredTooltip };
export function TooltipContent(props) {
  const {
    id,
    withLayout,
    label,
    description,
    align = 'center',
    shortcut,
    lineClamp,
    thumbnail,
    mode
  } = props;
  const shortcutElement = shortcut ? _jsx(Shortcut, {
    className: styles.shortcut,
    combination: shortcut,
    size: "small"
  }) : null;
  const lines = lineClamp ? [label] : label.trim().split('\n');
  const labelContent = lines.length === 1 ? _jsx(Text, {
    size: "small",
    weight: "bold",
    tagName: "div",
    lineClamp: lineClamp,
    tone: "primary",
    className: styles.label,
    alignment: align,
    id: id,
    children: label
  }) : _jsx("div", {
    className: styles.label,
    id: id,
    children: lines.map((line, i) => _jsx(Text, {
      size: "small",
      alignment: align,
      tone: "primary",
      children: line
    }, i))
  });
  const descriptionContent = description != null && _jsx(Text, {
    size: "small",
    tone: "secondary",
    alignment: align,
    className: styles.description,
    children: description
  });
  const thumbnailContent = thumbnail != null && _jsx("div", {
    className: styles.thumbnail,
    children: typeof thumbnail === 'string' ? _jsx("img", {
      src: thumbnail,
      alt: ""
    }) : _jsx(PixelDensityResponsiveImage, {
      sources: thumbnail,
      alt: ""
    })
  });
  const ariaProps = mode === 'toggletip' ? {} : {
    ['role']: 'tooltip'
  };
  return _jsx(ThemeBoundary, {
    light: "dark",
    dark: "dark",
    classicLight: "dark",
    classicDark: "dark",
    children: ({
      className
    }) => _jsx("div", {
      className: classNames(className, styles.tooltip, {
        [styles.tooltipLayout]: withLayout
      }),
      ...ariaProps,
      children: _jsxs(Rows, {
        spacing: "0",
        align: align,
        children: [thumbnailContent, labelContent, descriptionContent, shortcutElement]
      })
    })
  });
}
export function TooltipArrow({
  withLayout
}) {
  return _jsxs("svg", {
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    className: classNames(styles.arrow, {
      [styles.arrowLayout]: withLayout
    }),
    children: [_jsx("path", {
      d: "M15 9L10.3972 4.67335C9.04995 3.40695 6.95006 3.40695 5.60282 4.67335L1 9L15 9Z",
      className: styles.arrowInner
    }), _jsx("path", {
      d: "M15 9L10.3972 4.67335C9.04995 3.40695 6.95006 3.40695 5.60282 4.67335L1 9L2.46004 9L6.28773 5.40198C7.25004 4.4974 8.74996 4.4974 9.71228 5.40198L13.54 9L15 9Z",
      className: styles.arrowOutline
    })]
  });
}
export function StatelessTooltip({
  children,
  placement = 'bottom',
  open,
  arrow = true,
  refObj,
  overflowBoundariesElement,
  direction,
  expandTooltipWrapper,
  ...contentProps
}) {
  const contentElement = _jsx(TooltipContent, {
    withLayout: true,
    ...contentProps
  });
  const arrowElement = arrow ? _jsx(TooltipArrow, {
    withLayout: true
  }) : null;
  return _jsx(Pin, {
    placement: placement,
    level: LayerLevel.TOOLTIPS,
    overflowBoundariesElement: overflowBoundariesElement,
    content: contentElement,
    arrow: arrowElement,
    MotionWrapper: TooltipMotionWrapper,
    open: open,
    noPointerEventsForDisabledChildren: true,
    refObj: refObj,
    direction: direction,
    expandChildren: expandTooltipWrapper,
    children: children
  });
}
const TooltipMotionWrapper = createPinMotionWrapper({
  enterStyle: {
    opacity: 0
  },
  enteredStyle: {
    opacity: 1
  },
  leaveStyle: {
    opacity: 0
  },
  style: {
    transition: `opacity ${MOTION_DURATION_MS}ms ease-in-out`
  },
  durationMs: MOTION_DURATION_MS
});