import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import classNames from 'classnames';
import { Observer, observer } from 'mobx-react';
import * as React from 'react';
import { accessModeState } from '../../a11y/access_mode_state/access_mode_state';
import { pointerInputState } from '../../a11y/pointer_input_state/pointer_input_state';
import styles from './badge_container.css';
const paddingStyleClassMap = {
    ['compact']: styles.compact,
    ['standard']: undefined,
};
const transitionClassMap = {
    ['fade']: styles.fxFade,
    ['slide']: styles.fxSlide,
    ['none']: styles.fxAppear,
};
export const BadgeContainer = React.forwardRef(({ children, paddingStyle = 'standard', className, ariaLabel, ariaLabelledBy, role, }, ref) => (_jsx(Observer, { children: () => (_jsx("div", { ref: ref, className: classNames(styles.container, styles.hoverTrigger, paddingStyleClassMap[paddingStyle], className, {
            [styles.focusVisible]: accessModeState.isKeyboardMode,
        }), role: role, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, children: children })) })));
export function BadgeGroup({ location, visibility = 'always', transition, children, stretch, }) {
    return (_jsx(
        "span",
        { className: classNames(styles.badgeGroup, location && getLocationClasses(location), transition ? transitionClassMap[transition] : styles.defaultFx, {
                [styles.hoverTarget]: visibility === 'on-hover',
                [styles.pinning]: location != null,
                [styles.stretch]: stretch,
            }), children: children }
    ));
}
export const VisibleOnHover = observer(({ children, transition, showOnTouchDevice = false, }) => {
    const isMouseInput = pointerInputState.isMouseInput;
    if (!isMouseInput && !showOnTouchDevice) {
        return _jsx(_Fragment, {});
    }
    return (_jsx("span", { className: classNames(styles.badgeGroup, transition ? transitionClassMap[transition] : styles.defaultFx, {
            [styles.hoverTarget]: isMouseInput,
        }), children: children }));
});
export const SwapOnHover = ({ onHover, children, }) => (_jsxs("span", { className: styles.swapOnHoverWrapper, children: [_jsx("span", { className: styles.hideOnHover, children: children }), _jsx("span", { className: styles.showOnHover, children: onHover })] }));
function getLocationClasses(location) {
    return {
        [styles.top]: location === 'top-start' || location === 'top-end',
        [styles.bottom]: location === 'bottom-start' || location === 'bottom-end',
        [styles.left]: location === 'top-start' || location === 'bottom-start' || location === 'center-start',
        [styles.right]: location === 'top-end' || location === 'bottom-end' || location === 'center-end',
        [styles.verticalCenter]: location === 'center-start' || location === 'center-end',
    };
}
export const ExtendedBadgeVisibilityTrigger = observer(React.forwardRef(({ children, tagName = 'div', role, className, onMouseEnter, onMouseLeave, ariaLabelledBy, ariaDescribedBy, }, ref) => React.createElement(tagName, {
    className: classNames(className, styles.hoverTrigger, {
        [styles.focusVisible]: accessModeState.isKeyboardMode,
    }),
    onMouseEnter,
    onMouseLeave,
    ['aria-labelledby']: ariaLabelledBy,
    ['aria-describedby']: ariaDescribedBy,
    role,
    ref,
}, children)));
