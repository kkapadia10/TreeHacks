import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import composeRefs from '@seznam/compose-react-refs';
import classNames from 'classnames';
import { observer } from 'mobx-react';
import * as React from 'react';
import { accessModeState } from '../../a11y/access_mode_state/access_mode_state';
import { getButtonAriaAttributes } from '../../a11y/button_aria_attributes/button_aria_attributes';
import { pointerInputState } from '../../a11y/pointer_input_state/pointer_input_state';
import { ScreenReaderContent } from '../../a11y/screen_reader_content/screen_reader_content';
import { canHover } from '../../device_capabilities/device_capabilities';
import { useFocusableRef } from '../../focusable/focusable';
import { AnimatedLoadingIcon } from '../../icons/animated_loading/icon';
import { LinkMessages } from '../../link/link.messages';
import { useEnableAnimations } from '../../provider/provider';
import { Tooltip } from '../../tooltip/tooltip';
import { Text } from '../../typography/typography';
import styles, { getStyle } from '../button.css';
import { ButtonMessages } from '../button.messages';
import { RepeatClickWrapper } from './repeat_click_wrapper';
import { SubmitStore } from './submit_store';
const getButtonContent = (props) => {
    const { children, iconPosition = 'start', noChildWrapper, icon: Icon, LoadingIcon = AnimatedLoadingIcon, } = props;
    const content = [];
    let displayIcon = null;
    const hiddenAttrs = { ['aria-hidden']: props.loading || undefined };
    if (Icon) {
        displayIcon = (_jsx("span", { className: styles.iconWrapper, ...hiddenAttrs, children: _jsx(Icon, { size: props.iconSize || 'medium' }) }, "icon"));
    }
    if (iconPosition === 'start' || iconPosition === 'top') {
        content.push(displayIcon);
    }
    if (children) {
        content.push(noChildWrapper
            ? children
            : (_jsx("span", { className: styles.text, ...hiddenAttrs, children: children }, "content")));
    }
    if (iconPosition === 'end') {
        content.push(displayIcon);
    }
    if (props.loading) {
        const loadingIconSize = props.iconSize || 'medium';
        content.push(_jsxs("span", { className: styles.loadingIconWrapper, children: [_jsx(LoadingIcon, { size: loadingIconSize }), _jsx(ScreenReaderContent, { ariaLive: "assertive", children: props.loadingMessage || ButtonMessages.loading() })] }, "loading"));
    }
    return content;
};
const useClassName = (isAnchor, { children, alignment = 'center', on, loading, disabled, stretch, variant, hideOutline, iconPosition, shape, size, icon, iconSize, }) => {
    const trueSize = getSize({ children, iconSize, size, variant });
    const squareSizing = allowSquareSizing({ children, variant, stretch, icon });
    return classNames(styles.base, {
        [styles.anchor]: isAnchor,
        [styles.button]: variant !== 'basic',
        [styles.hideOutline]: hideOutline,
        [styles.topIcon]: iconPosition === 'top',
        [styles.startIcon]: icon && (!iconPosition || iconPosition === 'start'),
        [styles.endIcon]: icon && iconPosition === 'end',
        [styles.noMinWidth]: squareSizing,
        [styles.circleShape]: shape === 'circle',
    }, getStyle(variant), trueSize && getStyle(trueSize), {
        [styles.on]: on,
        [styles.stretch]: stretch,
        [styles.loading]: loading,
        [styles.disabled]: disabled,
        [styles.startAlign]: alignment === 'start',
        [styles.centerAlign]: alignment === 'center',
        [styles.endAlign]: alignment === 'end',
        [styles.hoverSupported]: !pointerInputState.isTouchInput && canHover(),
        [styles.animate]: useEnableAnimations(),
        [styles.tinyWidth]: trueSize === 'tiny' && squareSizing,
        [styles.smallWidth]: trueSize === 'small' && squareSizing,
        [styles.mediumWidth]: trueSize === 'medium' && squareSizing,
        [styles.largeWidth]: trueSize === 'large' && squareSizing,
    });
};
export const InternalButton = observer(function InternalButton(props) {
    const buttonSubmitStore = props._submitStore || submitStore;
    const ref = composeRefs(useFocusableRef(props.focusRef), props.buttonRef);
    React.useEffect(() => buttonSubmitStore.enable(), [buttonSubmitStore]);
    const disabledAttribute = props.type === 'submit' && buttonSubmitStore.shouldDisableSubmit;
    const disabledStyle = disabledAttribute || props.disabled;
    const disabled = disabledAttribute || props.disabled || props.loading;
    const className = useClassName(false, {
        ...props,
        hideOutline: accessModeState.isMouseMode,
        on: props.active,
        disabled: disabledStyle,
    });
    const children = !props.expandClickableArea
        ? getButtonContent(props)
        : _jsx("span", { className: className, children: getButtonContent(props) });
    const onClickImpl = props.onClick;
    const onClick = React.useCallback((e) => {
        if (disabled) {
            e.preventDefault();
        }
        else {
            onClickImpl === null || onClickImpl === void 0 ? void 0 : onClickImpl(e);
        }
    }, [disabled, onClickImpl]);
    const stopPropagationWhenDisabled = disabled
        ? (e) => {
            const shouldPrevent = ['click', 'mousedown', 'mouseup', 'submit'].includes(e.type)
                || !('code' in e)
                || ['Enter', 'Space'].includes(e.code);
            if (shouldPrevent) {
                e.stopPropagation();
                e.preventDefault();
            }
        }
        : undefined;
    return (_jsx(RepeatClickWrapper, { onClick: onClick, repeatSpeed: props.repeatSpeed, disabled: disabled, children: repeatClickWrapperProps => {
            var _a;
            return (_jsx("button", { id: props.id, onMouseDown: e => { var _a; return accessModeState.setAccessMode('mouse') && ((_a = props.onMouseDown) === null || _a === void 0 ? void 0 : _a.call(props, e)); }, className: classNames(props.expandClickableArea ? styles.expandClickableAreaContainer : className, props.className), form: props.form, onMouseUp: props.onMouseUp, onMouseEnter: props.onMouseEnter, onMouseLeave: props.onMouseLeave, onContextMenu: props.onContextMenu, onBlur: props.onBlur, onFocus: props.onFocus, onDragStart: props.onDragStart, onDragEnd: props.onDragEnd, draggable: props.draggable, onClickCapture: stopPropagationWhenDisabled, onMouseDownCapture: stopPropagationWhenDisabled, onKeyDownCapture: stopPropagationWhenDisabled, onMouseUpCapture: stopPropagationWhenDisabled, disabled: disabledAttribute, type: props.type || 'button', ...getButtonAriaAttributes({
                    ...props,
                    tagName: 'button',
                    active: (_a = props.ariaPressed) !== null && _a !== void 0 ? _a : props.active,
                    disabled,
                }), ...repeatClickWrapperProps, ref: ref, children: children }));
        } }));
});
export const Anchor = observer(function InternalAnchor(props) {
    const ref = composeRefs(useFocusableRef(props.focusRef), props.buttonRef);
    const semanticallyDisabled = props.disabled || props.loading;
    const targetBlank = props.target === '_blank';
    const rel = targetBlank && !props.rel ? 'noopener' : props.rel;
    const className = useClassName(true, {
        ...props,
        hideOutline: accessModeState.isMouseMode,
        on: props.active,
    });
    const children = !props.expandClickableArea
        ? getButtonContent(props)
        : _jsx("span", { className: className, children: getButtonContent(props) });
    let linkProps;
    if (!semanticallyDisabled) {
        linkProps = {
            onClick: props.onClick,
            onDragStart: props.onDragStart,
            onDragEnd: props.onDragEnd,
            onFocus: props.onFocus,
            onBlur: props.onBlur,
            onContextMenu: props.onContextMenu,
            onMouseEnter: props.onMouseEnter,
            onMouseLeave: props.onMouseLeave,
            href: props.href,
            target: props.target,
            rel,
            download: props.download,
            draggable: props.draggable,
        };
    }
    else {
        linkProps = {
            onClick: (e) => e.preventDefault(),
            href: props.href,
            target: props.target,
            download: props.download,
        };
    }
    return (_jsxs("a", { id: props.id, ref: ref, ...linkProps, className: classNames(props.expandClickableArea ? styles.expandClickableAreaContainer : className, props.className), ...getButtonAriaAttributes({ tagName: 'a', disabled: semanticallyDisabled, ...props }), children: [children, targetBlank && (_jsx(ScreenReaderContent, { tagName: "span", children: LinkMessages.opensInNewWindow() }))] }));
});
const ButtonWithTooltipInner = ({ buttonProps, tooltipTriggerProps, }) => {
    let ariaProps;
    if (buttonProps.ariaLabelledBy != null
        || buttonProps.ariaLabel != null
        || buttonProps.children != null) {
        ariaProps = { ariaDescribedBy: tooltipTriggerProps.tooltipId };
    }
    else {
        ariaProps = { ariaLabel: buttonProps.tooltipLabel };
    }
    const onMouseEnter = (event) => {
        var _a, _b;
        (_a = buttonProps.onMouseEnter) === null || _a === void 0 ? void 0 : _a.call(buttonProps, event);
        (_b = tooltipTriggerProps.onMouseEnter) === null || _b === void 0 ? void 0 : _b.call(tooltipTriggerProps);
    };
    const onMouseLeave = (event) => {
        var _a, _b;
        (_a = buttonProps.onMouseLeave) === null || _a === void 0 ? void 0 : _a.call(buttonProps, event);
        (_b = tooltipTriggerProps.onMouseLeave) === null || _b === void 0 ? void 0 : _b.call(tooltipTriggerProps);
    };
    const onMouseDown = (event) => {
        var _a, _b;
        (_a = buttonProps.onMouseDown) === null || _a === void 0 ? void 0 : _a.call(buttonProps, event);
        (_b = tooltipTriggerProps.onMouseDown) === null || _b === void 0 ? void 0 : _b.call(tooltipTriggerProps);
    };
    const onFocus = (event) => {
        var _a, _b;
        (_a = buttonProps.onFocus) === null || _a === void 0 ? void 0 : _a.call(buttonProps, event);
        (_b = tooltipTriggerProps.onFocus) === null || _b === void 0 ? void 0 : _b.call(tooltipTriggerProps);
    };
    const onBlur = (event) => {
        var _a, _b;
        (_a = buttonProps.onBlur) === null || _a === void 0 ? void 0 : _a.call(buttonProps, event);
        (_b = tooltipTriggerProps.onBlur) === null || _b === void 0 ? void 0 : _b.call(tooltipTriggerProps);
    };
    return (_jsx(InternalButton, { ...buttonProps, ...ariaProps, onFocus: onFocus, onBlur: onBlur, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, onMouseDown: onMouseDown, tooltipLabel: undefined }));
};
export const ButtonWithTooltip = observer(function ButtonWithTooltip(props) {
    const tooltip = (_jsx(Tooltip, { label: props.tooltipLabel, shortcut: props.tooltipShortcut, disabled: props.tooltipDisabled, placement: props.tooltipPlacement, overflowBoundariesElement: props.tooltipOverflowBoundariesElement, closeOnClick: props.tooltipCloseOnClick, children: triggerProps => {
            return _jsx(ButtonWithTooltipInner, { buttonProps: props, tooltipTriggerProps: triggerProps });
        } }));
    return props.stretch ? _jsx("div", { className: styles.stretchWrapper, children: tooltip }) : tooltip;
});
export const AnchorWithTooltip = observer(function AnchorWithTooltip(props) {
    const button = props.disabled
        ? (_jsx("div", { className: styles.disabledContainer, children: _jsx(Anchor, { ...props, tooltipLabel: undefined, ariaLabel: props.ariaLabel || props.tooltipLabel }) }))
        : (_jsx(Anchor, { ...props, tooltipLabel: undefined, ariaLabel: props.ariaLabel || props.tooltipLabel }));
    return (_jsx(Tooltip, { label: props.tooltipLabel, shortcut: props.tooltipShortcut, disabled: props.tooltipDisabled, placement: props.tooltipPlacement, closeOnClick: props.tooltipCloseOnClick, children: button }));
});
export const CircleButtonWithoutLabel = (props) => {
    return (_jsx(ElevatedWrapper, { ...props, shape: "circle", children: renderButton({ ...props, shape: 'circle' }) }));
};
export function CircleButtonWithLabel({ variant, children, ...props }) {
    const labelId = React.useId();
    const size = getSize({ ...props, variant });
    return (_jsxs("div", { className: classNames(styles.circleShapeWrapper, {
            [styles.circleShapeWrapperXsmall]: size === 'xsmall',
            [styles.circleShapeWrapperSmall]: size === 'small',
            [styles.circleShapeWrapperMedium]: size === 'medium',
            [styles.circleShapeWrapperLarge]: size === 'large',
        }), children: [_jsx(ElevatedWrapper, { ...props, variant: variant, shape: "circle", children: 
                renderButton({
                    ...props,
                    tooltipLabel: props.tooltipLabel,
                    tooltipPlacement: props.tooltipPlacement || 'top',
                    shape: 'circle',
                    variant,
                    ariaLabelledBy: labelId,
                }) }), _jsx("label", { className: styles.circleButtonLabel, children: _jsx(Text, { size: "small", id: labelId, tagName: "span", alignment: "center", tone: "secondary", lineClamp: 2, children: children }) })] }));
}
function allowSquareSizing({ children, stretch, variant, icon, }) {
    return !children && !!icon && !stretch && ['subtleLinkButton'].indexOf(variant) === -1;
}
function getSize({ children, iconSize, size, variant, }) {
    if (['subtleLinkButton'].indexOf(variant) !== -1) {
        return;
    }
    if (size && size !== 'default') {
        return size;
    }
    if (variant === 'basic') {
        return;
    }
    if (!children && iconSize && ['tiny', 'small', 'large'].indexOf(iconSize) !== -1) {
        return iconSize;
    }
    return 'medium';
}
const ElevatedWrapper = observer(function ElevatedWrapper(props) {
    if (props.elevated && props.shape === 'circle' && props.variant !== 'contrast') {
        return (_jsx("div", { className: classNames(styles.elevatedWrapper, props.containerClassName), children: props.children }));
    }
    return _jsx(_Fragment, { children: props.children });
});
const submitStore = new SubmitStore();
export const renderButton = (props) => {
    if (props.tooltipLabel != null && props.tooltipLabel.length > 0) {
        return _jsx(ButtonWithTooltip, { ...props, tooltipLabel: props.tooltipLabel });
    }
    return _jsx(InternalButton, { ...props, tooltipLabel: undefined });
};
export const renderAnchor = (props) => {
    if (props.tooltipLabel != null && props.tooltipLabel.length > 0) {
        return _jsx(AnchorWithTooltip, { ...props, tooltipLabel: props.tooltipLabel });
    }
    return _jsx(Anchor, { ...props, tooltipLabel: undefined });
};
export const renderButtonOrAnchor = (props) => {
    if (props.type === 'link') {
        return renderAnchor(props);
    }
    return renderButton(props);
};
