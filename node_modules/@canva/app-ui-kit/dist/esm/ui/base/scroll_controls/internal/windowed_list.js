import { makeObservable } from '../../../../base/make_observable/make_observable';
import { __decorate } from "tslib";
import { computed, observable, reaction } from 'mobx';
import { disposeOnUnmount, observer } from 'mobx-react';
import * as React from 'react';
let WindowedList = class WindowedList extends React.Component {
  static _makeObservable(instance) {
    makeObservable(instance, {
      visibleRange: observable.ref,
      itemPositions: computed
    });
  }
  constructor(...args) {
    super(...args);
    WindowedList._makeObservable(this);
  }
  get itemPositions() {
    return this.props.itemSizes.reduce((arr, size, index) => {
      arr.push(size + arr[index]);
      return arr;
    }, [0]);
  }
  componentDidMount() {
    disposeOnUnmount(this, reaction(() => ({
      positions: this.props.scrollState.positions,
      itemPositions: this.itemPositions
    }), ({
      positions,
      itemPositions
    }) => {
      if (positions == null) {
        this.visibleRange = undefined;
      } else {
        const {
          overscan = 1
        } = this.props;
        const {
          containerSize,
          scrollPosition
        } = positions;
        if (scrollPosition > itemPositions[itemPositions.length - 1]) {
          this.setVisibleRange(Math.max(itemPositions.length - 1 - overscan, 0), itemPositions.length - 1);
          return;
        }
        if (scrollPosition + containerSize < 0) {
          this.setVisibleRange(0, Math.min(overscan, itemPositions.length - 1));
          return;
        }
        const boundedFirstVisible = Math.min(scrollPosition, itemPositions[itemPositions.length - 1] - containerSize);
        const firstVisible = Math.max(0, itemPositions.findIndex(p => p > boundedFirstVisible) - 1 - overscan);
        const boundedLastVisible = Math.min(itemPositions[itemPositions.length - 1], scrollPosition + containerSize);
        const lastVisible = Math.min(itemPositions.length - 1, itemPositions.findIndex(p => p >= boundedLastVisible) + overscan);
        this.setVisibleRange(firstVisible, lastVisible);
      }
    }, {
      fireImmediately: true
    }));
  }
  setVisibleRange(firstVisible, lastVisible) {
    if (this.visibleRange == null) {
      this.visibleRange = observable({
        firstVisible,
        lastVisible
      });
    } else {
      this.visibleRange.firstVisible = firstVisible;
      this.visibleRange.lastVisible = lastVisible;
    }
  }
  render() {
    const {
      visibleRange,
      itemPositions
    } = this;
    if (visibleRange == null) {
      return this.props.children(undefined, itemPositions);
    }
    const {
      firstVisible,
      lastVisible
    } = visibleRange;
    return this.props.children({
      firstVisible,
      lastVisible
    }, itemPositions);
  }
};
WindowedList = __decorate([observer], WindowedList);
export { WindowedList };