import { UnreachableError } from '../../../../base/preconditions';
import { unique } from '../../../../base/unique';
import { Conversion, CssColors, RgbColor } from '../../color/color';
import { useThemedMedia } from '../../theme/escape_hatch';
import { SwatchMessages } from '../swatch.messages';
export function isFillObject(color) {
    if (typeof color === 'object' && color != null && 'type' in color) {
        return color.type === 'linear' || color.type === 'radial';
    }
    return false;
}
export const toStripePosition = (index, totalStripes) => {
    const stripePercentage = totalStripes > 0 ? 100 / totalStripes : 0;
    const positionPercentage = index * stripePercentage;
    return `${positionPercentage.toFixed(2)}%`;
};
export const toStripeWidth = (width, listSize) => {
    const swatchWidth = width > 0 ? width : 0;
    const stripeWidth = listSize > 0 ? swatchWidth / listSize : swatchWidth;
    return `${Math.ceil(stripeWidth)}px`;
};
const isGradient = (color) => /gradient/i.test(color);
export const getValidGradientString = (color) => isGradient(color) ? '' : `linear-gradient(to right, ${color}, ${color})`;
const normalizeValue = (v) => {
    return v.toFixed(3).replace(/\.?0*$/, '');
};
const convertToPercentage = (n) => {
    return n <= 1 ? `${normalizeValue(n * 100)}%` : `${n}%`;
};
const convertColorToHex = (color) => {
    const { r, g, b } = CssColors.fromString(color);
    return Conversion.toHex(new RgbColor(r, g, b));
};
const generateGradientLabel = (color) => {
    const stops = color.stops
        .map(c => c.transparency
        ? SwatchMessages.colorWithTransparencyLabel(convertColorToHex(c.color), convertToPercentage(c.transparency))
        : convertColorToHex(c.color))
        .join(`, `);
    switch (color.type) {
        case 'linear': {
            return SwatchMessages.colorLinearGradientLabel(color.rotation, stops);
        }
        case 'radial': {
            const { center: { top: y, left: x }, } = color;
            return SwatchMessages.colorCircularRadialGradientLabel(`${convertToPercentage(x)} ${convertToPercentage(y)}`, stops);
        }
        default:
            throw new UnreachableError(color);
    }
};
export const generateSwatchLabel = ({ areAllColorsTransparent, colors, colorNames, rgbToCmyk, fill, isAtleastOneColorTransparent, areNoColorsApplied, }) => {
    if (areAllColorsTransparent || areNoColorsApplied) {
        return SwatchMessages.colorTransparentLabel();
    }
    if (Array.isArray(colors) && colors.length === 1 && typeof colors[0] === 'string') {
        return getColorTooltipLabel(colors[0], colorNames, rgbToCmyk);
    }
    if (Array.isArray(fill)) {
        const generatedLabel = fill
            .map(color => {
            if (typeof color === 'string') {
                return getColorTooltipLabel(color);
            }
            if (color == null) {
                return undefined;
            }
            if (isFillObject(color)) {
                return generateGradientLabel(color);
            }
            return undefined;
        })
            .filter(Boolean)
            .join(', ');
        return isAtleastOneColorTransparent
            ? SwatchMessages.colorSemiTransparentLabel(generatedLabel)
            : generatedLabel || SwatchMessages.invalidColor();
    }
    return SwatchMessages.invalidColor();
};
const convertColorToRgba = (color, transparency = 0) => {
    const { r, g, b } = CssColors.fromString(color);
    return new RgbColor(r, g, b).toRgbaColor(1 - transparency).toRgbaString();
};
export const gradientToCssBackground = (color) => {
    const colorStops = color.stops
        .map(({ color, position, transparency = 0 }) => {
        const rgbaColor = convertColorToRgba(color, transparency);
        return position ? `${rgbaColor} ${convertToPercentage(position)}` : `${rgbaColor}`;
    })
        .join(', ');
    switch (color.type) {
        case 'linear': {
            return `linear-gradient(${color.rotation}deg, ${colorStops})`;
        }
        case 'radial': {
            const { center: { top: y, left: x }, } = color;
            const center = `${convertToPercentage(x)} ${convertToPercentage(y)}`;
            return `radial-gradient(circle farthest-corner at ${center}, ${colorStops})`;
        }
        default:
            throw new UnreachableError(color);
    }
};
const RGBA_RE = /^rgba\((\d+),\s*(\d+),\s*(\d+),\s*([0-9]*\.?[0-9]+)\)$/;
const getColorTooltipLabel = (color, colorNames, rgbToCmyk) => {
    var _a;
    const cmyk = (_a = rgbToCmyk === null || rgbToCmyk === void 0 ? void 0 : rgbToCmyk.get(color)) === null || _a === void 0 ? void 0 : _a.split(',').join(', ');
    const name = colorNames === null || colorNames === void 0 ? void 0 : colorNames.get(color);
    const cmykMessage = cmyk && SwatchMessages.cmykInfo(cmyk);
    if (cmykMessage && name) {
        return SwatchMessages.colorTitleWithNameAndCmykInfo(name, color, cmykMessage);
    }
    else if (name) {
        return SwatchMessages.colorTitleWithName(name, color);
    }
    else if (cmykMessage) {
        return SwatchMessages.colorTitleWithCmykInfo(color, cmykMessage);
    }
    else if (color === 'circularSpectrum' || color === 'linearSpectrum') {
        return SwatchMessages.colorRangeLabel();
    }
    else if (color.match(RGBA_RE)) {
        const { a } = CssColors.fromRgbaString(color);
        const transparency = 1 - a;
        if (transparency > 0) {
            return SwatchMessages.colorWithTransparencyLabel(convertColorToHex(color), convertToPercentage(transparency));
        }
        return convertColorToHex(color);
    }
    try {
        return convertColorToHex(color);
    }
    catch {
        return color;
    }
};
export function useContrastingColors(colors, shouldContrastColor) {
    const colorList = colors === 'circularSpectrum' || colors === 'linearSpectrum' ? [colors] : colors;
    const uniqueColors = unique(colorList);
    const themeColor = useThemedMedia({
        value: { light: '#ffffff', dark: '#000000' },
    });
    const nonContrastColor = themeColor || { value: '#ffffff' };
    let themeColors;
    if (nonContrastColor.value === '#ffffff') {
        themeColors = ['#ffffff', 'white', '#fff'];
    }
    else {
        themeColors = ['#000000', 'black', '#000'];
    }
    const uniqueColor = Array.isArray(uniqueColors) && uniqueColors.length === 1 && typeof uniqueColors[0] === 'string'
        ? uniqueColors[0]
        : null;
    if (shouldContrastColor && uniqueColor && themeColors.includes(uniqueColor)) {
        return 'circularSpectrum';
    }
    return uniqueColors;
}
