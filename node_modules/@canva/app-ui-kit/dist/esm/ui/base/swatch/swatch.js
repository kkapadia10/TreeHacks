import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import classnames from 'classnames';
import * as React from 'react';
import Measure from 'react-measure';
import { AspectRatio } from '../aspect_ratio/aspect_ratio';
import { PlusIcon } from '../icons/plus/icon';
import { ClickableSwatch, DeletableSwatch, StaticSwatch } from './internal/internal_swatch';
import { generateSwatchLabel, getValidGradientString, gradientToCssBackground, isFillObject, toStripePosition, toStripeWidth, useContrastingColors, } from './internal/swatch_util';
import styles from './swatch.css';
import { SwatchMessages } from './swatch.messages';
const getClassName = ({ size, stretch, aspectRatio, }) => {
    const fluidStyles = {
        [styles.stretch]: stretch,
        [styles.aspectRatio]: stretch && aspectRatio,
    };
    const sizeStyles = {
        [styles.xxsmall]: size === 'xxsmall',
        [styles.xsmall]: size === 'xsmall',
        [styles.small]: size === 'small',
        [styles.medium]: size === 'medium',
        [styles.large]: size === 'large',
    };
    return classnames(styles.swatch, sizeStyles, fluidStyles);
};
const getBackgroundClassName = ({ variant, fill, contrastingColors, isCheckeredBgPresent, areNoColorsApplied, }) => {
    const variantStyles = {
        [styles.outline]: variant === 'outline',
    };
    const fillStyles = {
        [styles.colorSpectrumCircular]: areNoColorsApplied || fill === 'circularSpectrum' || contrastingColors === 'circularSpectrum',
        [styles.colorSpectrumLinear]: fill === 'linearSpectrum',
        [styles.colorTransparent]: isCheckeredBgPresent,
    };
    return classnames(styles.background, variantStyles, fillStyles);
};
const getInlineStyles = (colors, width) => {
    if (!(colors === null || colors === void 0 ? void 0 : colors.length)) {
        return undefined;
    }
    const backgroundImage = colors
        .map(color => {
        if (typeof color === 'string') {
            return getValidGradientString(color);
        }
        if (color == null) {
            return getValidGradientString('transparent');
        }
        if (isFillObject(color)) {
            return gradientToCssBackground(color);
        }
        return undefined;
    })
        .filter(Boolean)
        .join(', ');
    const backgroundSize = colors.length > 1
        ? `${colors.map((c, i) => toStripeWidth(width, colors.length)).join(', ')}`
        : undefined;
    const backgroundPositionX = colors.length > 1
        ? `${colors.map((c, i) => toStripePosition(i, colors.length - 1)).join(', ')}`
        : undefined;
    const backgroundRepeat = colors.length > 1 ? 'no-repeat' : undefined;
    return { backgroundImage, backgroundRepeat, backgroundSize, backgroundPositionX };
};
const getSwatchContent = ({ areAllColorsTransparent, isCheckeredBgPresent, inlineStyles, }) => {
    if (areAllColorsTransparent) {
        return _jsx("span", { className: styles.strike });
    }
    if (isCheckeredBgPresent) {
        return _jsx("span", { className: classnames(styles.colors), style: inlineStyles });
    }
    return null;
};
export const Swatch = ({ fill, size = 'medium', variant = 'solid', Icon, onClick, active, disabled, disclosure, role, focusRef, tabIndex, tooltipLabel, disableTooltip, tooltipOverflowBoundariesElement, stretch, colorNames, rgbToCmyk, id, ariaLabel, ariaDescribedBy, ariaLabelledBy, onDelete, deleteButtonVisibility = 'on-hover', aspectRatio, ariaHasPopup, ariaControls, }) => {
    const [spanWidth, setSpanWidth] = React.useState(0);
    const contrastingColors = useContrastingColors(fill, variant === 'contrast');
    const colors = contrastingColors instanceof Array ? contrastingColors : undefined;
    const areNoColorsApplied = (colors === null || colors === void 0 ? void 0 : colors.length) === 0;
    const isAtleastOneColorTransparent = (!areNoColorsApplied && (colors === null || colors === void 0 ? void 0 : colors.some(c => !c))) || false;
    const areAllColorsTransparent = (!areNoColorsApplied && (colors === null || colors === void 0 ? void 0 : colors.every(c => !c))) || false;
    const isCheckeredBgPresent = fill !== 'linearSpectrum'
        && fill !== 'circularSpectrum'
        && contrastingColors !== 'circularSpectrum'
        && !areNoColorsApplied;
    const className = getClassName({
        size,
        stretch,
        aspectRatio,
    });
    const backgroundClassName = getBackgroundClassName({
        variant,
        fill,
        contrastingColors,
        isCheckeredBgPresent,
        areNoColorsApplied,
    });
    const inlineStyles = React.useMemo(() => getInlineStyles(colors, spanWidth), [colors, spanWidth]);
    const content = getSwatchContent({
        areAllColorsTransparent,
        isCheckeredBgPresent,
        inlineStyles,
    });
    const defaultLabel = React.useMemo(() => generateSwatchLabel({
        colors,
        colorNames,
        rgbToCmyk,
        areNoColorsApplied,
        areAllColorsTransparent,
        isAtleastOneColorTransparent,
        fill,
    }), [
        colors,
        colorNames,
        rgbToCmyk,
        areNoColorsApplied,
        areAllColorsTransparent,
        isAtleastOneColorTransparent,
        fill,
    ]);
    const tooltipLabelText = !disableTooltip ? tooltipLabel !== null && tooltipLabel !== void 0 ? tooltipLabel : defaultLabel : '';
    const ariaLabelText = ariaLabel !== null && ariaLabel !== void 0 ? ariaLabel : defaultLabel;
    const isClickable = !!onClick;
    const isDeletable = !!onDelete;
    const swatch = (_jsxs(StaticSwatch, { className: className, ariaLabel: ariaLabelText, ariaLabelledBy: ariaLabelledBy, ariaDescribedBy: ariaDescribedBy, id: id, children: [_jsx(Measure, { bounds: true, onResize: ({ bounds }) => setSpanWidth((bounds === null || bounds === void 0 ? void 0 : bounds.width) || 0), children: ({ measureRef }) => (_jsx("span", { ref: measureRef, className: backgroundClassName, style: content ? undefined : inlineStyles, children: content })) }), Icon && _jsx("span", { className: styles.icon, children: Icon() })] }));
    const interactiveSwatch = isClickable
        ? (_jsx(ClickableSwatch, { onClick: onClick, active: active, disabled: disabled, disclosure: disclosure, ariaLabel: ariaLabelText, role: role, focusRef: focusRef, tabIndex: tabIndex, stretch: stretch, aspectRatio: aspectRatio, ariaHasPopup: ariaHasPopup, ariaControls: ariaControls, tooltipLabel: tooltipLabelText, disableTooltip: disableTooltip, tooltipOverflowBoundariesElement: tooltipOverflowBoundariesElement, children: swatch }))
        : swatch;
    const fluidSwatch = stretch && aspectRatio
        ? _jsx(AspectRatio, { ratio: aspectRatio, children: interactiveSwatch })
        : interactiveSwatch;
    const swatchWithDeleteButton = isDeletable
        ? (_jsx(DeletableSwatch, { onDelete: onDelete, stretch: stretch, aspectRatio: aspectRatio, deleteButtonVisibility: deleteButtonVisibility, disableTooltip: disableTooltip, tooltipOverflowBoundariesElement: tooltipOverflowBoundariesElement, children: fluidSwatch }))
        : fluidSwatch;
    return swatchWithDeleteButton;
};
const iconSizeMap = {
    ['xxsmall']: 'tiny',
    ['xsmall']: 'small',
    ['small']: 'small',
    ['medium']: 'small',
    ['large']: 'medium',
};
export const AddColorButton = (props) => {
    const { size = 'medium' } = props;
    const Icon = () => (_jsx("span", { className: styles.iconOverlay, children: _jsx(PlusIcon, { size: iconSizeMap[size], tone: "primary" }) }));
    return (_jsx(Swatch, { ...props, fill: "circularSpectrum", tooltipLabel: SwatchMessages.addColor(), ariaLabel: SwatchMessages.addColor(), Icon: Icon }));
};
