import { Preconditions } from '../../../../base/preconditions';
export const defaultAreEqual = (a, b) => {
    return a === b;
};
export const defaultIsSelected = (option, value) => {
    return Array.isArray(value) ? value.includes(option.value) : option.value === value;
};
export const defaultGetLabel = option => {
    return option.label || option.value || '';
};
export const joinLabels = (labels) => {
    return labels.every(label => typeof label === 'string') ? labels.join(', ') : labels;
};
const normalizeQuery = (value) => value
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '');
export function defaultFilterFn(query, options, value, isSelected) {
    const normalizedQuery = normalizeQuery(query);
    if (!normalizedQuery) {
        return options;
    }
    const startMatches = [];
    const otherMatches = [];
    options.forEach(option => {
        Preconditions.checkArgument(typeof option.label === 'string', 'Provide a custom `filterFn` to work with options without labels');
        const normalizedLabel = normalizeQuery(option.label);
        if (!normalizedLabel.includes(normalizedQuery)) {
            if (isSelected(option, value)) {
                otherMatches.push(option);
            }
            return;
        }
        if (normalizedLabel.startsWith(normalizedQuery)) {
            startMatches.push(option);
        }
        else {
            otherMatches.push(option);
        }
    });
    return startMatches.concat(otherMatches);
}
export function normalizeOptionGroups(options) {
    const optionGroups = [];
    let currentImplicitGroup;
    options.forEach(optionOrGroup => {
        if (optionOrGroup.options != null) {
            currentImplicitGroup = undefined;
            optionGroups.push(optionOrGroup);
        }
        else {
            if (currentImplicitGroup == null) {
                currentImplicitGroup !== null && currentImplicitGroup !== void 0 ? currentImplicitGroup : (currentImplicitGroup = { options: [] });
                optionGroups.push(currentImplicitGroup);
            }
            currentImplicitGroup.options.push(optionOrGroup);
        }
    });
    return optionGroups;
}
export function isOptionGroup(option) {
    return option.options != null;
}
export function flattenOptions(options) {
    const result = [];
    options.forEach(option => {
        if (option.options != null) {
            result.push(...option.options);
        }
        else {
            result.push(option);
        }
    });
    return result;
}
export function deriveIdentifier(id, subid) {
    return subid == null ? undefined : `${id}--${subid}`;
}
export function sliceOptionGroups(optionGroups, start, end) {
    const slice = [];
    let groupStart = 0;
    for (let groupIndex = 0; groupIndex < optionGroups.length; groupIndex++) {
        const optionGroup = optionGroups[groupIndex];
        const groupLength = optionGroup.options.length;
        const groupEnd = groupStart + groupLength;
        if (groupEnd <= start) {
            groupStart += groupLength;
            continue;
        }
        if (groupStart >= end) {
            break;
        }
        if (groupStart < start && groupEnd <= end) {
            const optionsStart = start - groupStart;
            slice.push({
                label: optionGroup.label,
                options: optionGroup.options.slice(optionsStart),
                originalIndex: groupIndex,
                slice: [optionsStart, groupLength],
            });
            groupStart += groupLength;
            continue;
        }
        if (groupStart >= start && groupEnd <= end) {
            slice.push({
                label: optionGroup.label,
                options: optionGroup.options.slice(),
                originalIndex: groupIndex,
                slice: [0, groupLength],
            });
            groupStart += groupLength;
            continue;
        }
        if (groupStart >= start && groupEnd > end) {
            const optionsEnd = end - groupStart;
            slice.push({
                label: optionGroup.label,
                options: optionGroup.options.slice(0, optionsEnd),
                originalIndex: groupIndex,
                slice: [0, optionsEnd],
            });
            groupStart += groupLength;
            continue;
        }
        if (groupStart < start && groupEnd > end) {
            const optionsStart = start - groupStart;
            const optionsEnd = end - groupStart;
            slice.push({
                label: optionGroup.label,
                options: optionGroup.options.slice(optionsStart, optionsEnd),
                originalIndex: groupIndex,
                slice: [optionsStart, optionsEnd],
            });
            groupStart += groupLength;
            continue;
        }
    }
    return slice;
}
