import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import composeRefs from '@seznam/compose-react-refs';
import classNames from 'classnames';
import * as React from 'react';
import { Box } from '../../box/box';
import { BasicButton } from '../../button/button';
import { canHover } from '../../device_capabilities/device_capabilities';
import { Divider } from '../../divider/divider';
import { FakeCheckbox } from '../checkbox/checkbox';
import { ChevronDownIcon } from '../../icons/chevron_down/icon';
import { TickIcon } from '../../icons/tick/icon';
import { Rows } from '../../layout/layout';
import { Spacer } from '../../layout/spacer/spacer';
import { Menu as BaseMenu, MenuDivider, MenuItem } from '../../menu/menu';
import { baseUnit } from '../../metrics/metrics';
import { ScrollWindow, WindowedList } from '../../scroll_controls/scroll_window';
import { ScrollPositioner } from '../../scroll_positioner/scroll_positioner';
import { Flyout as BaseFlyout } from '../../surface/flyout/flyout';
import { InheritColor, Text } from '../../typography/typography';
import styles from './base_select.css';
import { BaseSelectMessages } from './base_select.messages';
import { defaultAreEqual, defaultGetLabel, defaultIsSelected, deriveIdentifier, flattenOptions, joinLabels, normalizeOptionGroups, sliceOptionGroups, } from './base_select_util';
const ITEM_HEIGHT = parseInt(styles.itemHeight, 10);
const DIVIDER_HEIGHT = parseInt(styles.dividerHeight, 10);
const TEXT_DIVIDER_HEIGHT = parseInt(styles.textDividerHeight, 10);
const DEFAULT_FLYOUT_WIDTH_UNITS = '40u';
const DEFAULT_FLYOUT_WIDTH = parseInt(DEFAULT_FLYOUT_WIDTH_UNITS, 10) * baseUnit;
export function StatelessBaseSelect(props) {
    const { Trigger = BaseSelectTrigger, Menu = BaseSelectMenu, Item, Flyout = BaseFlyout, value, placeholder, open, disabled, error, stretch, activeIndex, options, focusOnMenu = false, flyoutPlacement = 'bottom-start', flyoutWidth: flyoutWidthProp, id, ariaLabel, ariaLabelledBy, ariaDescribedBy, tooltipLabel, tooltipPlacement, className, onRequestToggle, onBlur, onFocus, onItemClick, onItemHover, areEqual = defaultAreEqual, isSelected = defaultIsSelected, getLabel = defaultGetLabel, } = props;
    const menuId = React.useId();
    const labelId = React.useId();
    const triggerContainerRef = React.useRef(null);
    const menuContainerRef = React.useRef(null);
    const flatOptions = React.useMemo(() => { var _a; return (_a = props.flatOptions) !== null && _a !== void 0 ? _a : flattenOptions(props.options); }, [props.options, props.flatOptions]);
    const optionGroups = React.useMemo(() => { var _a; return (_a = props.optionGroups) !== null && _a !== void 0 ? _a : normalizeOptionGroups(props.options); }, [props.options, props.optionGroups]);
    const selectedOptions = React.useMemo(() => { var _a; return (_a = props.selectedOptions) !== null && _a !== void 0 ? _a : flatOptions.filter(option => isSelected(option, value)); }, [flatOptions, props.selectedOptions, isSelected, value]);
    const activeDescendantId = deriveIdentifier(menuId, activeIndex);
    const [flyoutWidth, setFlyoutWidth] = React.useState(flyoutWidthProp !== null && flyoutWidthProp !== void 0 ? flyoutWidthProp : DEFAULT_FLYOUT_WIDTH_UNITS);
    React.useEffect(() => {
        var _a, _b;
        if (!stretch || flyoutWidthProp != null) {
            setFlyoutWidth(flyoutWidthProp !== null && flyoutWidthProp !== void 0 ? flyoutWidthProp : DEFAULT_FLYOUT_WIDTH_UNITS);
            return;
        }
        const triggerWidth = (_b = (_a = triggerContainerRef.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect().width) !== null && _b !== void 0 ? _b : 0;
        const width = triggerWidth < DEFAULT_FLYOUT_WIDTH ? DEFAULT_FLYOUT_WIDTH_UNITS : 'trigger';
        setFlyoutWidth(width);
    }, [flyoutWidthProp, stretch]);
    return (_jsx(Flyout, { placement: flyoutPlacement, open: open !== null && open !== void 0 ? open : false, onRequestClose: onRequestToggle, captureFocus: focusOnMenu, width: flyoutWidth, trigger: _jsx("div", { ref: composeRefs(triggerContainerRef, props.triggerContainerRef), className: classNames(styles.triggerContainer, className, {
                [styles.triggerStretch]: stretch,
            }), children: _jsx(Trigger, { value: value, options: options, flatOptions: flatOptions, optionGroups: optionGroups, selectedOptions: selectedOptions, placeholder: placeholder, disabled: disabled, error: error, open: open, id: id, ariaLabel: ariaLabelledBy ? undefined : ariaLabel, ariaLabelledBy: ariaLabelledBy, ariaDescribedBy: ariaDescribedBy, activeIndex: activeIndex, onBlur: onBlur, onFocus: onFocus, role: "combobox", disclosure: true, labelId: labelId, active: open, ariaActiveDescendant: activeDescendantId, ariaControls: menuId, onRequestToggle: onRequestToggle, getLabel: getLabel, isSelected: isSelected, tooltipLabel: tooltipLabel, tooltipPlacement: tooltipPlacement }) }), children: ({ mode }) => (_jsx("div", { className: styles.menuContainer, ref: composeRefs(menuContainerRef, props.menuContainerRef), children: _jsx(Menu, { Item: Item, id: menuId, options: options, flatOptions: flatOptions, optionGroups: optionGroups, selectedOptions: selectedOptions, value: value, activeIndex: activeIndex, activeOption: flatOptions[activeIndex !== null && activeIndex !== void 0 ? activeIndex : -1], onItemClick: onItemClick, onItemHover: onItemHover, areEqual: areEqual, isSelected: isSelected, getLabel: getLabel, sizingMode: mode === 'popover' ? 'fixed' : 'fill', menuContainerRef: menuContainerRef, ariaLabel: ariaLabel, ariaLabelledBy: ariaLabelledBy, children: options.length === 0 ? renderEmptyMenuContent() : undefined }) })) }));
}
export function BaseSelectTrigger(props) {
    var _a, _b, _c;
    const { selectedOptions, children } = props;
    const placeholder = (_a = props.placeholder) !== null && _a !== void 0 ? _a : BaseSelectMessages.defaultPlaceholder();
    const hasPlaceholder = !selectedOptions.length;
    const label = hasPlaceholder ? placeholder : joinLabels(selectedOptions.map(props.getLabel));
    const className = classNames(styles.triggerButton, props.className, {
        [styles.open]: props.open,
        [styles.error]: props.error,
        [styles.hoverSupported]: canHover(),
    });
    const Icon = getIcon((_b = props.Icon) !== null && _b !== void 0 ? _b : 'auto', (_c = selectedOptions[0]) === null || _c === void 0 ? void 0 : _c.Icon);
    return (_jsxs(BasicButton, { onClick: props.onRequestToggle, onBlur: props.onBlur, onFocus: props.onFocus, disclosure: true, active: props.open, disabled: props.disabled, className: className, icon: ChevronDownIcon, iconSize: "small", iconPosition: "end", id: props.id, role: props.role, tooltipLabel: props.tooltipLabel, tooltipPlacement: props.tooltipPlacement, tooltipOverflowBoundariesElement: "viewport", ariaLabel: props.ariaLabel, ariaLabelledBy: props.ariaLabelledBy || (props.ariaLabel ? undefined : props.labelId), ariaDescribedBy: props.ariaDescribedBy, ariaControls: props.ariaControls, ariaHasPopup: "listbox", ariaActiveDescendant: props.ariaActiveDescendant, noChildWrapper: true, alignment: "start", children: [Icon && (_jsxs(_Fragment, { children: [_jsx(Icon, { size: "medium" }), _jsx(Spacer, { size: "1u" })] })), _jsx(Text, { id: props.labelId, tagName: "span", lineClamp: 1, tone: InheritColor, className: classNames(styles.label, { [styles.placeholder]: hasPlaceholder }), children: children !== null && children !== void 0 ? children : label })] }));
}
function getIcon(Icon, FallbackIcon) {
    if (Icon === 'none') {
        return undefined;
    }
    if (Icon === 'auto') {
        return FallbackIcon;
    }
    return Icon;
}
function useScrollToActiveItem({ activeIndex }) {
    const scrollRef = React.useRef(null);
    const activeItemRef = React.useRef(null);
    React.useEffect(() => {
        if (!scrollRef.current || !activeItemRef.current) {
            return;
        }
        if (ScrollPositioner.isAboveVisibleScroll(scrollRef.current, activeItemRef.current)) {
            ScrollPositioner.scrollToPutAtTop(scrollRef.current, activeItemRef.current);
        }
        if (ScrollPositioner.isBelowVisibleScroll(scrollRef.current, activeItemRef.current)) {
            ScrollPositioner.scrollToPutAtBottom(scrollRef.current, activeItemRef.current);
        }
    }, [activeIndex, scrollRef]);
    return { scrollRef, activeItemRef };
}
export function BaseSelectMenu(props) {
    const { Item = BaseSelectItem, flatOptions, optionGroups, value, activeIndex, id, ariaLabel, ariaLabelledBy, header, footer, isSelected, getLabel, onItemClick, onItemHover, className, children, sizingMode, } = props;
    const { scrollRef, activeItemRef } = useScrollToActiveItem({ activeIndex });
    const hasMultipleGroups = optionGroups.length > 1;
    return (_jsx(WithHeaderAndFooter, { header: header, footer: footer, children: _jsx("div", { className: classNames(styles.scrollContainer, sizingMode === 'fixed' && styles.popover, className), ref: scrollRef, id: hasMultipleGroups ? id : undefined, role: hasMultipleGroups ? 'listbox' : undefined, "aria-label": hasMultipleGroups ? ariaLabel : undefined, "aria-labelledby": hasMultipleGroups ? ariaLabelledBy : undefined, children: children
                ? _jsx("div", { role: "alert", children: children })
                : (optionGroups.map((optionGroup, groupIndex) => (_jsxs(React.Fragment, { children: [groupIndex > 0 && (_jsx("div", { className: styles.groupDivider, children: _jsx(Divider, {}) })), _jsx(OptionGroup, { Item: Item, menuId: id, id: hasMultipleGroups ? undefined : id, role: hasMultipleGroups ? 'group' : 'listbox', ariaLabel: hasMultipleGroups ? undefined : ariaLabel, ariaLabelledBy: hasMultipleGroups ? undefined : ariaLabelledBy, activeItemRef: activeItemRef, value: value, optionIndexOffset: flatOptions.findIndex(o => o === optionGroup.options[0]), activeIndex: activeIndex, label: optionGroup.label, options: optionGroup.options, isSelected: isSelected, onItemClick: onItemClick, onItemHover: onItemHover, getLabel: getLabel })] }, groupIndex)))) }) }));
}
function OptionGroup({ Item = BaseSelectItem, id, menuId, role, ariaLabel, ariaLabelledBy, value, optionIndexOffset = 0, activeIndex, label, options, isSelected, activeItemRef, onItemClick, onItemHover, getLabel, }) {
    const headingId = React.useId();
    const multiSelectable = Array.isArray(value);
    return (_jsxs(BaseMenu, { id: id, role: role, ariaMultiSelectable: multiSelectable, ariaLabel: ariaLabel, ariaLabelledBy: label ? headingId : ariaLabelledBy, children: [label != null && _jsx(MenuDivider, { id: headingId, children: label }), options.map((option, i) => {
                const selected = isSelected(option, value);
                const itemIndex = optionIndexOffset + i;
                const active = activeIndex === itemIndex;
                const id = deriveIdentifier(menuId, itemIndex);
                return (_jsx(Item, { id: id, selected: selected, active: active, forwardedRef: active ? activeItemRef : undefined, onItemClick: onItemClick, onItemHover: onItemHover, getLabel: getLabel, option: option, multiSelectable: multiSelectable }, id));
            })] }));
}
export function WindowedSelectMenu(props) {
    const { Item = BaseSelectItem, optionGroups, flatOptions, value, activeIndex, id, ariaLabel, ariaLabelledBy, header, footer, isSelected, getLabel, onItemClick, onItemHover, className, children, sizingMode, itemHeight = ITEM_HEIGHT, } = props;
    const itemSizes = React.useMemo(() => {
        const itemSizes = [];
        optionGroups.forEach((optionGroup, groupIndex) => {
            optionGroup.options.forEach((option, optionIndex) => {
                let height = itemHeight;
                if (optionIndex === 0 && groupIndex > 0) {
                    height += DIVIDER_HEIGHT;
                }
                if (optionIndex === 0 && optionGroup.label != null) {
                    height += TEXT_DIVIDER_HEIGHT;
                }
                itemSizes.push(height);
            });
        });
        return itemSizes;
    }, [itemHeight, optionGroups]);
    const { scrollRef, activeItemRef } = useScrollToActiveItem({ activeIndex });
    React.useEffect(() => {
        if (!scrollRef.current || activeIndex == null || activeIndex < 5) {
            return;
        }
        const activeOptionHeight = itemSizes[activeIndex];
        const activeOptionPosition = itemSizes.slice(0, activeIndex).reduce((a, h) => a + h);
        const paddingTop = parseInt(window.getComputedStyle(scrollRef.current).paddingTop, 10);
        const scrollOffset = scrollRef.current.offsetHeight - paddingTop - activeOptionHeight;
        scrollRef.current.scrollTop = activeOptionPosition - scrollOffset;
    }, []);
    const hasMultipleGroups = optionGroups.length > 1;
    return (_jsx(WithHeaderAndFooter, { header: header, footer: footer, children: _jsx(ScrollWindow, { layout: "vertical", children: ({ scrollableRef, scrollState }) => (_jsx("div", { className: classNames(styles.scrollContainer, sizingMode === 'fixed' && styles.popover, className), ref: composeRefs(scrollableRef, scrollRef), id: hasMultipleGroups ? id : undefined, role: hasMultipleGroups ? 'listbox' : undefined, "aria-label": hasMultipleGroups ? ariaLabel : undefined, "aria-labelledby": hasMultipleGroups ? ariaLabelledBy : undefined, children: children
                    ? _jsx("div", { role: "alert", children: children })
                    : (_jsx(WindowedList, { scrollState: scrollState, itemSizes: itemSizes, overscan: 2, children: (state, itemPositions) => {
                            if (!state) {
                                return (_jsx("div", { role: "none", style: { height: itemPositions[itemPositions.length - 1] } }));
                            }
                            const { firstVisible, lastVisible } = state;
                            const spaceBefore = itemPositions[firstVisible];
                            const spaceAfter = itemPositions[itemPositions.length - 1] - itemPositions[lastVisible];
                            const visibleGroups = sliceOptionGroups(optionGroups, firstVisible, lastVisible);
                            return (_jsxs(_Fragment, { children: [_jsx("div", { role: "none", style: { height: spaceBefore } }), visibleGroups.map(optionGroup => {
                                        const isFirstItemVisible = optionGroup.slice[0] === 0;
                                        return (_jsxs(React.Fragment, { children: [optionGroup.originalIndex > 0 && isFirstItemVisible && (_jsx("div", { className: styles.groupDivider, children: _jsx(Divider, {}) })), _jsx(OptionGroup, { Item: Item, menuId: id, id: hasMultipleGroups ? undefined : id, role: hasMultipleGroups ? 'group' : 'listbox', ariaLabel: hasMultipleGroups ? optionGroup.label : ariaLabel, ariaLabelledBy: hasMultipleGroups ? undefined : ariaLabelledBy, activeItemRef: activeItemRef, value: value, optionIndexOffset: flatOptions.findIndex(o => o === optionGroup.options[0]), activeIndex: activeIndex, label: isFirstItemVisible ? optionGroup.label : undefined, options: optionGroup.options, isSelected: isSelected, onItemClick: onItemClick, onItemHover: onItemHover, getLabel: getLabel })] }, optionGroup.originalIndex));
                                    }), _jsx("div", { role: "none", style: { height: spaceAfter } })] }));
                        } })) })) }) }));
}
function WithHeaderAndFooter(props) {
    const { header, footer, children } = props;
    return (_jsxs(_Fragment, { children: [header && (_jsx("header", { className: styles.menuHeader, children: typeof header === 'string' ? _jsx(Text, { children: header }) : header })), children, footer && (_jsx("footer", { className: styles.menuFooter, children: typeof footer === 'string' ? _jsx(Text, { children: footer }) : footer }))] }));
}
export function renderEmptyMenuContent() {
    return (_jsx(Box, { padding: "3u", children: _jsx(Text, { children: BaseSelectMessages.defaultEmptyMessage() }) }));
}
export const BaseSelectItem = React.memo(_BaseSelectItem);
function _BaseSelectItem(props) {
    var _a, _b, _c, _d;
    const { onItemClick, onItemHover, option, multiSelectable, } = props;
    const onClick = React.useCallback((event) => {
        onItemClick === null || onItemClick === void 0 ? void 0 : onItemClick(option, event);
    }, [onItemClick, option]);
    const onMouseEnter = React.useCallback((event) => {
        onItemHover === null || onItemHover === void 0 ? void 0 : onItemHover(option, event);
    }, [onItemHover, option]);
    const OptionIcon = option.Icon && _jsx(option.Icon, { size: "medium" });
    const SelectedIcon = !multiSelectable && props.selected ? _jsx(TickIcon, { size: "medium" }) : undefined;
    const CheckboxIcon = _jsx(FakeCheckbox, { checked: props.selected, disabled: props.option.disabled });
    const start = multiSelectable
        ? (_jsxs(_Fragment, { children: [CheckboxIcon, (_a = props.start) !== null && _a !== void 0 ? _a : OptionIcon] }))
        : (_b = props.start) !== null && _b !== void 0 ? _b : OptionIcon;
    const end = (_c = props.end) !== null && _c !== void 0 ? _c : SelectedIcon;
    const content = (_d = props.children) !== null && _d !== void 0 ? _d : (props.option.description != null
        ? (_jsxs(Rows, { tagName: "span", spacing: "0", children: [_jsx(Text, { tagName: "span", lineClamp: 1, children: props.getLabel(props.option) }), _jsx(Text, { tagName: "span", size: "small", tone: "tertiary", children: props.option.description })] }))
        : props.getLabel(props.option));
    return (_jsx(MenuItem, { id: props.id, ariaSelected: props.selected, buttonRef: props.forwardedRef, tabIndex: -1, onClick: onClick, onMouseEnter: onMouseEnter, start: start, end: end, className: classNames(props.className, {
            [styles.active]: props.active,
            [styles.disabled]: props.option.disabled,
        }), disabled: props.option.disabled, children: content }));
}
