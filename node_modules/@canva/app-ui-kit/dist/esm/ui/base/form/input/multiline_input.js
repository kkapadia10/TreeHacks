import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import composeRefs from '@seznam/compose-react-refs';
import classNames from 'classnames';
import { observer } from 'mobx-react';
import * as React from 'react';
import ResizeObserver from 'resize-observer-polyfill';
import { useControllableValue } from '../../controllable_value/controllable_value';
import { canHover } from '../../device_capabilities/device_capabilities';
import { useFocusState, useOnWrapperMouseDown } from './base_input';
import inputStyles from './base_input.css';
import { BaseInputContextProvider, useCreateInputControls, usePropOverrides, } from './internal/input_internal';
import styles from './multiline_input.css';
const DEFAULT_BUFFER_ROWS = 1;
const DEFAULT_MAX_ROWS = Number.POSITIVE_INFINITY;
function getVerticalPadding(domElement) {
    const window = domElement.ownerDocument.defaultView;
    const styles = window === null || window === void 0 ? void 0 : window.getComputedStyle(domElement);
    return parseInt((styles === null || styles === void 0 ? void 0 : styles.paddingBottom) || '0', 10) + parseInt((styles === null || styles === void 0 ? void 0 : styles.paddingTop) || '0', 10);
}
function useAutoGrow(
    { autoGrow, bufferRows = DEFAULT_BUFFER_ROWS, maxRows = DEFAULT_MAX_ROWS, minRows = 1, value, }
) {
    const textAreaRef = React.useRef(null);
    const remeasure = React.useCallback(() => {
        const domElement = textAreaRef.current;
        if (!domElement) {
            return;
        }
        if (!autoGrow) {
            return;
        }
        domElement.style.height = '100%';
        domElement.rows = 1;
        const rowHeight = domElement.clientHeight - getVerticalPadding(domElement);
        const contentRows = rowHeight === 0
            ? 0
            : Math.round((domElement.scrollHeight - getVerticalPadding(domElement)) / rowHeight);
        domElement.rows = Math.max(minRows + bufferRows, contentRows + bufferRows);
        domElement.rows = Math.min(maxRows, domElement.rows);
    }, [autoGrow, bufferRows, maxRows, minRows]);
    React.useLayoutEffect(remeasure, [remeasure, value]);
    const stableRemeasure = React.useRef(remeasure);
    const observerRef = React.useRef(null);
    const ref = React.useCallback((element) => {
        if (observerRef.current == null) {
            observerRef.current = new ResizeObserver(() => stableRemeasure.current());
        }
        if (textAreaRef.current != null) {
            observerRef.current.unobserve(textAreaRef.current);
        }
        textAreaRef.current = element;
        if (textAreaRef.current != null) {
            observerRef.current.observe(textAreaRef.current);
        }
    }, []);
    React.useEffect(() => {
        return () => { var _a; return (_a = observerRef.current) === null || _a === void 0 ? void 0 : _a.disconnect(); };
    }, []);
    return ref;
}
export const MultilineInput = observer(React.forwardRef(InternalMultilineInput));
MultilineInput.displayName = 'MultilineInput';
function InternalMultilineInput(props_, forwardedRef) {
    const { props, setPropOverrides } = usePropOverrides(props_);
    const { onChange, onFocus, onBlur, onChangeComplete, onKeyDown, dir = 'auto' } = props;
    const { ref: inputRef, onMouseDown: onWrapperMouseDown } = useOnWrapperMouseDown();
    const { isFocused, isKeyboardMode, setFocused } = useFocusState();
    const [value, setValue] = useControllableValue({ value: props.value });
    const autoGrowRef = useAutoGrow({ ...props, value });
    const controls = useCreateInputControls({
        focus: () => { var _a; return (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus(); },
        setDisabled: disabled => setPropOverrides({ disabled }),
        setValue: (value) => {
            setValue(value);
            onChange === null || onChange === void 0 ? void 0 : onChange(value);
        },
    });
    const _onChange = React.useCallback((e) => {
        setValue(e.target.value);
        onChange === null || onChange === void 0 ? void 0 : onChange(e.target.value, e);
    }, [onChange, setValue]);
    const _onFocus = React.useCallback((e) => {
        onFocus === null || onFocus === void 0 ? void 0 : onFocus(e);
        setFocused(true);
    }, [onFocus, setFocused]);
    const _onBlur = React.useCallback((e) => {
        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
        onChangeComplete === null || onChangeComplete === void 0 ? void 0 : onChangeComplete(e.target.value);
        setFocused(false);
    }, [onBlur, onChangeComplete, setFocused]);
    const _onKeyDown = React.useCallback((e) => {
        if (e.keyCode === 229) {
            e.stopPropagation();
            return;
        }
        onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(e);
    }, [onKeyDown]);
    const { autoComplete = 'browser_default' } = props;
    const autoCompleteValue = autoComplete === 'browser_default' ? undefined : autoComplete === 'on' ? 'on' : 'no';
    const wrapperClassName = classNames(inputStyles.wrapper, styles.multilineWrapper, {
        [inputStyles.hoverSupported]: canHover(),
        [inputStyles.focusOutline]: isFocused && isKeyboardMode,
        [inputStyles.borderless]: props.borderless,
        [styles.resize]: props.resize,
    }, 
    (props.disabled && inputStyles.disabled)
        || (isFocused && inputStyles.active) || (props.error && inputStyles.error), props.className);
    const inputClassName = classNames(inputStyles.textField, styles.multilineTextField, props.inputClassName);
    return (_jsx(
        "div",
        { className: wrapperClassName, onMouseDown: onWrapperMouseDown, children: _jsxs(BaseInputContextProvider, { controls: controls, value: value !== null && value !== void 0 ? value : '', children: [_jsx("textarea", { className: inputClassName, value: value, onChange: _onChange, onFocus: _onFocus, onBlur: _onBlur, onKeyPress: props.onKeyPress, onKeyDown: _onKeyDown, onKeyUp: props.onKeyUp, ref: composeRefs(inputRef, autoGrowRef, forwardedRef), dir: dir, autoComplete: autoCompleteValue, disabled: props.disabled, placeholder: props.placeholder, maxLength: props.maxLength, lang: props.lang, rows: props.minRows, id: props.id, "aria-label": props.ariaLabel, "aria-labelledby": props.ariaLabelledBy, "aria-describedby": props.ariaDescribedBy, required: props.required, readOnly: props.readOnly }), props.footer] }) }
    ));
}
