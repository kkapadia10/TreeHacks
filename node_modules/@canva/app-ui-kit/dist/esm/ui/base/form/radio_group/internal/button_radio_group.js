import { makeObservable } from '../../../../../base/make_observable/make_observable';
import { __decorate } from "tslib";
import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import composeRefs from '@seznam/compose-react-refs';
import classNames from 'classnames';
import * as mobx from 'mobx';
import * as mobxReact from 'mobx-react';
import * as React from 'react';
import { BasicButton } from '../../../button/button';
import { useKeyCombinationHandler } from '../../../key_combinations/use_key_combination_handler';
import { Grid } from '../../../layout/layout';
import { Text } from '../../../typography/typography';
import styles from '../radio_group.css';
const ButtonItem = React.memo(function ButtonItem({
  active,
  disabled,
  label,
  description,
  onClick,
  tabbable,
  className,
  ariaLabel,
  focusRef,
  onFocus,
  onBlur
}) {
  const descriptionId = React.useId();
  return _jsx(BasicButton, {
    className: classNames(styles.buttonItem, {
      [styles.buttonItemActive]: active
    }, className),
    ariaLabel: ariaLabel,
    disabled: disabled,
    onClick: onClick,
    type: "button",
    role: "radio",
    active: active,
    tabIndex: active || tabbable ? undefined : -1,
    focusRef: focusRef,
    onFocus: onFocus,
    onBlur: onBlur,
    noChildWrapper: true,
    ariaDescribedBy: description ? descriptionId : undefined,
    children: _jsx(ButtonItemLabel, {
      label: label,
      description: description,
      disabled: disabled,
      active: active,
      descriptionId: descriptionId
    })
  });
});
function ButtonItemLabel({
  label,
  description,
  disabled,
  active,
  descriptionId
}) {
  const labelElement = typeof label === 'string' ? _jsx(Text, {
    tagName: "span",
    margins: "none",
    alignment: "center",
    tone: disabled ? 'tertiary' : 'primary',
    weight: active ? 'bold' : 'regular',
    children: label
  }) : _jsx(_Fragment, {
    children: label
  });
  if (!description) {
    return labelElement;
  }
  return _jsxs(_Fragment, {
    children: [labelElement, _jsx("div", {
      "aria-hidden": true,
      children: _jsx(Text, {
        id: descriptionId,
        tagName: "span",
        tone: "tertiary",
        size: "small",
        children: description
      })
    })]
  });
}
let ButtonItemContainer = class ButtonItemContainer extends React.Component {
  static _makeObservable(instance) {
    makeObservable(instance, {
      onClick: mobx.computed
    });
  }
  constructor(...args) {
    super(...args);
    ButtonItemContainer._makeObservable(this);
  }
  get onClick() {
    const {
      option,
      active,
      onChange
    } = this.props;
    return event => !active && (onChange === null || onChange === void 0 ? void 0 : onChange(option.value, event));
  }
  render() {
    var _a;
    const {
      active,
      disabled,
      option,
      tabbable,
      className,
      focusRef,
      onFocus,
      onBlur
    } = this.props;
    return _jsx(ButtonItem, {
      ariaLabel: option.ariaLabel,
      active: active,
      disabled: (_a = option.disabled) !== null && _a !== void 0 ? _a : disabled,
      tabbable: tabbable,
      className: className,
      focusRef: focusRef,
      onClick: this.onClick,
      onFocus: onFocus,
      onBlur: onBlur,
      label: option.label,
      description: option.description
    });
  }
};
ButtonItemContainer = __decorate([mobxReact.observer], ButtonItemContainer);
function _ButtonRadioGroup(props, ref) {
  const {
    itemsPerRow,
    disabled,
    options,
    value,
    id,
    ariaLabel,
    ariaLabelledBy,
    ariaDescribedBy,
    className,
    focusRef: focusRefProp,
    onChange,
    onFocus,
    onBlur
  } = props;
  const shouldFocus = React.useRef(false);
  const activeRef = React.useRef(null);
  React.useEffect(() => {
    var _a;
    if (shouldFocus.current) {
      (_a = activeRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }
  }, [shouldFocus, value]);
  const availableOptions = options.filter(option => {
    return !option.disabled;
  });
  const firstAvailableOption = availableOptions[0];
  const moveSelection = delta => {
    const currentIndex = availableOptions.findIndex(option => option.value === value);
    const newIndex = ((currentIndex > -1 ? currentIndex : 0) + availableOptions.length + delta) % availableOptions.length;
    shouldFocus.current = true;
    onChange === null || onChange === void 0 ? void 0 : onChange(availableOptions[newIndex].value);
  };
  const {
    ref: keyRef
  } = useKeyCombinationHandler([['ArrowUp', () => moveSelection(-1)], ['ArrowDown', () => moveSelection(1)], ['previous', () => moveSelection(-1)], ['next', () => moveSelection(1)]], {
    handleInputs: true
  });
  return _jsx("div", {
    ref: composeRefs(keyRef, ref),
    className: className,
    role: "radiogroup",
    id: id,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    "aria-describedby": ariaDescribedBy,
    children: _jsx(Grid, {
      spacing: "1u",
      columns: itemsPerRow || options.length,
      children: options.map((option, idx) => {
        const tabbable = option === firstAvailableOption && value === undefined;
        const isCurrentItemSelected = option.value === value;
        const hasFocusRef = value != null ? isCurrentItemSelected : option === firstAvailableOption;
        const focusRef = composeRefs(hasFocusRef ? focusRefProp : undefined, isCurrentItemSelected ? activeRef : undefined);
        return _jsx(ButtonItemContainer, {
          disabled: disabled,
          active: isCurrentItemSelected,
          option: option,
          tabbable: tabbable,
          className: option.className,
          focusRef: focusRef,
          onChange: onChange,
          onFocus: onFocus,
          onBlur: onBlur
        }, idx);
      })
    })
  });
}
export const ButtonRadioGroup = React.forwardRef(_ButtonRadioGroup);