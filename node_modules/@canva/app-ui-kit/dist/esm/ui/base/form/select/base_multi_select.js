import { makeObservable } from '../../../../base/make_observable/make_observable';
import { __decorate } from "tslib";
import { jsx as _jsx } from "react/jsx-runtime";
import { exists } from '../../../../base/exists';
import * as mobx from 'mobx';
import * as React from 'react';
import { BaseSelect } from './base_select';
import { BaseSelectMessages } from './base_select.messages';
import { BaseSelectPresenter, BaseSelectStore } from './base_select_presenter';
import { defaultAreEqual, defaultIsSelected, flattenOptions } from './base_select_util';
import { BaseSelectItem, BaseSelectTrigger } from './stateless_base_select';
const selectAllValue = Symbol();
const selectAllOption = {
  value: selectAllValue,
  label: BaseSelectMessages.selectAll()
};
export class BaseMultiSelectStore extends BaseSelectStore {
  static _makeObservable(instance) {
    makeObservable(instance, {
      value: mobx.observable.ref
    });
  }
  constructor(...args) {
    super(...args);
    BaseMultiSelectStore._makeObservable(this);
  }
}
export class BaseMultiSelect extends React.Component {
  constructor() {
    var _a, _b;
    super(...arguments);
    this.store = (_a = this.props.store) !== null && _a !== void 0 ? _a : new BaseMultiSelectStore();
    this.presenter = (_b = this.props.presenter) !== null && _b !== void 0 ? _b : new BaseSelectPresenter();
    this.isSelected = (option, value) => {
      if (option.value === selectAllValue) {
        return this.isAllSelected();
      }
      const {
        isSelected = defaultIsSelected
      } = this.props;
      return isSelected(option, value);
    };
    this.onSelection = option => {
      var _a, _b, _c, _d;
      if (option.value === selectAllValue) {
        return this.onSelectAll();
      }
      if (option.value == null) {
        return;
      }
      const {
        isSelected = defaultIsSelected,
        areEqual = defaultAreEqual
      } = this.props;
      const value = (_b = (_a = this.value) === null || _a === void 0 ? void 0 : _a.slice()) !== null && _b !== void 0 ? _b : [];
      const newValue = isSelected(option, value) ? value.filter(v => !areEqual(v, option.value)) : value.concat(option.value);
      if (this.props.maxSelectedOptions && this.isAllSelected() && newValue.length > value.length) {
        return;
      }
      this.presenter.setValue(this.store, newValue);
      (_d = (_c = this.props).onChange) === null || _d === void 0 ? void 0 : _d.call(_c, newValue);
    };
    this.onSelectAll = () => {
      var _a, _b;
      let newValue = this.isAllSelected() ? [] : this.getAvailableOptions().map(option => option.value).filter(exists);
      const disabledSelectedOptions = this.getDisabledOptions().map(option => this.isSelected(option, this.value) ? option.value : undefined).filter(exists);
      if (this.props.maxSelectedOptions) {
        newValue = newValue.slice(0, this.props.maxSelectedOptions - disabledSelectedOptions.length);
      }
      newValue = newValue.concat(disabledSelectedOptions);
      this.presenter.setValue(this.store, newValue);
      (_b = (_a = this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, newValue);
    };
    this.Trigger = React.memo(props => {
      const {
        Trigger = BaseSelectTrigger,
        options
      } = this.props;
      return _jsx(Trigger, {
        ...props,
        options: options
      });
    });
    this.Item = React.memo(props => {
      return _jsx(BaseSelectItem, {
        ...props,
        multiSelectable: true,
        children: props.option.value === selectAllValue ? props.option.label : props.getLabel(props.option)
      });
    });
  }
  get value() {
    var _a;
    return (_a = this.props.value) !== null && _a !== void 0 ? _a : this.store.value;
  }
  isAllSelected() {
    if (!this.value) {
      return false;
    }
    if (this.props.maxSelectedOptions && this.value.length >= this.props.maxSelectedOptions) {
      return true;
    }
    if (this.value.length === flattenOptions(this.props.options).length) {
      return true;
    }
    let valueWithoutDisabledOptions = this.value;
    this.getDisabledOptions().forEach(option => {
      valueWithoutDisabledOptions = valueWithoutDisabledOptions.filter(value => value !== option.value);
    });
    return Array.isArray(valueWithoutDisabledOptions) && valueWithoutDisabledOptions.length === this.getAvailableOptions().length;
  }
  getAvailableOptions() {
    return flattenOptions(this.props.options).filter(option => !option.disabled);
  }
  getDisabledOptions() {
    return flattenOptions(this.props.options).filter(option => option.disabled);
  }
  render() {
    const {
      showSelectAll,
      options,
      maxSelectedOptions
    } = this.props;
    const finalShowSelectAll = showSelectAll && (!maxSelectedOptions || maxSelectedOptions >= options.length);
    return _jsx(BaseSelect, {
      store: this.store,
      presenter: this.presenter,
      Trigger: this.Trigger,
      Item: this.Item,
      onSelection: this.onSelection,
      closeOnSelection: false,
      ...this.props,
      isSelected: this.isSelected,
      options: finalShowSelectAll ? [selectAllOption, ...options] : options
    });
  }
}