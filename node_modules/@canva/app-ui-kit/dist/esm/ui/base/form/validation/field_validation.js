import { makeObservable } from '../../../../base/make_observable/make_observable';
import { __decorate } from "tslib";
import { Fragment as _Fragment, jsx as _jsx } from "react/jsx-runtime";
import * as mobx from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';
import { Validation } from '../../validation/validation';
import { useRegisterFormValidation } from './form_validation_store';
export const valid = Validation.valid;
export const invalid = Validation.invalid;
export class FieldValidationStore {
  static _makeObservable(instance) {
    makeObservable(instance, {
      value: mobx.observable.ref,
      validationStarted: mobx.observable.ref,
      validationFn: mobx.observable.ref
    });
  }
  constructor({
    value,
    validator
  }) {
    FieldValidationStore._makeObservable(this);
    this.value = undefined;
    this.validationStarted = false;
    this.value = value;
    this.validator = validator;
  }
  get validator() {
    return this.validationFn;
  }
  set validator(validator) {
    this.validationFn = validator != null ? getValidationFn(validator) : undefined;
  }
}
export const setValue = mobx.action((store, value) => {
  store.value = value;
});
export const startValidation = mobx.action(store => {
  store.validationStarted = true;
});
export const getResult = store => {
  var _a, _b;
  return (_b = (_a = store.validator) === null || _a === void 0 ? void 0 : _a.call(store, store.value)) !== null && _b !== void 0 ? _b : Validation.valid();
};
export const getError = store => {
  const result = store.validationStarted ? getResult(store) : undefined;
  if ((result === null || result === void 0 ? void 0 : result.state) === 'invalid') {
    return result.error;
  }
};
export const validateAll = (...stores) => {
  let isValid = true;
  for (const v of stores) {
    if (v == null) {
      continue;
    }
    startValidation(v);
    isValid && (isValid = getResult(v).state === 'valid');
  }
  return isValid;
};
export const isValid = (...stores) => {
  for (const v of stores) {
    if (v != null && getError(v) != null) {
      return false;
    }
  }
  return true;
};
export function useFieldValidation(
  {
    store: storeProp,
    name,
    value,
    validator
  }
) {
  const [store, setStore] = React.useState(() => {
    if (storeProp != null) {
      return storeProp;
    }
    if (validator != null) {
      return new FieldValidationStore({
        value,
        validator
      });
    }
  });
  React.useEffect(() => {
    if (store == null && validator != null) {
      setStore(new FieldValidationStore({
        value,
        validator
      }));
    }
  }, [store, validator, value]);
  useRegisterFormValidation({
    name,
    fieldValidation: store
  });
  React.useEffect(() => {
    if (storeProp == null && store != null) {
      mobx.runInAction(() => {
        store.value = value;
        store.validator = validator;
      });
    }
  }, [store, storeProp, value, validator]);
  return store;
}
export const WithFieldValidation = observer(function WithFieldValidation({
  children,
  ...rest
}) {
  const store = useFieldValidation(rest);
  return _jsx(_Fragment, {
    children: children({
      store
    })
  });
});
export function getValidationFn(validator) {
  if (Array.isArray(validator)) {
    if (isValidationMessageTuple(validator)) {
      return mapErrorMessage(...validator);
    }
    return anyError(validator);
  }
  return validator;
}
function isValidationMessageTuple(validator) {
  return validator.length === 2 && typeof validator[1] === 'string';
}
export const mapErrorMessage = (boolValidator, errorMessage) => {
  return value => {
    const result = boolValidator(value);
    if (result.state === 'invalid') {
      return Validation.invalid(errorMessage);
    }
    return result;
  };
};
export const anyError = validators => Validation.all(validators.map(v => getValidationFn(v)));
export const allErrors = validators => value => {
  let errors = [];
  for (const validator of validators) {
    const validationFn = getValidationFn(validator);
    const result = validationFn(value);
    if (result.state === 'invalid') {
      if (Array.isArray(result.error)) {
        errors = errors.concat(result.error);
      } else {
        errors.push(result.error);
      }
    }
  }
  if (errors.length) {
    return Validation.invalid(errors);
  }
  return Validation.valid();
};
export const ignoreNullValue = validationFn => {
  return value => {
    if (value == null) {
      return valid();
    }
    return validationFn(value);
  };
};
export const ignoreNullValueInFactory = fnFactory => {
  return args => ignoreNullValue(fnFactory(args));
};