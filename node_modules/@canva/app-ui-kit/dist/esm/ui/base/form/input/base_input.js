import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import composeRefs from '@seznam/compose-react-refs';
import { exists } from '../../../../base/exists';
import { UnreachableError } from '../../../../base/preconditions';
import classNames from 'classnames';
import { action } from 'mobx';
import { observer, useLocalObservable } from 'mobx-react';
import * as React from 'react';
import { accessModeState } from '../../a11y/access_mode_state/access_mode_state';
import { useControllableValue } from '../../controllable_value/controllable_value';
import { canHover, isVirtualKeyboard } from '../../device_capabilities/device_capabilities';
import { CalendarIcon } from '../../icons/calendar/icon';
import { CreditCardNumberIcon } from '../../icons/credit_card_number/icon';
import { CreditCardVerificationIcon } from '../../icons/credit_card_verification/icon';
import { EmailIcon } from '../../icons/email/icon';
import { LinkIcon } from '../../icons/link/icon';
import { LocationIcon } from '../../icons/location/icon';
import { PersonIcon } from '../../icons/person/icon';
import { SearchIcon } from '../../icons/search/icon';
import { Spacer } from '../../layout/spacer/spacer';
import styles from './base_input.css';
import { BaseInputContextProvider, useCreateInputControls, usePropOverrides, } from './internal/input_internal';
export { useInputControls, useInputValue } from './internal/input_internal';
function getLegacyIcon({ icon, iconClassName }, position) {
    return (icon === null || icon === void 0 ? void 0 : icon.align) === position && _jsx(Icon, { ...icon, className: iconClassName });
}
function getDecoration(decoration) {
    const content = typeof decoration === 'function' ? decoration() : decoration;
    return content
        ? (_jsx("div", { className: styles.decoration, children: React.isValidElement(content) && content.type === React.Fragment
                ? React.Children.toArray(content.props.children).filter(exists).map(addLeadingSpace)
                : content }))
        : undefined;
}
function addLeadingSpace(child, index) {
    return index === 0 ? child : [_jsx(Spacer, { size: "0.5u" }, index), child];
}
export function useFocusState() {
    const store = useLocalObservable(() => ({
        isFocused: false,
        setFocused: action((value) => (store.isFocused = value)),
    }));
    return {
        isFocused: store.isFocused,
        isKeyboardMode: accessModeState.isKeyboardMode,
        setFocused: store.setFocused,
    };
}
export function useOnWrapperMouseDown() {
    const ref = React.useRef(null);
    const onMouseDown = React.useCallback((e) => {
        var _a;
        let el = e.target;
        while (el && el !== e.currentTarget) {
            if (isInteractive(el)) {
                return;
            }
            el = el.parentElement;
        }
        e.stopPropagation();
        e.preventDefault();
        (_a = ref.current) === null || _a === void 0 ? void 0 : _a.focus();
    }, []);
    return { ref, onMouseDown };
}
function isInteractive(el) {
    return (el.tagName === 'A'
        || el.tagName === 'BUTTON'
        || el.tagName === 'INPUT'
        || el.tagName === 'TEXTAREA'
        || el.getAttribute('tabIndex') != null);
}
export const BaseInput = observer(React.forwardRef(InternalBaseInput));
function InternalBaseInput(props_, forwardedRef) {
    var _a, _b, _c;
    const { props, setPropOverrides } = usePropOverrides(props_);
    const { blurOnEnterKeyDown, onChange, onFocus, onBlur, onKeyDown, onChangeComplete, } = props;
    const { ref: inputRef, onMouseDown: onWrapperMouseDown } = useOnWrapperMouseDown();
    const { isFocused, isKeyboardMode, setFocused } = useFocusState();
    const [value, setValue] = useControllableValue({
        value: props.value,
        defaultValue: (_a = props.defaultValue) !== null && _a !== void 0 ? _a : '',
    });
    const startDecoration = getDecoration((_b = props.start) !== null && _b !== void 0 ? _b : getLegacyIcon(props, 'start'));
    const endDecoration = getDecoration((_c = props.end) !== null && _c !== void 0 ? _c : getLegacyIcon(props, 'end'));
    const controls = useCreateInputControls({
        focus: () => { var _a; return (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus(); },
        setType: type => setPropOverrides(type ? { type } : undefined),
        setDisabled: disabled => setPropOverrides({ disabled }),
        setValue: (value) => {
            setValue(value);
            onChange === null || onChange === void 0 ? void 0 : onChange(value);
        },
    });
    const _onChange = React.useCallback((e) => {
        setValue(e.target.value);
        onChange === null || onChange === void 0 ? void 0 : onChange(e.target.value, e);
    }, [onChange, setValue]);
    const _onFocus = React.useCallback((e) => {
        onFocus === null || onFocus === void 0 ? void 0 : onFocus(e);
        setFocused(true);
    }, [onFocus, setFocused]);
    const _onBlur = React.useCallback((e) => {
        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
        onChangeComplete === null || onChangeComplete === void 0 ? void 0 : onChangeComplete(e.target.value);
        setFocused(false);
    }, [onBlur, onChangeComplete, setFocused]);
    const _onKeyDown = React.useCallback((e) => {
        var _a;
        if (e.keyCode === 229) {
            e.stopPropagation();
            return;
        }
        if (e.key === 'Enter' && blurOnEnterKeyDown) {
            (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.blur();
        }
        onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(e);
        if (!blurOnEnterKeyDown && e.key === 'Enter') {
            onChangeComplete === null || onChangeComplete === void 0 ? void 0 : onChangeComplete(e.currentTarget.value);
        }
    }, [onKeyDown, onChangeComplete, blurOnEnterKeyDown, inputRef]);
    const wrapperClassName = classNames(styles.wrapper, {
        [styles.hoverSupported]: canHover(),
        [styles.focusOutline]: isFocused && isKeyboardMode,
        [styles.borderless]: props.borderless,
        [styles.withStartDecoration]: startDecoration != null,
        [styles.withEndDecoration]: endDecoration != null,
    }, 
    (props.disabled && styles.disabled)
        || (isFocused && styles.active) || (props.error && styles.error), props.className);
    const inputClassName = classNames(styles.textField, {
        [styles.textAlignCenter]: props.textAlignCenter,
        [styles.noAutocomplete]: props.autoComplete === 'off',
    }, props.inputClassName);
    return (_jsx(
        "div",
        { className: wrapperClassName, onMouseDown: onWrapperMouseDown, children: _jsxs(BaseInputContextProvider, { controls: controls, value: value, children: [startDecoration, _jsx("input", { id: props.id, className: inputClassName, value: value, onChange: _onChange, onFocus: _onFocus, onBlur: _onBlur, onKeyDown: _onKeyDown, onClick: props.onClick, onMouseDown: props.onMouseDown, onMouseUp: props.onMouseUp, onContextMenu: props.onContextMenu, onPaste: props.onPaste, onKeyUp: props.onKeyUp, ref: composeRefs(inputRef, forwardedRef), dir: "auto", spellCheck: props.disableSpellcheck ? false : undefined, type: props.type, inputMode: props.inputMode, autoCapitalize: props.autoCapitalize, autoCorrect: props.autoCorrect, pattern: props.pattern, autoFocus: props.autoFocus === 'always'
                            || (props.autoFocus === 'on-desktop' && !isVirtualKeyboard()), autoComplete: props.autoComplete, disabled: props.disabled, readOnly: props.readOnly, maxLength: props.maxLength, max: props.max, min: props.min, placeholder: props.placeholder, step: props.step, name: props.name, role: props.role, "aria-roledescription": props.ariaRoleDescription, "aria-required": props.required || undefined, "aria-invalid": props.error || undefined, "aria-label": props.ariaLabel, "aria-labelledby": props.ariaLabelledBy, "aria-describedby": props.ariaDescribedBy, "aria-autocomplete": props.ariaAutoComplete, "aria-activedescendant": props.ariaActiveDescendant, "aria-controls": props.ariaControls, "aria-expanded": props.ariaExpanded, "aria-haspopup": props.ariaHasPopup, "aria-valuenow": props.ariaValueNow, "aria-valuetext": props.ariaValueText, "aria-valuemin": props.ariaValueMin, "aria-valuemax": props.ariaValueMax }), endDecoration] }) }
    ));
}
function Icon({ type, className }) {
    const props = {
        size: 'medium',
        tone: 'primary',
        className,
    };
    switch (type) {
        case 'credit-card':
            return _jsx(CreditCardNumberIcon, { ...props });
        case 'credit-card-expiry':
            return _jsx(CalendarIcon, { ...props });
        case 'credit-card-verification':
            return _jsx(CreditCardVerificationIcon, { ...props });
        case 'email':
            return _jsx(EmailIcon, { ...props });
        case 'link':
            return _jsx(LinkIcon, { ...props });
        case 'location':
            return _jsx(LocationIcon, { ...props });
        case 'person':
            return _jsx(PersonIcon, { ...props });
        case 'search':
            return _jsx(SearchIcon, { ...props });
        default:
            throw new UnreachableError(type);
    }
}
