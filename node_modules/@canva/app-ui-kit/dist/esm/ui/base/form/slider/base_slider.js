import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import composeRefs from '@seznam/compose-react-refs';
import classNames from 'classnames';
import { observer } from 'mobx-react';
import * as React from 'react';
import Measure from 'react-measure';
import { NeverSnap } from './bar_snap_behavior';
import styles, { customProperties } from './base_slider.css';
import sliderStyles from './slider.css';
export class BaseSlider extends React.PureComponent {
    constructor(props) {
        super(props);
        this.inputRef = React.createRef();
        this.snapBehavior = this.props.snapBehavior || new NeverSnap();
        this.isDragging = false;
        this.keyPressed = false;
        this.onDragStart = (value) => {
            var _a, _b;
            this.dragStartValue = this.clamp(value);
            this.isDragging = true;
            this.setState({ active: true });
            (_b = (_a = this.props).onDragStart) === null || _b === void 0 ? void 0 : _b.call(_a);
        };
        this.onDragEnd = (newValue) => {
            var _a, _b, _c, _d, _e;
            if (!this.isDragging) {
                return;
            }
            this.isDragging = false;
            this.setState({ active: false });
            this.props.blurOnDragEnd && ((_a = this.inputRef.current) === null || _a === void 0 ? void 0 : _a.blur());
            newValue != null && ((_c = (_b = this.props).onChangeComplete) === null || _c === void 0 ? void 0 : _c.call(_b, this.dragStartValue, newValue));
            (_e = (_d = this.props).onDragEnd) === null || _e === void 0 ? void 0 : _e.call(_d);
        };
        this.onMouseUp = (event) => {
            const target = event.target;
            target.removeEventListener('mouseup', this.onMouseUp);
            const value = this.clamp(parseFloat(target.value));
            this.onDragEnd(value);
        };
        this.onMouseDown = (event) => {
            const target = event.target;
            target.addEventListener('mouseup', this.onMouseUp, { once: true });
            const value = this.clamp(parseFloat(target.value));
            this.onDragStart(value);
        };
        this.onTouchStart = (event) => {
            if (event.touches.length > 1) {
                return;
            }
            const target = event.target;
            const value = this.clamp(parseFloat(target.value));
            this.onDragStart(value);
        };
        this.onTouchEnd = (event) => {
            if (event.touches.length > 0) {
                return;
            }
            const target = event.target;
            const value = this.clamp(parseFloat(target.value));
            this.onDragEnd(value);
        };
        this.onResize = (contentRect) => {
            if (contentRect.entry) {
                this.setState({ width: contentRect.entry.width });
            }
        };
        this.onBarResize = (contentRect) => {
            var _a, _b;
            if (contentRect.offset) {
                (_b = (_a = this.props).onBarResize) === null || _b === void 0 ? void 0 : _b.call(_a, { width: contentRect.offset.width, start: contentRect.offset.left });
            }
        };
        this.onKeyDown = () => {
            this.keyPressed = true;
            this.snapBehavior.onKeyDown();
        };
        this.onKeyUp = () => {
            this.keyPressed = false;
            this.snapBehavior.onKeyUp();
        };
        this.onFocus = () => this.setState({ focused: true });
        this.onBlur = () => this.setState({ focused: false });
        this.onMouseEnter = () => this.setState({ hovering: true });
        this.onMouseLeave = () => this.setState({ hovering: false });
        this.onChange = (event) => {
            var _a, _b;
            const newValue = this.clamp(parseFloat(event.target.value));
            const range = this.props.max - this.props.min;
            const pxPerUnit = this.state.width / range;
            this.snapBehavior.onChange(this.props, newValue, pxPerUnit);
            if (this.keyPressed) {
                (_b = (_a = this.props).onChangeComplete) === null || _b === void 0 ? void 0 : _b.call(_a, this.props.value, newValue);
            }
        };
        this.state = { active: false, focused: false, hovering: false, width: 0 };
        this.dragStartValue = this.clamp(props.value);
    }
    componentWillUnmount() {
        this.isDragging && this.onDragEnd();
    }
    render() {
        const { id, min, max, step, snap, value, disabled, ariaLabel, ariaLabelledBy, ariaDescribedBy, ariaValueText, trackFill, Track = DefaultTrack, Knob = DefaultKnob, } = this.props;
        return (_jsxs("div", { className: styles.root, children: [_jsx(Measure, { onResize: this.onResize, children: ({ measureRef }) => (_jsx("input", { id: id, className: classNames(styles.hiddenSlider, {
                            [styles.disabled]: disabled,
                        }), ref: composeRefs(measureRef, this.inputRef), type: "range", onChange: this.onChange, onKeyDown: this.onKeyDown, onKeyUp: this.onKeyUp, onFocus: this.onFocus, onBlur: this.onBlur, onMouseEnter: this.onMouseEnter, onMouseLeave: this.onMouseLeave, onTouchStart: this.onTouchStart, onTouchEnd: this.onTouchEnd, onMouseDown: this.onMouseDown, min: min, max: max, step: step, value: value, disabled: disabled, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy, "aria-valuetext": ariaValueText })) }), _jsx(Measure, { offset: true, onResize: this.onBarResize, children: ({ measureRef }) => (_jsxs("div", { className: styles.styledBarRoot, ref: measureRef, children: [_jsx(Track, { trackFill: trackFill, min: min, max: max, snap: snap }), _jsx("div", { className: styles.knobPositioner, style: this.knobPositionerStyle, children: _jsx(Knob, { ...this.state, value: value, disabled: disabled, trackFill: trackFill }) })] })) })] }));
    }
    valueAsPercent(value) {
        const range = this.props.max - this.props.min;
        const valueFromMin = this.clamp(value) - this.props.min;
        const percent = (valueFromMin / range) * 100;
        return percent > 99.5 ? 100 : percent;
    }
    normalizeOrigin(origin) {
        const { min, max } = this.props;
        if (origin < min) {
            return min;
        }
        if (origin > max) {
            return max;
        }
        return origin;
    }
    get knobPositionerStyle() {
        const { min, max, snap, value } = this.props;
        const finalValue = value == null ? min + (max - min) / 2 : value;
        const startingPoint = this.props.origin != null ? this.normalizeOrigin(this.props.origin) : snap;
        const valueAsPercent = this.valueAsPercent(finalValue);
        const snapAsPercent = startingPoint != null ? ((startingPoint - min) / (max - min)) * 100 : undefined;
        if (snapAsPercent == null) {
            return { width: `${valueAsPercent}%` };
        }
        if (valueAsPercent >= snapAsPercent) {
            return {
                width: `${valueAsPercent - snapAsPercent}%`,
                [customProperties.knobPositionerMargin]: `${snapAsPercent}%`,
            };
        }
        return {
            width: `${snapAsPercent - valueAsPercent}%`,
            [customProperties.knobPositionerMargin]: `${valueAsPercent}%`,
            transform: `scaleX(-1)`,
        };
    }
    clamp(value) {
        return Math.min(Math.max(this.props.min, value), this.props.max);
    }
}
const DefaultTrack = observer(({ min, max, snap, trackFill }) => {
    const customStyles = trackFill
        ? { background: trackFill }
        : undefined;
    const markerBufferWidth = snap != null
        && `calc(${((snap - min) / (max - min)) * 100}% - 0.5 * ${sliderStyles.zeroMarkerSize})`;
    return (_jsx("div", { className: sliderStyles.track, style: customStyles, children: markerBufferWidth && (_jsxs(_Fragment, { children: [_jsx("div", { className: sliderStyles.markerBuffer, style: { width: markerBufferWidth } }), _jsx("div", { className: sliderStyles.marker })] })) }));
});
const DefaultKnob = ({ active, hovering, focused, trackFill, disabled, value }) => {
    const progressIndicatorClass = classNames(sliderStyles.progressIndicator, {
        [sliderStyles.transparentProgressIndicator]: trackFill !== undefined,
        [sliderStyles.noValue]: value == null,
        [sliderStyles.disabled]: disabled,
    });
    return (_jsx("div", { className: progressIndicatorClass, children: _jsx("div", { className: classNames(sliderStyles.knob, {
                [sliderStyles.active]: !disabled && active,
                [sliderStyles.focused]: !disabled && focused,
                [sliderStyles.hovering]: !disabled && hovering,
                [sliderStyles.disabled]: disabled,
            }) }) }));
};
