import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import classNames from 'classnames';
import { observer } from 'mobx-react';
import * as React from 'react';
import { WithIdentifiers } from '../../a11y/identifier/identifier';
import { useControllableValue } from '../../controllable_value/controllable_value';
import { NumberInput } from '../input/number_input';
import { Label } from '../label_text/label_text';
import { Snap } from './bar_snap_behavior';
import { BaseSlider } from './base_slider';
import styles from './slider.css';
export const Slider = observer(function Slider({ id, min, max, snap, step, origin, value: valueProp, defaultValue, onDragStart, onDragEnd: onDragEndProp, trackFill, label, labelSize = 'medium', ariaLabelledBy, disabled, autoFocusNumericInput, NumericInput, colorVariant, blurOnDragEnd, ariaLabel, ariaDescribedBy, ariaValueText, onChange: onChangeProp, onChangeComplete, }) {
    const [value, setValue] = useControllableValue({
        value: valueProp,
        defaultValue,
    });
    const [initialValue, setInitialValue] = React.useState(value);
    const snapBehaviour = React.useMemo(() => (snap != null ? new Snap(snap) : undefined), [snap]);
    const onChange = React.useCallback((newValue) => {
        setValue(newValue);
        setInitialValue(newValue);
        onChangeProp === null || onChangeProp === void 0 ? void 0 : onChangeProp(newValue);
    }, [setValue, onChangeProp]);
    const onInputChangeComplete = React.useCallback((newValue) => {
        try {
            onChange(newValue);
            onChangeComplete === null || onChangeComplete === void 0 ? void 0 : onChangeComplete(initialValue, newValue);
        }
        finally {
            setInitialValue(newValue);
        }
    }, [initialValue, setInitialValue, onChange, onChangeComplete]);
    const sliderClassName = classNames(styles.container, colorVariant === undefined && styles.default, colorVariant === 'mono' && styles.mono, colorVariant === 'alternate' && styles.alternate, NumericInput === 'none' && styles.noNumberInput, label ? styles.labelledSlider : styles.standardSlider);
    return (_jsx(WithIdentifiers, { children: labelId => {
            const _ariaLabelledBy = ariaLabelledBy !== null && ariaLabelledBy !== void 0 ? ariaLabelledBy : (label == null ? undefined : labelId);
            const numberInput = (_jsx(_Fragment, { children: NumericInput !== 'none' && (_jsx(SliderNumberInput, { className: styles.numberInputContainer, inputClassName: styles.numberInput, value: value, NumericInput: NumericInput, min: min, max: max, step: step, disabled: disabled, autoFocus: autoFocusNumericInput, onChangeComplete: onInputChangeComplete, ariaLabel: ariaLabel, ariaLabelledBy: _ariaLabelledBy, ariaDescribedBy: ariaDescribedBy })) }));
            return (_jsxs("div", { className: sliderClassName, children: [label && (_jsx(Label, { id: labelId, size: labelSize, variant: "regular", children: label })), label && numberInput, _jsx("div", { className: styles.slider, children: _jsx(BaseSlider, { id: id, value: value, min: min, max: max, step: step, snap: snap, origin: origin, onChange: onChange, onDragStart: onDragStart, onDragEnd: onDragEndProp, snapBehavior: snapBehaviour, disabled: disabled, blurOnDragEnd: blurOnDragEnd, ariaLabel: ariaLabel, ariaLabelledBy: _ariaLabelledBy, ariaDescribedBy: ariaDescribedBy, ariaValueText: ariaValueText, onChangeComplete: onChangeComplete, trackFill: trackFill }) }), !label && numberInput] }));
        } }));
});
export class SliderNumberInput extends React.Component {
    constructor(props) {
        super(props);
        this.inlineInputRef = React.createRef();
        this.onChange = (_numberValue, stringValue) => {
            if (!this.props.disabled) {
                this.setState({
                    inputStringValue: stringValue,
                });
            }
        };
        this.onChangeComplete = (value) => {
            var _a, _b;
            if (value == null || isNaN(value)) {
                this.setState({
                    inputStringValue: this.props.value == null ? '' : this.props.value.toString(),
                });
                return;
            }
            this.setState({
                inputStringValue: value == null ? '' : value.toString(),
            });
            (_b = (_a = this.props).onChangeComplete) === null || _b === void 0 ? void 0 : _b.call(_a, value);
        };
        this.onFocus = () => {
            window.setTimeout(() => {
                this.inlineInputRef.current && this.inlineInputRef.current.select();
            }, 0);
        };
        this.onBlur = () => {
            const selection = window.getSelection();
            selection && selection.removeAllRanges();
        };
        this.state = {
            inputStringValue: props.value == null ? '' : props.value.toString(),
            previousValueProp: props.value,
        };
    }
    static getDerivedStateFromProps(props, state) {
        if (props.value !== state.previousValueProp) {
            return {
                inputStringValue: props.value == null ? '' : props.value.toString(),
                previousValueProp: props.value,
            };
        }
        return state;
    }
    render() {
        const { className, inputClassName, min, max, step, disabled, NumericInput = NumberInput, ariaLabel, ariaLabelledBy, autoFocus, ariaDescribedBy, } = this.props;
        return (_jsx(NumericInput, { className: className, inputClassName: inputClassName, value: this.state.inputStringValue, disabled: disabled, placeholder: "--", ariaLabel: ariaLabel, ariaLabelledBy: ariaLabelledBy, ariaDescribedBy: ariaDescribedBy, onChange: this.onChange, onChangeComplete: this.onChangeComplete, onBlur: this.onBlur, onFocus: this.onFocus, blurOnEnterKeyDown: true, min: min, max: max, step: step, ref: this.inlineInputRef, autoFocus: autoFocus }));
    }
}
