import classNames from 'classnames';
import * as React from 'react';
import { commonPropsToDOMProps } from '../../box/types';
import { getSpaceValue } from '../../metrics/metrics';
import { generateStyle } from '../../responsive/responsive';
import styles, { customProperties } from './inline.css';
const spacingPropertyMap = {
    default: customProperties.spacing,
    smallUp: customProperties.smallUpSpacing,
    mediumUp: customProperties.mediumUpSpacing,
    largeUp: customProperties.largeUpSpacing,
};
const alignPropertyMap = {
    default: customProperties.align,
    smallUp: customProperties.smallUpAlign,
    mediumUp: customProperties.mediumUpAlign,
    largeUp: customProperties.largeUpAlign,
};
const alignYPropertyMap = {
    default: customProperties.alignY,
    smallUp: customProperties.smallUpAlignY,
    mediumUp: customProperties.mediumUpAlignY,
    largeUp: customProperties.largeUpAlignY,
};
const getAlignValue = (align) => (align !== 'spaceBetween' ? align : 'space-between');
const getAlignYValue = (alignY) => alignY === 'start' || alignY === 'end' ? `flex-${alignY}` : alignY;
export const Inline = React.forwardRef(({ children, spacing, align, alignY, collapseBelow, collapsed, tagName = 'div', ...rest }, ref) => {
    const isList = tagName === 'ul' || tagName === 'ol';
    const childTagName = isList ? 'li' : 'span';
    const isPhrasingContent = tagName === 'span';
    const containerTagName = isPhrasingContent ? 'span' : 'div';
    return React.createElement(containerTagName, {
        className: styles.container,
        ref,
    }, React.createElement(tagName, {
        className: classNames(styles.inline, collapseBelow && collapseBelowClassNames[collapseBelow], collapsed && styles.collapsed),
        children: wrapOrCloneChildren(children, childTagName),
        style: {
            ...(spacing && generateStyle(spacingPropertyMap, spacing, getSpaceValue)),
            ...(align && generateStyle(alignPropertyMap, align, getAlignValue)),
            ...(alignY && generateStyle(alignYPropertyMap, alignY, getAlignYValue)),
        },
        ...commonPropsToDOMProps(rest),
    }));
});
Inline.displayName = 'Inline';
function wrapOrCloneChildren(children, tagName) {
    return React.Children.map(flattenChildren(children), child => {
        if (!child) {
            return null;
        }
        if (tagName === 'li'
            && React.isValidElement(child)
            && child.type === 'li') {
            return React.cloneElement(child, {
                className: classNames(child.props.className, styles.element),
            });
        }
        return React.createElement(tagName, {
            className: styles.element,
        }, child);
    });
}
function isFragment(node) {
    return React.isValidElement(node) && node.type === React.Fragment;
}
function flattenChildren(children, depth = 0, keys = []) {
    return React.Children.toArray(children).reduce((acc, node, nodeIndex) => {
        if (isFragment(node)) {
            acc.push(...flattenChildren(node.props.children, depth + 1, keys.concat(node.key || nodeIndex)));
        }
        else {
            if (React.isValidElement(node)) {
                acc.push(React.cloneElement(node, {
                    key: keys.concat(String(node.key)).join('.'),
                }));
            }
            else if (typeof node === 'string' || typeof node === 'number') {
                acc.push(node);
            }
        }
        return acc;
    }, []);
}
const collapseBelowClassNames = {
    small: styles.collapseBelowSmall,
    medium: styles.collapseBelowMedium,
    large: styles.collapseBelowLarge,
};
