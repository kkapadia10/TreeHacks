"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AudioContextProvider = exports.AudioContext = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const React = require("react");
exports.AudioContext = React.createContext(undefined);
/**
 * 
 *  A wrapper that tracks the currently playing audio. By using this, we can ensure only 1 audio track is playing at a time.
 *  It also manages the situation where a user tries to play an audio file while another is playing.
 *  This component must appear once — and only once — at the root of an app, as the `AudioCard` component depends on it.
 */
const AudioContextProvider = (props) => {
    const [playingAudio, setPlayingAudio] = React.useState();
    const previousAudio = React.useRef(playingAudio);
    React.useEffect(() => {
        if (previousAudio.current && previousAudio.current !== playingAudio) {
            previousAudio.current.pause();
            previousAudio.current.onended = null;
        }
        previousAudio.current = playingAudio;
    });
    const stop = React.useCallback(() => {
        if (playingAudio) {
            playingAudio.pause();
            playingAudio.onended = null;
        }
        setPlayingAudio(undefined);
    }, [playingAudio]);
    const play = React.useCallback((audio) => {
        audio.currentTime = 0;
        audio.play().catch(error => {
            audio.play();
        });
        audio.onended = stop;
        setPlayingAudio(audio);
    }, [stop]);
    const value = React.useMemo(() => ({ playingAudio, stop, play }), [playingAudio, stop, play]);
    return (0, jsx_runtime_1.jsx)(exports.AudioContext.Provider, { ...props, value: value });
};
exports.AudioContextProvider = AudioContextProvider;
