"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AudioCover = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const classnames_1 = require("classnames");
const React = require("react");
const button_1 = require('../../../../../../../base/button/button');
const card_1 = require('../../../../../../../base/card/card');
const icons_1 = require("../../../../icons/icons");
const audio_messages_1 = require("../audio.messages");
const audio_context_1 = require("../audio_context");
const audio_cover_css_1 = require("./audio_cover.css");
function AudioCover({ url, thumbnailUrl }) {
    const audioContext = React.useContext(audio_context_1.AudioContext);
    if (audioContext == null) {
        throw new Error('AudioCover must be used under the AudioContextProvider');
    }
    const audio = React.useRef();
    const [duration, setDuration] = React.useState(0);
    const [currentTime, setCurrentTime] = React.useState(0);
    const [canPlay, setCanPlay] = React.useState(true);
    const [isHovering, setIsHovering] = React.useState(false);
    const isPlaying = audio.current && audio.current === audioContext.playingAudio;
    React.useEffect(() => {
        if (isPlaying) {
            audioContext.stop();
        }
        audio.current = new Audio(url);
        setCanPlay(true);
        audio.current.onerror = () => {
            var _a;
            if (((_a = audio.current) === null || _a === void 0 ? void 0 : _a.src) === url) {
                setDuration(0);
                setCanPlay(false);
                setCurrentTime(0);
            }
        };
        audio.current.onloadedmetadata = () => {
            if (duration === 0 && audio.current && audio.current.src.includes(url)) {
                setDuration(audio.current.duration);
            }
        };
        audio.current.ontimeupdate = () => {
            if (audio.current && audio.current.src.includes(url)) {
                setCurrentTime(audio.current.currentTime);
            }
        };
    }, [url]);
    const playAudio = () => {
        if (!audio.current || !canPlay) {
            return;
        }
        audioContext.play(audio.current);
    };
    const toggleAudio = (event) => {
        event.stopPropagation();
        isPlaying ? audioContext.stop() : playAudio();
    };
    return ((0, jsx_runtime_1.jsxs)(button_1.BasicButton, { ariaLabel: audio_messages_1.AudioCardMessages.playPreview(), className: (0, classnames_1.default)(audio_cover_css_1.default.audioCover, {
            [audio_cover_css_1.default.audioCoverPlaying]: isPlaying,
        }), onClick: toggleAudio, onMouseEnter: () => setIsHovering(true), onMouseLeave: () => setIsHovering(false), noChildWrapper: true, children: [thumbnailUrl && ((0, jsx_runtime_1.jsx)(card_1.CardImageThumbnail, { alt: "", url: thumbnailUrl, className: (0, classnames_1.default)({
                    [audio_cover_css_1.default.audioImagePlaying]: isPlaying,
                }) })), isPlaying && duration > 0 && (0, jsx_runtime_1.jsx)(PlayingCircle, { playedPercentage: currentTime / duration }), (0, jsx_runtime_1.jsx)("span", { className: audio_cover_css_1.default.audioIcon, children: (0, jsx_runtime_1.jsx)(AudioIcon, { canPlay: canPlay, isPlaying: Boolean(isPlaying), hasCoverArt: Boolean(thumbnailUrl), isHovering: isHovering }) })] }));
}
exports.AudioCover = AudioCover;
const AudioIcon = ({ canPlay, isPlaying, isHovering, hasCoverArt, }) => {
    if (!canPlay) {
        return (0, jsx_runtime_1.jsx)(icons_1.AlertTriangleIcon, {});
    }
    if (isPlaying) {
        return (0, jsx_runtime_1.jsx)(icons_1.PauseIcon, {});
    }
    if (isHovering) {
        return (0, jsx_runtime_1.jsx)(icons_1.PlayFilledIcon, {});
    }
    if (!hasCoverArt) {
        return (0, jsx_runtime_1.jsx)(icons_1.MusicIcon, {});
    }
    return null;
};
const PlayingCircle = ({ playedPercentage }) => {
    const strokeWidth = parseInt(audio_cover_css_1.default.progressStrokeWidth, 10) || 0;
    const size = 56;
    const radius = (size - strokeWidth) / 2;
    const perimeter = 2 * Math.PI * radius;
    const dashSize = perimeter * playedPercentage;
    return ((0, jsx_runtime_1.jsx)("svg", { viewBox: `0 0 ${size} ${size}`, className: audio_cover_css_1.default.playingCircle, children: (0, jsx_runtime_1.jsx)("circle", { className: audio_cover_css_1.default.animatedCircle, cx: size / 2, cy: size / 2, r: radius, strokeDasharray: `${dashSize},${perimeter}` }) }));
};
