"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RadioGroup = void 0;
const react_1 = require("react");
const jsx_runtime_1 = require("react/jsx-runtime");
const React = require("react");
const controllable_value_1 = require('../../controllable_value/controllable_value');
const button_radio_group_1 = require("./internal/button_radio_group");
const radio_item_1 = require("./internal/radio_item");
const radio_group_css_1 = require("./radio_group.css");
function RadioGroup(props) {
    const { value: valueProp, defaultValue: defaultValueProp, options, onChange: onChangeProp, disabled, id, ariaLabel, ariaLabelledBy, ariaDescribedBy, itemsPerRow, className, name, variant = 'default', focusRef, onFocus, onBlur, } = props;
    const radioGroupRef = React.useRef(null);
    const [value, setValue] = (0, controllable_value_1.useControllableValue)({
        value: valueProp,
        defaultValue: defaultValueProp,
    });
    const onChange = React.useCallback((value, e) => {
        setValue(value);
        onChangeProp === null || onChangeProp === void 0 ? void 0 : onChangeProp(value, e);
    }, [onChangeProp, setValue]);
    const onItemFocus = React.useCallback((e) => {
        var _a;
        const previouslyFocussedElement = e.relatedTarget;
        if (previouslyFocussedElement
            && ((_a = radioGroupRef === null || radioGroupRef === void 0 ? void 0 : radioGroupRef.current) === null || _a === void 0 ? void 0 : _a.contains(previouslyFocussedElement))) {
            return;
        }
        onFocus === null || onFocus === void 0 ? void 0 : onFocus(e);
    }, [onFocus]);
    const onItemBlur = React.useCallback((e) => {
        var _a;
        const nextElementToBeFocussed = e.relatedTarget;
        if (nextElementToBeFocussed && ((_a = radioGroupRef === null || radioGroupRef === void 0 ? void 0 : radioGroupRef.current) === null || _a === void 0 ? void 0 : _a.contains(nextElementToBeFocussed))) {
            return;
        }
        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
    }, [onBlur]);
    if (variant === 'button') {
        return ((0, jsx_runtime_1.jsx)(button_radio_group_1.ButtonRadioGroup, { options: options, value: value, onChange: onChange, className: className, disabled: disabled, id: id, ariaLabel: ariaLabel, ariaLabelledBy: ariaLabelledBy, ariaDescribedBy: ariaDescribedBy, itemsPerRow: itemsPerRow, ref: radioGroupRef, focusRef: focusRef, onFocus: onFocus && onItemFocus, onBlur: onBlur && onItemBlur }));
    }
    const radioGroup = ((0, jsx_runtime_1.jsx)("div", { role: "radiogroup", id: id, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy, ref: radioGroupRef, className: radio_group_css_1.default.radioGroup, children: options.map((option, index) => {
            var _a;
            const hasFocusRef = value != null ? option.value === value : index === 0;
            return ((0, react_1.createElement)(radio_item_1.RadioItem, { ...option, disabled: (_a = option.disabled) !== null && _a !== void 0 ? _a : disabled, checked: option.value === value, key: index, onChange: onChange, name: name, focusRef: hasFocusRef ? focusRef : undefined, onFocus: onFocus && onItemFocus, onBlur: onBlur && onItemBlur }));
        }) }));
    if (className) {
        return (0, jsx_runtime_1.jsx)("div", { className: className, children: radioGroup });
    }
    return radioGroup;
}
exports.RadioGroup = RadioGroup;
