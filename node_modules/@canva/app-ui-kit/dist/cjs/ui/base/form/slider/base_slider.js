"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseSlider = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const compose_react_refs_1 = require("@seznam/compose-react-refs");
const classnames_1 = require("classnames");
const mobx_react_1 = require("mobx-react");
const React = require("react");
const react_measure_1 = require("react-measure");
const bar_snap_behavior_1 = require("./bar_snap_behavior");
const base_slider_css_1 = require("./base_slider.css");
const slider_css_1 = require("./slider.css");
class BaseSlider extends React.PureComponent {
    constructor(props) {
        super(props);
        this.inputRef = React.createRef();
        this.snapBehavior = this.props.snapBehavior || new bar_snap_behavior_1.NeverSnap();
        this.isDragging = false;
        this.keyPressed = false;
        this.onDragStart = (value) => {
            var _a, _b;
            this.dragStartValue = this.clamp(value);
            this.isDragging = true;
            this.setState({ active: true });
            (_b = (_a = this.props).onDragStart) === null || _b === void 0 ? void 0 : _b.call(_a);
        };
        this.onDragEnd = (newValue) => {
            var _a, _b, _c, _d, _e;
            if (!this.isDragging) {
                return;
            }
            this.isDragging = false;
            this.setState({ active: false });
            this.props.blurOnDragEnd && ((_a = this.inputRef.current) === null || _a === void 0 ? void 0 : _a.blur());
            newValue != null && ((_c = (_b = this.props).onChangeComplete) === null || _c === void 0 ? void 0 : _c.call(_b, this.dragStartValue, newValue));
            (_e = (_d = this.props).onDragEnd) === null || _e === void 0 ? void 0 : _e.call(_d);
        };
        this.onMouseUp = (event) => {
            const target = event.target;
            target.removeEventListener('mouseup', this.onMouseUp);
            const value = this.clamp(parseFloat(target.value));
            this.onDragEnd(value);
        };
        this.onMouseDown = (event) => {
            const target = event.target;
            target.addEventListener('mouseup', this.onMouseUp, { once: true });
            const value = this.clamp(parseFloat(target.value));
            this.onDragStart(value);
        };
        this.onTouchStart = (event) => {
            if (event.touches.length > 1) {
                return;
            }
            const target = event.target;
            const value = this.clamp(parseFloat(target.value));
            this.onDragStart(value);
        };
        this.onTouchEnd = (event) => {
            if (event.touches.length > 0) {
                return;
            }
            const target = event.target;
            const value = this.clamp(parseFloat(target.value));
            this.onDragEnd(value);
        };
        this.onResize = (contentRect) => {
            if (contentRect.entry) {
                this.setState({ width: contentRect.entry.width });
            }
        };
        this.onBarResize = (contentRect) => {
            var _a, _b;
            if (contentRect.offset) {
                (_b = (_a = this.props).onBarResize) === null || _b === void 0 ? void 0 : _b.call(_a, { width: contentRect.offset.width, start: contentRect.offset.left });
            }
        };
        this.onKeyDown = () => {
            this.keyPressed = true;
            this.snapBehavior.onKeyDown();
        };
        this.onKeyUp = () => {
            this.keyPressed = false;
            this.snapBehavior.onKeyUp();
        };
        this.onFocus = () => this.setState({ focused: true });
        this.onBlur = () => this.setState({ focused: false });
        this.onMouseEnter = () => this.setState({ hovering: true });
        this.onMouseLeave = () => this.setState({ hovering: false });
        this.onChange = (event) => {
            var _a, _b;
            const newValue = this.clamp(parseFloat(event.target.value));
            const range = this.props.max - this.props.min;
            const pxPerUnit = this.state.width / range;
            this.snapBehavior.onChange(this.props, newValue, pxPerUnit);
            if (this.keyPressed) {
                (_b = (_a = this.props).onChangeComplete) === null || _b === void 0 ? void 0 : _b.call(_a, this.props.value, newValue);
            }
        };
        this.state = { active: false, focused: false, hovering: false, width: 0 };
        this.dragStartValue = this.clamp(props.value);
    }
    componentWillUnmount() {
        this.isDragging && this.onDragEnd();
    }
    render() {
        const { id, min, max, step, snap, value, disabled, ariaLabel, ariaLabelledBy, ariaDescribedBy, ariaValueText, trackFill, Track = DefaultTrack, Knob = DefaultKnob, } = this.props;
        return ((0, jsx_runtime_1.jsxs)("div", { className: base_slider_css_1.default.root, children: [(0, jsx_runtime_1.jsx)(react_measure_1.default, { onResize: this.onResize, children: ({ measureRef }) => ((0, jsx_runtime_1.jsx)("input", { id: id, className: (0, classnames_1.default)(base_slider_css_1.default.hiddenSlider, {
                            [base_slider_css_1.default.disabled]: disabled,
                        }), ref: (0, compose_react_refs_1.default)(measureRef, this.inputRef), type: "range", onChange: this.onChange, onKeyDown: this.onKeyDown, onKeyUp: this.onKeyUp, onFocus: this.onFocus, onBlur: this.onBlur, onMouseEnter: this.onMouseEnter, onMouseLeave: this.onMouseLeave, onTouchStart: this.onTouchStart, onTouchEnd: this.onTouchEnd, onMouseDown: this.onMouseDown, min: min, max: max, step: step, value: value, disabled: disabled, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy, "aria-valuetext": ariaValueText })) }), (0, jsx_runtime_1.jsx)(react_measure_1.default, { offset: true, onResize: this.onBarResize, children: ({ measureRef }) => ((0, jsx_runtime_1.jsxs)("div", { className: base_slider_css_1.default.styledBarRoot, ref: measureRef, children: [(0, jsx_runtime_1.jsx)(Track, { trackFill: trackFill, min: min, max: max, snap: snap }), (0, jsx_runtime_1.jsx)("div", { className: base_slider_css_1.default.knobPositioner, style: this.knobPositionerStyle, children: (0, jsx_runtime_1.jsx)(Knob, { ...this.state, value: value, disabled: disabled, trackFill: trackFill }) })] })) })] }));
    }
    valueAsPercent(value) {
        const range = this.props.max - this.props.min;
        const valueFromMin = this.clamp(value) - this.props.min;
        const percent = (valueFromMin / range) * 100;
        return percent > 99.5 ? 100 : percent;
    }
    normalizeOrigin(origin) {
        const { min, max } = this.props;
        if (origin < min) {
            return min;
        }
        if (origin > max) {
            return max;
        }
        return origin;
    }
    get knobPositionerStyle() {
        const { min, max, snap, value } = this.props;
        const finalValue = value == null ? min + (max - min) / 2 : value;
        const startingPoint = this.props.origin != null ? this.normalizeOrigin(this.props.origin) : snap;
        const valueAsPercent = this.valueAsPercent(finalValue);
        const snapAsPercent = startingPoint != null ? ((startingPoint - min) / (max - min)) * 100 : undefined;
        if (snapAsPercent == null) {
            return { width: `${valueAsPercent}%` };
        }
        if (valueAsPercent >= snapAsPercent) {
            return {
                width: `${valueAsPercent - snapAsPercent}%`,
                [base_slider_css_1.customProperties.knobPositionerMargin]: `${snapAsPercent}%`,
            };
        }
        return {
            width: `${snapAsPercent - valueAsPercent}%`,
            [base_slider_css_1.customProperties.knobPositionerMargin]: `${valueAsPercent}%`,
            transform: `scaleX(-1)`,
        };
    }
    clamp(value) {
        return Math.min(Math.max(this.props.min, value), this.props.max);
    }
}
exports.BaseSlider = BaseSlider;
const DefaultTrack = (0, mobx_react_1.observer)(({ min, max, snap, trackFill }) => {
    const customStyles = trackFill
        ? { background: trackFill }
        : undefined;
    const markerBufferWidth = snap != null
        && `calc(${((snap - min) / (max - min)) * 100}% - 0.5 * ${slider_css_1.default.zeroMarkerSize})`;
    return ((0, jsx_runtime_1.jsx)("div", { className: slider_css_1.default.track, style: customStyles, children: markerBufferWidth && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)("div", { className: slider_css_1.default.markerBuffer, style: { width: markerBufferWidth } }), (0, jsx_runtime_1.jsx)("div", { className: slider_css_1.default.marker })] })) }));
});
const DefaultKnob = ({ active, hovering, focused, trackFill, disabled, value }) => {
    const progressIndicatorClass = (0, classnames_1.default)(slider_css_1.default.progressIndicator, {
        [slider_css_1.default.transparentProgressIndicator]: trackFill !== undefined,
        [slider_css_1.default.noValue]: value == null,
        [slider_css_1.default.disabled]: disabled,
    });
    return ((0, jsx_runtime_1.jsx)("div", { className: progressIndicatorClass, children: (0, jsx_runtime_1.jsx)("div", { className: (0, classnames_1.default)(slider_css_1.default.knob, {
                [slider_css_1.default.active]: !disabled && active,
                [slider_css_1.default.focused]: !disabled && focused,
                [slider_css_1.default.hovering]: !disabled && hovering,
                [slider_css_1.default.disabled]: disabled,
            }) }) }));
};
