"use strict";

const makeObservable = require('../../../../base/make_observable/make_observable').makeObservable;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BaseMultiSelect = exports.BaseMultiSelectStore = void 0;
const tslib_1 = require("tslib");
const jsx_runtime_1 = require("react/jsx-runtime");
const exists_1 = require('../../../../base/exists');
const mobx = require("mobx");
const React = require("react");
const base_select_1 = require("./base_select");
const base_select_messages_1 = require("./base_select.messages");
const base_select_presenter_1 = require("./base_select_presenter");
const base_select_util_1 = require("./base_select_util");
const stateless_base_select_1 = require("./stateless_base_select");
const selectAllValue = Symbol();
const selectAllOption = {
  value: selectAllValue,
  label: base_select_messages_1.BaseSelectMessages.selectAll()
};
class BaseMultiSelectStore extends base_select_presenter_1.BaseSelectStore {
  static _makeObservable(instance) {
    makeObservable(instance, {
      value: mobx.observable.ref
    });
  }
  constructor(...args) {
    super(...args);
    BaseMultiSelectStore._makeObservable(this);
  }
}
exports.BaseMultiSelectStore = BaseMultiSelectStore;
class BaseMultiSelect extends React.Component {
  constructor() {
    var _a, _b;
    super(...arguments);
    this.store = (_a = this.props.store) !== null && _a !== void 0 ? _a : new BaseMultiSelectStore();
    this.presenter = (_b = this.props.presenter) !== null && _b !== void 0 ? _b : new base_select_presenter_1.BaseSelectPresenter();
    this.isSelected = (option, value) => {
      if (option.value === selectAllValue) {
        return this.isAllSelected();
      }
      const {
        isSelected = base_select_util_1.defaultIsSelected
      } = this.props;
      return isSelected(option, value);
    };
    this.onSelection = option => {
      var _a, _b, _c, _d;
      if (option.value === selectAllValue) {
        return this.onSelectAll();
      }
      if (option.value == null) {
        return;
      }
      const {
        isSelected = base_select_util_1.defaultIsSelected,
        areEqual = base_select_util_1.defaultAreEqual
      } = this.props;
      const value = (_b = (_a = this.value) === null || _a === void 0 ? void 0 : _a.slice()) !== null && _b !== void 0 ? _b : [];
      const newValue = isSelected(option, value) ? value.filter(v => !areEqual(v, option.value)) : value.concat(option.value);
      if (this.props.maxSelectedOptions && this.isAllSelected() && newValue.length > value.length) {
        return;
      }
      this.presenter.setValue(this.store, newValue);
      (_d = (_c = this.props).onChange) === null || _d === void 0 ? void 0 : _d.call(_c, newValue);
    };
    this.onSelectAll = () => {
      var _a, _b;
      let newValue = this.isAllSelected() ? [] : this.getAvailableOptions().map(option => option.value).filter(exists_1.exists);
      const disabledSelectedOptions = this.getDisabledOptions().map(option => this.isSelected(option, this.value) ? option.value : undefined).filter(exists_1.exists);
      if (this.props.maxSelectedOptions) {
        newValue = newValue.slice(0, this.props.maxSelectedOptions - disabledSelectedOptions.length);
      }
      newValue = newValue.concat(disabledSelectedOptions);
      this.presenter.setValue(this.store, newValue);
      (_b = (_a = this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, newValue);
    };
    this.Trigger = React.memo(props => {
      const {
        Trigger = stateless_base_select_1.BaseSelectTrigger,
        options
      } = this.props;
      return (0, jsx_runtime_1.jsx)(Trigger, {
        ...props,
        options: options
      });
    });
    this.Item = React.memo(props => {
      return (0, jsx_runtime_1.jsx)(stateless_base_select_1.BaseSelectItem, {
        ...props,
        multiSelectable: true,
        children: props.option.value === selectAllValue ? props.option.label : props.getLabel(props.option)
      });
    });
  }
  get value() {
    var _a;
    return (_a = this.props.value) !== null && _a !== void 0 ? _a : this.store.value;
  }
  isAllSelected() {
    if (!this.value) {
      return false;
    }
    if (this.props.maxSelectedOptions && this.value.length >= this.props.maxSelectedOptions) {
      return true;
    }
    if (this.value.length === (0, base_select_util_1.flattenOptions)(this.props.options).length) {
      return true;
    }
    let valueWithoutDisabledOptions = this.value;
    this.getDisabledOptions().forEach(option => {
      valueWithoutDisabledOptions = valueWithoutDisabledOptions.filter(value => value !== option.value);
    });
    return Array.isArray(valueWithoutDisabledOptions) && valueWithoutDisabledOptions.length === this.getAvailableOptions().length;
  }
  getAvailableOptions() {
    return (0, base_select_util_1.flattenOptions)(this.props.options).filter(option => !option.disabled);
  }
  getDisabledOptions() {
    return (0, base_select_util_1.flattenOptions)(this.props.options).filter(option => option.disabled);
  }
  render() {
    const {
      showSelectAll,
      options,
      maxSelectedOptions
    } = this.props;
    const finalShowSelectAll = showSelectAll && (!maxSelectedOptions || maxSelectedOptions >= options.length);
    return (0, jsx_runtime_1.jsx)(base_select_1.BaseSelect, {
      store: this.store,
      presenter: this.presenter,
      Trigger: this.Trigger,
      Item: this.Item,
      onSelection: this.onSelection,
      closeOnSelection: false,
      ...this.props,
      isSelected: this.isSelected,
      options: finalShowSelectAll ? [selectAllOption, ...options] : options
    });
  }
}
exports.BaseMultiSelect = BaseMultiSelect;