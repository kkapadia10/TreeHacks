"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultilineInput = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const compose_react_refs_1 = require("@seznam/compose-react-refs");
const classnames_1 = require("classnames");
const mobx_react_1 = require("mobx-react");
const React = require("react");
const resize_observer_polyfill_1 = require("resize-observer-polyfill");
const controllable_value_1 = require('../../controllable_value/controllable_value');
const device_capabilities_1 = require('../../device_capabilities/device_capabilities');
const base_input_1 = require("./base_input");
const base_input_css_1 = require("./base_input.css");
const input_internal_1 = require("./internal/input_internal");
const multiline_input_css_1 = require("./multiline_input.css");
const DEFAULT_BUFFER_ROWS = 1;
const DEFAULT_MAX_ROWS = Number.POSITIVE_INFINITY;
function getVerticalPadding(domElement) {
    const window = domElement.ownerDocument.defaultView;
    const styles = window === null || window === void 0 ? void 0 : window.getComputedStyle(domElement);
    return parseInt((styles === null || styles === void 0 ? void 0 : styles.paddingBottom) || '0', 10) + parseInt((styles === null || styles === void 0 ? void 0 : styles.paddingTop) || '0', 10);
}
function useAutoGrow(
    { autoGrow, bufferRows = DEFAULT_BUFFER_ROWS, maxRows = DEFAULT_MAX_ROWS, minRows = 1, value, }
) {
    const textAreaRef = React.useRef(null);
    const remeasure = React.useCallback(() => {
        const domElement = textAreaRef.current;
        if (!domElement) {
            return;
        }
        if (!autoGrow) {
            return;
        }
        domElement.style.height = '100%';
        domElement.rows = 1;
        const rowHeight = domElement.clientHeight - getVerticalPadding(domElement);
        const contentRows = rowHeight === 0
            ? 0
            : Math.round((domElement.scrollHeight - getVerticalPadding(domElement)) / rowHeight);
        domElement.rows = Math.max(minRows + bufferRows, contentRows + bufferRows);
        domElement.rows = Math.min(maxRows, domElement.rows);
    }, [autoGrow, bufferRows, maxRows, minRows]);
    React.useLayoutEffect(remeasure, [remeasure, value]);
    const stableRemeasure = React.useRef(remeasure);
    const observerRef = React.useRef(null);
    const ref = React.useCallback((element) => {
        if (observerRef.current == null) {
            observerRef.current = new resize_observer_polyfill_1.default(() => stableRemeasure.current());
        }
        if (textAreaRef.current != null) {
            observerRef.current.unobserve(textAreaRef.current);
        }
        textAreaRef.current = element;
        if (textAreaRef.current != null) {
            observerRef.current.observe(textAreaRef.current);
        }
    }, []);
    React.useEffect(() => {
        return () => { var _a; return (_a = observerRef.current) === null || _a === void 0 ? void 0 : _a.disconnect(); };
    }, []);
    return ref;
}
exports.MultilineInput = (0, mobx_react_1.observer)(React.forwardRef(InternalMultilineInput));
exports.MultilineInput.displayName = 'MultilineInput';
function InternalMultilineInput(props_, forwardedRef) {
    const { props, setPropOverrides } = (0, input_internal_1.usePropOverrides)(props_);
    const { onChange, onFocus, onBlur, onChangeComplete, onKeyDown, dir = 'auto' } = props;
    const { ref: inputRef, onMouseDown: onWrapperMouseDown } = (0, base_input_1.useOnWrapperMouseDown)();
    const { isFocused, isKeyboardMode, setFocused } = (0, base_input_1.useFocusState)();
    const [value, setValue] = (0, controllable_value_1.useControllableValue)({ value: props.value });
    const autoGrowRef = useAutoGrow({ ...props, value });
    const controls = (0, input_internal_1.useCreateInputControls)({
        focus: () => { var _a; return (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus(); },
        setDisabled: disabled => setPropOverrides({ disabled }),
        setValue: (value) => {
            setValue(value);
            onChange === null || onChange === void 0 ? void 0 : onChange(value);
        },
    });
    const _onChange = React.useCallback((e) => {
        setValue(e.target.value);
        onChange === null || onChange === void 0 ? void 0 : onChange(e.target.value, e);
    }, [onChange, setValue]);
    const _onFocus = React.useCallback((e) => {
        onFocus === null || onFocus === void 0 ? void 0 : onFocus(e);
        setFocused(true);
    }, [onFocus, setFocused]);
    const _onBlur = React.useCallback((e) => {
        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
        onChangeComplete === null || onChangeComplete === void 0 ? void 0 : onChangeComplete(e.target.value);
        setFocused(false);
    }, [onBlur, onChangeComplete, setFocused]);
    const _onKeyDown = React.useCallback((e) => {
        if (e.keyCode === 229) {
            e.stopPropagation();
            return;
        }
        onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(e);
    }, [onKeyDown]);
    const { autoComplete = 'browser_default' } = props;
    const autoCompleteValue = autoComplete === 'browser_default' ? undefined : autoComplete === 'on' ? 'on' : 'no';
    const wrapperClassName = (0, classnames_1.default)(base_input_css_1.default.wrapper, multiline_input_css_1.default.multilineWrapper, {
        [base_input_css_1.default.hoverSupported]: (0, device_capabilities_1.canHover)(),
        [base_input_css_1.default.focusOutline]: isFocused && isKeyboardMode,
        [base_input_css_1.default.borderless]: props.borderless,
        [multiline_input_css_1.default.resize]: props.resize,
    }, 
    (props.disabled && base_input_css_1.default.disabled)
        || (isFocused && base_input_css_1.default.active) || (props.error && base_input_css_1.default.error), props.className);
    const inputClassName = (0, classnames_1.default)(base_input_css_1.default.textField, multiline_input_css_1.default.multilineTextField, props.inputClassName);
    return ((0, jsx_runtime_1.jsx)(
        "div",
        { className: wrapperClassName, onMouseDown: onWrapperMouseDown, children: (0, jsx_runtime_1.jsxs)(input_internal_1.BaseInputContextProvider, { controls: controls, value: value !== null && value !== void 0 ? value : '', children: [(0, jsx_runtime_1.jsx)("textarea", { className: inputClassName, value: value, onChange: _onChange, onFocus: _onFocus, onBlur: _onBlur, onKeyPress: props.onKeyPress, onKeyDown: _onKeyDown, onKeyUp: props.onKeyUp, ref: (0, compose_react_refs_1.default)(inputRef, autoGrowRef, forwardedRef), dir: dir, autoComplete: autoCompleteValue, disabled: props.disabled, placeholder: props.placeholder, maxLength: props.maxLength, lang: props.lang, rows: props.minRows, id: props.id, "aria-label": props.ariaLabel, "aria-labelledby": props.ariaLabelledBy, "aria-describedby": props.ariaDescribedBy, required: props.required, readOnly: props.readOnly }), props.footer] }) }
    ));
}
