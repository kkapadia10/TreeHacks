"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseSelect = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const compose_react_refs_1 = require("@seznam/compose-react-refs");
const mobx_1 = require("mobx");
const mobx_react_1 = require("mobx-react");
const React = require("react");
const access_mode_state_1 = require('../../a11y/access_mode_state/access_mode_state');
const use_keyboard_navigation_1 = require('../../a11y/keyboard_navigation/use_keyboard_navigation');
const base_input_1 = require('../input/base_input');
const use_key_combination_handler_1 = require('../../key_combinations/use_key_combination_handler');
const base_select_presenter_1 = require("./base_select_presenter");
const base_select_util_1 = require("./base_select_util");
const stateless_base_select_1 = require("./stateless_base_select");
exports.BaseSelect = (0, mobx_react_1.observer)(function BaseSelect(props) {
    var _a, _b;
    const [store] = React.useState(() => { var _a; return (_a = props.store) !== null && _a !== void 0 ? _a : new base_select_presenter_1.BaseSelectStore(); });
    const [presenter] = React.useState(() => { var _a; return (_a = props.presenter) !== null && _a !== void 0 ? _a : new base_select_presenter_1.BaseSelectPresenter(); });
    const { query } = store;
    const { Menu = stateless_base_select_1.BaseSelectMenu, open, triggerContainerRef, menuContainerRef, searchable, isSelected = base_select_util_1.defaultIsSelected, onChange, onOpen, onClose, closeOnSelection = true, } = props;
    const value = (_a = props.value) !== null && _a !== void 0 ? _a : store.value;
    const optionGroups = React.useMemo(() => {
        return (0, base_select_util_1.normalizeOptionGroups)(props.options);
    }, [props.options]);
    const isSearchable = !!searchable;
    const filterFn = (typeof searchable === 'object' && searchable.filterFn) || base_select_util_1.defaultFilterFn;
    const options = React.useMemo(() => {
        if (!isSearchable || !query) {
            return props.options;
        }
        return optionGroups
            .map(optionGroup => {
            const filteredOptions = filterFn(query, optionGroup.options, value, isSelected);
            return {
                label: optionGroup.label,
                options: filteredOptions,
            };
        })
            .filter(optionGroup => optionGroup.options.length > 0);
    }, [query, isSearchable, filterFn, optionGroups, props.options, value, isSelected]);
    const flatOptions = React.useMemo(() => {
        return (0, base_select_util_1.flattenOptions)(options);
    }, [options]);
    const defaultOnSelection = React.useCallback((option, e) => {
        if (!isSelected(option, value)) {
            presenter.setValue(store, option.value);
            onChange === null || onChange === void 0 ? void 0 : onChange(option.value, option);
        }
    }, [isSelected, value, presenter, store, onChange]);
    const onSelection = (_b = props.onSelection) !== null && _b !== void 0 ? _b : defaultOnSelection;
    const onItemHover = React.useCallback((option) => {
        var _a;
        (_a = store.keyboardNavigation) === null || _a === void 0 ? void 0 : _a.moveTo(flatOptions.indexOf(option));
    }, [store, flatOptions]);
    const openMenu = React.useCallback(() => {
        if (!store.open) {
            presenter.toggle(store, true);
            onOpen === null || onOpen === void 0 ? void 0 : onOpen();
        }
    }, [store, presenter, onOpen]);
    const closeMenu = React.useCallback(() => {
        if (store.open) {
            presenter.toggle(store, false);
            onClose === null || onClose === void 0 ? void 0 : onClose();
        }
    }, [store, presenter, onClose]);
    const maybeCloseMenu = React.useCallback(() => {
        closeOnSelection && closeMenu();
    }, [closeOnSelection, closeMenu]);
    const toggleMenu = React.useCallback(() => {
        presenter.toggle(store);
        if (store.open) {
            onOpen === null || onOpen === void 0 ? void 0 : onOpen();
        }
        else {
            onClose === null || onClose === void 0 ? void 0 : onClose();
        }
    }, [presenter, store, onOpen, onClose]);
    const onItemClick = React.useCallback((option, e) => {
        !option.disabled && onSelection(option, e);
        maybeCloseMenu();
    }, [onSelection, maybeCloseMenu]);
    const spaceHandler = React.useCallback((e, index) => {
        if (e.target instanceof HTMLInputElement && e.target.value.length > 0) {
            return;
        }
        e.preventDefault();
        const activeOption = flatOptions[index !== null && index !== void 0 ? index : -1];
        if (activeOption === null || activeOption === void 0 ? void 0 : activeOption.disabled) {
            return;
        }
        activeOption && (onSelection === null || onSelection === void 0 ? void 0 : onSelection(activeOption, e));
    }, [onSelection, flatOptions]);
    const enterHandler = React.useCallback((e, index) => {
        e.preventDefault();
        if (e.keyCode === 229) {
            return;
        }
        const activeOption = flatOptions[index !== null && index !== void 0 ? index : -1];
        if (activeOption === null || activeOption === void 0 ? void 0 : activeOption.disabled) {
            return;
        }
        activeOption && onSelection(activeOption, e);
        maybeCloseMenu();
    }, [flatOptions, onSelection, maybeCloseMenu]);
    const keySelectionHandler = React.useCallback((e, index) => {
        if (index === -1) {
            return;
        }
        return e.code === 'Space' ? spaceHandler(e, index) : enterHandler(e, index);
    }, [spaceHandler, enterHandler]);
    const exitHandler = React.useCallback((e) => {
        if (store.open) {
            e.stopPropagation();
            closeMenu();
        }
    }, [store, closeMenu]);
    const onInputChange = typeof searchable === 'object' ? searchable.onInputChange : undefined;
    const onInputChangeRef = React.useRef(onInputChange);
    onInputChangeRef.current = onInputChange;
    const onSearchInputChange = React.useCallback((value) => {
        (0, mobx_1.runInAction)(() => {
            var _a, _b;
            (_a = onInputChangeRef.current) === null || _a === void 0 ? void 0 : _a.call(onInputChangeRef, value);
            store.query = value.trimStart();
            (_b = store.keyboardNavigation) === null || _b === void 0 ? void 0 : _b.moveTo(0);
        });
    }, [store]);
    const searchInputPlaceholder = React.useRef();
    searchInputPlaceholder.current =
        typeof searchable === 'object' ? searchable.inputPlaceholder : undefined;
    const MenuWithSearchInput = React.useMemo(() => (0, mobx_react_1.observer)((props) => {
        return ((0, jsx_runtime_1.jsx)(Menu, { ...props, header: (0, jsx_runtime_1.jsx)(base_input_1.BaseInput, { type: "search", value: store.query, onChange: onSearchInputChange, placeholder: searchInputPlaceholder.current, icon: { type: 'search', align: 'start' }, ariaActiveDescendant: (0, base_select_util_1.deriveIdentifier)(props.id, props.activeIndex) }) }));
    }), [Menu, onSearchInputChange, store]);
    const reactionDeps = React.useRef({ flatOptions, value, isSelected });
    reactionDeps.current.flatOptions = flatOptions;
    reactionDeps.current.value = value;
    reactionDeps.current.isSelected = isSelected;
    React.useEffect(() => {
        return (0, mobx_1.reaction)(() => store.open, open => {
            var _a, _b, _c;
            const { flatOptions, value, isSelected } = reactionDeps.current;
            if (open) {
                const firstSelectedOptionIndex = flatOptions.findIndex(option => isSelected(option, value));
                if (firstSelectedOptionIndex !== -1) {
                    (_a = store.keyboardNavigation) === null || _a === void 0 ? void 0 : _a.moveTo(firstSelectedOptionIndex);
                }
                else if (access_mode_state_1.accessModeState.isKeyboardMode) {
                    (_b = store.keyboardNavigation) === null || _b === void 0 ? void 0 : _b.moveTo(0);
                }
            }
            else {
                (_c = store.keyboardNavigation) === null || _c === void 0 ? void 0 : _c.moveTo();
            }
            store.query = '';
        });
    }, [store]);
    const setKeyboardMode = React.useCallback(() => {
        access_mode_state_1.accessModeState.setAccessMode('keyboard');
    }, []);
    const openWithArrows = React.useCallback((e) => {
        e.preventDefault();
        openMenu();
        setKeyboardMode();
    }, [openMenu, setKeyboardMode]);
    const triggerKeyMap = React.useMemo(() => [['ArrowUp', openWithArrows], ['ArrowDown', openWithArrows]], [openWithArrows]);
    return ((0, jsx_runtime_1.jsx)(
        use_key_combination_handler_1.WithKeyCombinationHandler,
        { map: triggerKeyMap, handleInputs: true, children: ({ ref: triggerKeysRef }) => ((0, jsx_runtime_1.jsx)(use_keyboard_navigation_1.WithKeyboardNavigation, { size: flatOptions.length, handleInputs: true, onSelect: keySelectionHandler, onExit: exitHandler, onNext: setKeyboardMode, onPrev: setKeyboardMode, onFirst: setKeyboardMode, onLast: setKeyboardMode, children: keyboardNavigation => {
                    store.keyboardNavigation = keyboardNavigation;
                    return ((0, jsx_runtime_1.jsx)(mobx_react_1.Observer, { children: () => ((0, jsx_runtime_1.jsx)(stateless_base_select_1.StatelessBaseSelect, { ...props, value: value, open: open !== null && open !== void 0 ? open : store.open, activeIndex: keyboardNavigation.index > -1 ? keyboardNavigation.index : undefined, onRequestToggle: toggleMenu, onItemClick: onItemClick, onItemHover: onItemHover, focusOnMenu: !!searchable, triggerContainerRef: (0, compose_react_refs_1.default)(searchable ? null : keyboardNavigation.ref, triggerKeysRef, triggerContainerRef), menuContainerRef: (0, compose_react_refs_1.default)(searchable ? keyboardNavigation.ref : null, menuContainerRef), Menu: searchable ? MenuWithSearchInput : Menu, options: options, tooltipLabel: props.tooltipLabel, tooltipPlacement: props.tooltipPlacement })) }));
                } })) }
    ));
});
