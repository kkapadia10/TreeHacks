"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SliderNumberInput = exports.Slider = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const classnames_1 = require("classnames");
const mobx_react_1 = require("mobx-react");
const React = require("react");
const identifier_1 = require('../../a11y/identifier/identifier');
const controllable_value_1 = require('../../controllable_value/controllable_value');
const number_input_1 = require('../input/number_input');
const label_text_1 = require('../label_text/label_text');
const bar_snap_behavior_1 = require("./bar_snap_behavior");
const base_slider_1 = require("./base_slider");
const slider_css_1 = require("./slider.css");
exports.Slider = (0, mobx_react_1.observer)(function Slider({ id, min, max, snap, step, origin, value: valueProp, defaultValue, onDragStart, onDragEnd: onDragEndProp, trackFill, label, labelSize = 'medium', ariaLabelledBy, disabled, autoFocusNumericInput, NumericInput, colorVariant, blurOnDragEnd, ariaLabel, ariaDescribedBy, ariaValueText, onChange: onChangeProp, onChangeComplete, }) {
    const [value, setValue] = (0, controllable_value_1.useControllableValue)({
        value: valueProp,
        defaultValue,
    });
    const [initialValue, setInitialValue] = React.useState(value);
    const snapBehaviour = React.useMemo(() => (snap != null ? new bar_snap_behavior_1.Snap(snap) : undefined), [snap]);
    const onChange = React.useCallback((newValue) => {
        setValue(newValue);
        setInitialValue(newValue);
        onChangeProp === null || onChangeProp === void 0 ? void 0 : onChangeProp(newValue);
    }, [setValue, onChangeProp]);
    const onInputChangeComplete = React.useCallback((newValue) => {
        try {
            onChange(newValue);
            onChangeComplete === null || onChangeComplete === void 0 ? void 0 : onChangeComplete(initialValue, newValue);
        }
        finally {
            setInitialValue(newValue);
        }
    }, [initialValue, setInitialValue, onChange, onChangeComplete]);
    const sliderClassName = (0, classnames_1.default)(slider_css_1.default.container, colorVariant === undefined && slider_css_1.default.default, colorVariant === 'mono' && slider_css_1.default.mono, colorVariant === 'alternate' && slider_css_1.default.alternate, NumericInput === 'none' && slider_css_1.default.noNumberInput, label ? slider_css_1.default.labelledSlider : slider_css_1.default.standardSlider);
    return ((0, jsx_runtime_1.jsx)(identifier_1.WithIdentifiers, { children: labelId => {
            const _ariaLabelledBy = ariaLabelledBy !== null && ariaLabelledBy !== void 0 ? ariaLabelledBy : (label == null ? undefined : labelId);
            const numberInput = ((0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: NumericInput !== 'none' && ((0, jsx_runtime_1.jsx)(SliderNumberInput, { className: slider_css_1.default.numberInputContainer, inputClassName: slider_css_1.default.numberInput, value: value, NumericInput: NumericInput, min: min, max: max, step: step, disabled: disabled, autoFocus: autoFocusNumericInput, onChangeComplete: onInputChangeComplete, ariaLabel: ariaLabel, ariaLabelledBy: _ariaLabelledBy, ariaDescribedBy: ariaDescribedBy })) }));
            return ((0, jsx_runtime_1.jsxs)("div", { className: sliderClassName, children: [label && ((0, jsx_runtime_1.jsx)(label_text_1.Label, { id: labelId, size: labelSize, variant: "regular", children: label })), label && numberInput, (0, jsx_runtime_1.jsx)("div", { className: slider_css_1.default.slider, children: (0, jsx_runtime_1.jsx)(base_slider_1.BaseSlider, { id: id, value: value, min: min, max: max, step: step, snap: snap, origin: origin, onChange: onChange, onDragStart: onDragStart, onDragEnd: onDragEndProp, snapBehavior: snapBehaviour, disabled: disabled, blurOnDragEnd: blurOnDragEnd, ariaLabel: ariaLabel, ariaLabelledBy: _ariaLabelledBy, ariaDescribedBy: ariaDescribedBy, ariaValueText: ariaValueText, onChangeComplete: onChangeComplete, trackFill: trackFill }) }), !label && numberInput] }));
        } }));
});
class SliderNumberInput extends React.Component {
    constructor(props) {
        super(props);
        this.inlineInputRef = React.createRef();
        this.onChange = (_numberValue, stringValue) => {
            if (!this.props.disabled) {
                this.setState({
                    inputStringValue: stringValue,
                });
            }
        };
        this.onChangeComplete = (value) => {
            var _a, _b;
            if (value == null || isNaN(value)) {
                this.setState({
                    inputStringValue: this.props.value == null ? '' : this.props.value.toString(),
                });
                return;
            }
            this.setState({
                inputStringValue: value == null ? '' : value.toString(),
            });
            (_b = (_a = this.props).onChangeComplete) === null || _b === void 0 ? void 0 : _b.call(_a, value);
        };
        this.onFocus = () => {
            window.setTimeout(() => {
                this.inlineInputRef.current && this.inlineInputRef.current.select();
            }, 0);
        };
        this.onBlur = () => {
            const selection = window.getSelection();
            selection && selection.removeAllRanges();
        };
        this.state = {
            inputStringValue: props.value == null ? '' : props.value.toString(),
            previousValueProp: props.value,
        };
    }
    static getDerivedStateFromProps(props, state) {
        if (props.value !== state.previousValueProp) {
            return {
                inputStringValue: props.value == null ? '' : props.value.toString(),
                previousValueProp: props.value,
            };
        }
        return state;
    }
    render() {
        const { className, inputClassName, min, max, step, disabled, NumericInput = number_input_1.NumberInput, ariaLabel, ariaLabelledBy, autoFocus, ariaDescribedBy, } = this.props;
        return ((0, jsx_runtime_1.jsx)(NumericInput, { className: className, inputClassName: inputClassName, value: this.state.inputStringValue, disabled: disabled, placeholder: "--", ariaLabel: ariaLabel, ariaLabelledBy: ariaLabelledBy, ariaDescribedBy: ariaDescribedBy, onChange: this.onChange, onChangeComplete: this.onChangeComplete, onBlur: this.onBlur, onFocus: this.onFocus, blurOnEnterKeyDown: true, min: min, max: max, step: step, ref: this.inlineInputRef, autoFocus: autoFocus }));
    }
}
exports.SliderNumberInput = SliderNumberInput;
