"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sliceOptionGroups = exports.deriveIdentifier = exports.flattenOptions = exports.isOptionGroup = exports.normalizeOptionGroups = exports.defaultFilterFn = exports.joinLabels = exports.defaultGetLabel = exports.defaultIsSelected = exports.defaultAreEqual = void 0;
const preconditions_1 = require('../../../../base/preconditions');
const defaultAreEqual = (a, b) => {
    return a === b;
};
exports.defaultAreEqual = defaultAreEqual;
const defaultIsSelected = (option, value) => {
    return Array.isArray(value) ? value.includes(option.value) : option.value === value;
};
exports.defaultIsSelected = defaultIsSelected;
const defaultGetLabel = option => {
    return option.label || option.value || '';
};
exports.defaultGetLabel = defaultGetLabel;
const joinLabels = (labels) => {
    return labels.every(label => typeof label === 'string') ? labels.join(', ') : labels;
};
exports.joinLabels = joinLabels;
const normalizeQuery = (value) => value
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '');
function defaultFilterFn(query, options, value, isSelected) {
    const normalizedQuery = normalizeQuery(query);
    if (!normalizedQuery) {
        return options;
    }
    const startMatches = [];
    const otherMatches = [];
    options.forEach(option => {
        preconditions_1.Preconditions.checkArgument(typeof option.label === 'string', 'Provide a custom `filterFn` to work with options without labels');
        const normalizedLabel = normalizeQuery(option.label);
        if (!normalizedLabel.includes(normalizedQuery)) {
            if (isSelected(option, value)) {
                otherMatches.push(option);
            }
            return;
        }
        if (normalizedLabel.startsWith(normalizedQuery)) {
            startMatches.push(option);
        }
        else {
            otherMatches.push(option);
        }
    });
    return startMatches.concat(otherMatches);
}
exports.defaultFilterFn = defaultFilterFn;
function normalizeOptionGroups(options) {
    const optionGroups = [];
    let currentImplicitGroup;
    options.forEach(optionOrGroup => {
        if (optionOrGroup.options != null) {
            currentImplicitGroup = undefined;
            optionGroups.push(optionOrGroup);
        }
        else {
            if (currentImplicitGroup == null) {
                currentImplicitGroup !== null && currentImplicitGroup !== void 0 ? currentImplicitGroup : (currentImplicitGroup = { options: [] });
                optionGroups.push(currentImplicitGroup);
            }
            currentImplicitGroup.options.push(optionOrGroup);
        }
    });
    return optionGroups;
}
exports.normalizeOptionGroups = normalizeOptionGroups;
function isOptionGroup(option) {
    return option.options != null;
}
exports.isOptionGroup = isOptionGroup;
function flattenOptions(options) {
    const result = [];
    options.forEach(option => {
        if (option.options != null) {
            result.push(...option.options);
        }
        else {
            result.push(option);
        }
    });
    return result;
}
exports.flattenOptions = flattenOptions;
function deriveIdentifier(id, subid) {
    return subid == null ? undefined : `${id}--${subid}`;
}
exports.deriveIdentifier = deriveIdentifier;
function sliceOptionGroups(optionGroups, start, end) {
    const slice = [];
    let groupStart = 0;
    for (let groupIndex = 0; groupIndex < optionGroups.length; groupIndex++) {
        const optionGroup = optionGroups[groupIndex];
        const groupLength = optionGroup.options.length;
        const groupEnd = groupStart + groupLength;
        if (groupEnd <= start) {
            groupStart += groupLength;
            continue;
        }
        if (groupStart >= end) {
            break;
        }
        if (groupStart < start && groupEnd <= end) {
            const optionsStart = start - groupStart;
            slice.push({
                label: optionGroup.label,
                options: optionGroup.options.slice(optionsStart),
                originalIndex: groupIndex,
                slice: [optionsStart, groupLength],
            });
            groupStart += groupLength;
            continue;
        }
        if (groupStart >= start && groupEnd <= end) {
            slice.push({
                label: optionGroup.label,
                options: optionGroup.options.slice(),
                originalIndex: groupIndex,
                slice: [0, groupLength],
            });
            groupStart += groupLength;
            continue;
        }
        if (groupStart >= start && groupEnd > end) {
            const optionsEnd = end - groupStart;
            slice.push({
                label: optionGroup.label,
                options: optionGroup.options.slice(0, optionsEnd),
                originalIndex: groupIndex,
                slice: [0, optionsEnd],
            });
            groupStart += groupLength;
            continue;
        }
        if (groupStart < start && groupEnd > end) {
            const optionsStart = start - groupStart;
            const optionsEnd = end - groupStart;
            slice.push({
                label: optionGroup.label,
                options: optionGroup.options.slice(optionsStart, optionsEnd),
                originalIndex: groupIndex,
                slice: [optionsStart, optionsEnd],
            });
            groupStart += groupLength;
            continue;
        }
    }
    return slice;
}
exports.sliceOptionGroups = sliceOptionGroups;
