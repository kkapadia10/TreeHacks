"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Switch = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const classnames_1 = require("classnames");
const React = require("react");
const button_1 = require('../../button/button');
const controllable_value_1 = require('../../controllable_value/controllable_value');
const icon_1 = require('../../icons/tick/icon');
const provider_1 = require('../../provider/provider');
const typography_1 = require('../../typography/typography');
const switch_css_1 = require("./switch.css");
const Switch = (props) => {
    const { id, value: valueProp, defaultValue: defaultValueProp, onChange: onChangeProp, disabled, label, labelWeight = 'regular', description, ariaLabel, ariaLabelledBy, ariaDescribedBy, focusRef, onFocus, onBlur, } = props;
    const [value, setValue] = (0, controllable_value_1.useControllableValue)({
        value: valueProp,
        defaultValue: defaultValueProp !== null && defaultValueProp !== void 0 ? defaultValueProp : false,
    });
    const labelId = React.useId();
    const descriptionId = React.useId();
    const generatedButtonId = React.useId();
    const buttonId = id || generatedButtonId;
    const switchClassNames = (0, classnames_1.default)(switch_css_1.default.switch, value ? switch_css_1.default.switchOn : switch_css_1.default.switchOff, {
        [switch_css_1.default.disabled]: disabled,
        [switch_css_1.default.animated]: (0, provider_1.useEnableAnimations)(),
    });
    const onChange = React.useCallback((value, e) => {
        setValue(value);
        onChangeProp === null || onChangeProp === void 0 ? void 0 : onChangeProp(value, e);
    }, [onChangeProp, setValue]);
    const getButton = (buttonId, labelId, descriptionId) => ((0, jsx_runtime_1.jsx)(button_1.BasicButton, { role: "switch", onClick: event => onChange(!value, event), className: switchClassNames, disabled: disabled, active: value, ariaLabel: ariaLabel, ariaLabelledBy: ariaLabelledBy !== null && ariaLabelledBy !== void 0 ? ariaLabelledBy : labelId, ariaDescribedBy: ariaDescribedBy !== null && ariaDescribedBy !== void 0 ? ariaDescribedBy : (description ? descriptionId : undefined), alignment: "start", noChildWrapper: true, id: buttonId, focusRef: focusRef, onFocus: onFocus, onBlur: onBlur, children: (0, jsx_runtime_1.jsx)("span", { className: switch_css_1.default.animationWrapper, children: (0, jsx_runtime_1.jsx)("span", { className: switch_css_1.default.thumb, children: (0, jsx_runtime_1.jsx)(icon_1.TickIcon, { size: "tiny", className: switch_css_1.default.tick }) }) }) }));
    if (label == null) {
        return getButton(id);
    }
    return ((0, jsx_runtime_1.jsxs)(
        "div",
        { className: switch_css_1.default.switchWrapper, children: [(0, jsx_runtime_1.jsx)("label", { htmlFor: buttonId, className: switch_css_1.default.switchText, id: labelId, children: (0, jsx_runtime_1.jsx)(SwitchLabelAndDescription, { label: label, description: description, disabled: disabled, descriptionId: descriptionId, labelWeight: labelWeight }) }), getButton(buttonId, labelId, descriptionId)] }
    ));
};
exports.Switch = Switch;
function SwitchLabelAndDescription({ label, description, disabled, descriptionId, labelWeight, }) {
    const labelElement = typeof label === 'string'
        ? ((0, jsx_runtime_1.jsx)(typography_1.Text, { tagName: "span", margins: "none", tone: disabled ? 'tertiary' : 'primary', weight: labelWeight, className: switch_css_1.default.switchLabel, children: label }))
        : (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: label });
    if (!description) {
        return labelElement;
    }
    return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [labelElement, (0, jsx_runtime_1.jsx)("div", { "aria-hidden": true, children: (0, jsx_runtime_1.jsx)(typography_1.Text, { className: switch_css_1.default.switchDescription, id: descriptionId, tone: "tertiary", size: "small", children: description }) })] }));
}
