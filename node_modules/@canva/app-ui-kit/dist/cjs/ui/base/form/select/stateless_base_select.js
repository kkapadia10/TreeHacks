"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseSelectItem = exports.renderEmptyMenuContent = exports.WindowedSelectMenu = exports.BaseSelectMenu = exports.BaseSelectTrigger = exports.StatelessBaseSelect = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const compose_react_refs_1 = require("@seznam/compose-react-refs");
const classnames_1 = require("classnames");
const React = require("react");
const box_1 = require('../../box/box');
const button_1 = require('../../button/button');
const device_capabilities_1 = require('../../device_capabilities/device_capabilities');
const divider_1 = require('../../divider/divider');
const checkbox_1 = require('../checkbox/checkbox');
const icon_1 = require('../../icons/chevron_down/icon');
const icon_2 = require('../../icons/tick/icon');
const layout_1 = require('../../layout/layout');
const spacer_1 = require('../../layout/spacer/spacer');
const menu_1 = require('../../menu/menu');
const metrics_1 = require('../../metrics/metrics');
const scroll_window_1 = require('../../scroll_controls/scroll_window');
const scroll_positioner_1 = require('../../scroll_positioner/scroll_positioner');
const flyout_1 = require('../../surface/flyout/flyout');
const typography_1 = require('../../typography/typography');
const base_select_css_1 = require("./base_select.css");
const base_select_messages_1 = require("./base_select.messages");
const base_select_util_1 = require("./base_select_util");
const ITEM_HEIGHT = parseInt(base_select_css_1.default.itemHeight, 10);
const DIVIDER_HEIGHT = parseInt(base_select_css_1.default.dividerHeight, 10);
const TEXT_DIVIDER_HEIGHT = parseInt(base_select_css_1.default.textDividerHeight, 10);
const DEFAULT_FLYOUT_WIDTH_UNITS = '40u';
const DEFAULT_FLYOUT_WIDTH = parseInt(DEFAULT_FLYOUT_WIDTH_UNITS, 10) * metrics_1.baseUnit;
function StatelessBaseSelect(props) {
    const { Trigger = BaseSelectTrigger, Menu = BaseSelectMenu, Item, Flyout = flyout_1.Flyout, value, placeholder, open, disabled, error, stretch, activeIndex, options, focusOnMenu = false, flyoutPlacement = 'bottom-start', flyoutWidth: flyoutWidthProp, id, ariaLabel, ariaLabelledBy, ariaDescribedBy, tooltipLabel, tooltipPlacement, className, onRequestToggle, onBlur, onFocus, onItemClick, onItemHover, areEqual = base_select_util_1.defaultAreEqual, isSelected = base_select_util_1.defaultIsSelected, getLabel = base_select_util_1.defaultGetLabel, } = props;
    const menuId = React.useId();
    const labelId = React.useId();
    const triggerContainerRef = React.useRef(null);
    const menuContainerRef = React.useRef(null);
    const flatOptions = React.useMemo(() => { var _a; return (_a = props.flatOptions) !== null && _a !== void 0 ? _a : (0, base_select_util_1.flattenOptions)(props.options); }, [props.options, props.flatOptions]);
    const optionGroups = React.useMemo(() => { var _a; return (_a = props.optionGroups) !== null && _a !== void 0 ? _a : (0, base_select_util_1.normalizeOptionGroups)(props.options); }, [props.options, props.optionGroups]);
    const selectedOptions = React.useMemo(() => { var _a; return (_a = props.selectedOptions) !== null && _a !== void 0 ? _a : flatOptions.filter(option => isSelected(option, value)); }, [flatOptions, props.selectedOptions, isSelected, value]);
    const activeDescendantId = (0, base_select_util_1.deriveIdentifier)(menuId, activeIndex);
    const [flyoutWidth, setFlyoutWidth] = React.useState(flyoutWidthProp !== null && flyoutWidthProp !== void 0 ? flyoutWidthProp : DEFAULT_FLYOUT_WIDTH_UNITS);
    React.useEffect(() => {
        var _a, _b;
        if (!stretch || flyoutWidthProp != null) {
            setFlyoutWidth(flyoutWidthProp !== null && flyoutWidthProp !== void 0 ? flyoutWidthProp : DEFAULT_FLYOUT_WIDTH_UNITS);
            return;
        }
        const triggerWidth = (_b = (_a = triggerContainerRef.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect().width) !== null && _b !== void 0 ? _b : 0;
        const width = triggerWidth < DEFAULT_FLYOUT_WIDTH ? DEFAULT_FLYOUT_WIDTH_UNITS : 'trigger';
        setFlyoutWidth(width);
    }, [flyoutWidthProp, stretch]);
    return ((0, jsx_runtime_1.jsx)(Flyout, { placement: flyoutPlacement, open: open !== null && open !== void 0 ? open : false, onRequestClose: onRequestToggle, captureFocus: focusOnMenu, width: flyoutWidth, trigger: (0, jsx_runtime_1.jsx)("div", { ref: (0, compose_react_refs_1.default)(triggerContainerRef, props.triggerContainerRef), className: (0, classnames_1.default)(base_select_css_1.default.triggerContainer, className, {
                [base_select_css_1.default.triggerStretch]: stretch,
            }), children: (0, jsx_runtime_1.jsx)(Trigger, { value: value, options: options, flatOptions: flatOptions, optionGroups: optionGroups, selectedOptions: selectedOptions, placeholder: placeholder, disabled: disabled, error: error, open: open, id: id, ariaLabel: ariaLabelledBy ? undefined : ariaLabel, ariaLabelledBy: ariaLabelledBy, ariaDescribedBy: ariaDescribedBy, activeIndex: activeIndex, onBlur: onBlur, onFocus: onFocus, role: "combobox", disclosure: true, labelId: labelId, active: open, ariaActiveDescendant: activeDescendantId, ariaControls: menuId, onRequestToggle: onRequestToggle, getLabel: getLabel, isSelected: isSelected, tooltipLabel: tooltipLabel, tooltipPlacement: tooltipPlacement }) }), children: ({ mode }) => ((0, jsx_runtime_1.jsx)("div", { className: base_select_css_1.default.menuContainer, ref: (0, compose_react_refs_1.default)(menuContainerRef, props.menuContainerRef), children: (0, jsx_runtime_1.jsx)(Menu, { Item: Item, id: menuId, options: options, flatOptions: flatOptions, optionGroups: optionGroups, selectedOptions: selectedOptions, value: value, activeIndex: activeIndex, activeOption: flatOptions[activeIndex !== null && activeIndex !== void 0 ? activeIndex : -1], onItemClick: onItemClick, onItemHover: onItemHover, areEqual: areEqual, isSelected: isSelected, getLabel: getLabel, sizingMode: mode === 'popover' ? 'fixed' : 'fill', menuContainerRef: menuContainerRef, ariaLabel: ariaLabel, ariaLabelledBy: ariaLabelledBy, children: options.length === 0 ? renderEmptyMenuContent() : undefined }) })) }));
}
exports.StatelessBaseSelect = StatelessBaseSelect;
function BaseSelectTrigger(props) {
    var _a, _b, _c;
    const { selectedOptions, children } = props;
    const placeholder = (_a = props.placeholder) !== null && _a !== void 0 ? _a : base_select_messages_1.BaseSelectMessages.defaultPlaceholder();
    const hasPlaceholder = !selectedOptions.length;
    const label = hasPlaceholder ? placeholder : (0, base_select_util_1.joinLabels)(selectedOptions.map(props.getLabel));
    const className = (0, classnames_1.default)(base_select_css_1.default.triggerButton, props.className, {
        [base_select_css_1.default.open]: props.open,
        [base_select_css_1.default.error]: props.error,
        [base_select_css_1.default.hoverSupported]: (0, device_capabilities_1.canHover)(),
    });
    const Icon = getIcon((_b = props.Icon) !== null && _b !== void 0 ? _b : 'auto', (_c = selectedOptions[0]) === null || _c === void 0 ? void 0 : _c.Icon);
    return ((0, jsx_runtime_1.jsxs)(button_1.BasicButton, { onClick: props.onRequestToggle, onBlur: props.onBlur, onFocus: props.onFocus, disclosure: true, active: props.open, disabled: props.disabled, className: className, icon: icon_1.ChevronDownIcon, iconSize: "small", iconPosition: "end", id: props.id, role: props.role, tooltipLabel: props.tooltipLabel, tooltipPlacement: props.tooltipPlacement, tooltipOverflowBoundariesElement: "viewport", ariaLabel: props.ariaLabel, ariaLabelledBy: props.ariaLabelledBy || (props.ariaLabel ? undefined : props.labelId), ariaDescribedBy: props.ariaDescribedBy, ariaControls: props.ariaControls, ariaHasPopup: "listbox", ariaActiveDescendant: props.ariaActiveDescendant, noChildWrapper: true, alignment: "start", children: [Icon && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(Icon, { size: "medium" }), (0, jsx_runtime_1.jsx)(spacer_1.Spacer, { size: "1u" })] })), (0, jsx_runtime_1.jsx)(typography_1.Text, { id: props.labelId, tagName: "span", lineClamp: 1, tone: typography_1.InheritColor, className: (0, classnames_1.default)(base_select_css_1.default.label, { [base_select_css_1.default.placeholder]: hasPlaceholder }), children: children !== null && children !== void 0 ? children : label })] }));
}
exports.BaseSelectTrigger = BaseSelectTrigger;
function getIcon(Icon, FallbackIcon) {
    if (Icon === 'none') {
        return undefined;
    }
    if (Icon === 'auto') {
        return FallbackIcon;
    }
    return Icon;
}
function useScrollToActiveItem({ activeIndex }) {
    const scrollRef = React.useRef(null);
    const activeItemRef = React.useRef(null);
    React.useEffect(() => {
        if (!scrollRef.current || !activeItemRef.current) {
            return;
        }
        if (scroll_positioner_1.ScrollPositioner.isAboveVisibleScroll(scrollRef.current, activeItemRef.current)) {
            scroll_positioner_1.ScrollPositioner.scrollToPutAtTop(scrollRef.current, activeItemRef.current);
        }
        if (scroll_positioner_1.ScrollPositioner.isBelowVisibleScroll(scrollRef.current, activeItemRef.current)) {
            scroll_positioner_1.ScrollPositioner.scrollToPutAtBottom(scrollRef.current, activeItemRef.current);
        }
    }, [activeIndex, scrollRef]);
    return { scrollRef, activeItemRef };
}
function BaseSelectMenu(props) {
    const { Item = exports.BaseSelectItem, flatOptions, optionGroups, value, activeIndex, id, ariaLabel, ariaLabelledBy, header, footer, isSelected, getLabel, onItemClick, onItemHover, className, children, sizingMode, } = props;
    const { scrollRef, activeItemRef } = useScrollToActiveItem({ activeIndex });
    const hasMultipleGroups = optionGroups.length > 1;
    return ((0, jsx_runtime_1.jsx)(WithHeaderAndFooter, { header: header, footer: footer, children: (0, jsx_runtime_1.jsx)("div", { className: (0, classnames_1.default)(base_select_css_1.default.scrollContainer, sizingMode === 'fixed' && base_select_css_1.default.popover, className), ref: scrollRef, id: hasMultipleGroups ? id : undefined, role: hasMultipleGroups ? 'listbox' : undefined, "aria-label": hasMultipleGroups ? ariaLabel : undefined, "aria-labelledby": hasMultipleGroups ? ariaLabelledBy : undefined, children: children
                ? (0, jsx_runtime_1.jsx)("div", { role: "alert", children: children })
                : (optionGroups.map((optionGroup, groupIndex) => ((0, jsx_runtime_1.jsxs)(React.Fragment, { children: [groupIndex > 0 && ((0, jsx_runtime_1.jsx)("div", { className: base_select_css_1.default.groupDivider, children: (0, jsx_runtime_1.jsx)(divider_1.Divider, {}) })), (0, jsx_runtime_1.jsx)(OptionGroup, { Item: Item, menuId: id, id: hasMultipleGroups ? undefined : id, role: hasMultipleGroups ? 'group' : 'listbox', ariaLabel: hasMultipleGroups ? undefined : ariaLabel, ariaLabelledBy: hasMultipleGroups ? undefined : ariaLabelledBy, activeItemRef: activeItemRef, value: value, optionIndexOffset: flatOptions.findIndex(o => o === optionGroup.options[0]), activeIndex: activeIndex, label: optionGroup.label, options: optionGroup.options, isSelected: isSelected, onItemClick: onItemClick, onItemHover: onItemHover, getLabel: getLabel })] }, groupIndex)))) }) }));
}
exports.BaseSelectMenu = BaseSelectMenu;
function OptionGroup({ Item = exports.BaseSelectItem, id, menuId, role, ariaLabel, ariaLabelledBy, value, optionIndexOffset = 0, activeIndex, label, options, isSelected, activeItemRef, onItemClick, onItemHover, getLabel, }) {
    const headingId = React.useId();
    const multiSelectable = Array.isArray(value);
    return ((0, jsx_runtime_1.jsxs)(menu_1.Menu, { id: id, role: role, ariaMultiSelectable: multiSelectable, ariaLabel: ariaLabel, ariaLabelledBy: label ? headingId : ariaLabelledBy, children: [label != null && (0, jsx_runtime_1.jsx)(menu_1.MenuDivider, { id: headingId, children: label }), options.map((option, i) => {
                const selected = isSelected(option, value);
                const itemIndex = optionIndexOffset + i;
                const active = activeIndex === itemIndex;
                const id = (0, base_select_util_1.deriveIdentifier)(menuId, itemIndex);
                return ((0, jsx_runtime_1.jsx)(Item, { id: id, selected: selected, active: active, forwardedRef: active ? activeItemRef : undefined, onItemClick: onItemClick, onItemHover: onItemHover, getLabel: getLabel, option: option, multiSelectable: multiSelectable }, id));
            })] }));
}
function WindowedSelectMenu(props) {
    const { Item = exports.BaseSelectItem, optionGroups, flatOptions, value, activeIndex, id, ariaLabel, ariaLabelledBy, header, footer, isSelected, getLabel, onItemClick, onItemHover, className, children, sizingMode, itemHeight = ITEM_HEIGHT, } = props;
    const itemSizes = React.useMemo(() => {
        const itemSizes = [];
        optionGroups.forEach((optionGroup, groupIndex) => {
            optionGroup.options.forEach((option, optionIndex) => {
                let height = itemHeight;
                if (optionIndex === 0 && groupIndex > 0) {
                    height += DIVIDER_HEIGHT;
                }
                if (optionIndex === 0 && optionGroup.label != null) {
                    height += TEXT_DIVIDER_HEIGHT;
                }
                itemSizes.push(height);
            });
        });
        return itemSizes;
    }, [itemHeight, optionGroups]);
    const { scrollRef, activeItemRef } = useScrollToActiveItem({ activeIndex });
    React.useEffect(() => {
        if (!scrollRef.current || activeIndex == null || activeIndex < 5) {
            return;
        }
        const activeOptionHeight = itemSizes[activeIndex];
        const activeOptionPosition = itemSizes.slice(0, activeIndex).reduce((a, h) => a + h);
        const paddingTop = parseInt(window.getComputedStyle(scrollRef.current).paddingTop, 10);
        const scrollOffset = scrollRef.current.offsetHeight - paddingTop - activeOptionHeight;
        scrollRef.current.scrollTop = activeOptionPosition - scrollOffset;
    }, []);
    const hasMultipleGroups = optionGroups.length > 1;
    return ((0, jsx_runtime_1.jsx)(WithHeaderAndFooter, { header: header, footer: footer, children: (0, jsx_runtime_1.jsx)(scroll_window_1.ScrollWindow, { layout: "vertical", children: ({ scrollableRef, scrollState }) => ((0, jsx_runtime_1.jsx)("div", { className: (0, classnames_1.default)(base_select_css_1.default.scrollContainer, sizingMode === 'fixed' && base_select_css_1.default.popover, className), ref: (0, compose_react_refs_1.default)(scrollableRef, scrollRef), id: hasMultipleGroups ? id : undefined, role: hasMultipleGroups ? 'listbox' : undefined, "aria-label": hasMultipleGroups ? ariaLabel : undefined, "aria-labelledby": hasMultipleGroups ? ariaLabelledBy : undefined, children: children
                    ? (0, jsx_runtime_1.jsx)("div", { role: "alert", children: children })
                    : ((0, jsx_runtime_1.jsx)(scroll_window_1.WindowedList, { scrollState: scrollState, itemSizes: itemSizes, overscan: 2, children: (state, itemPositions) => {
                            if (!state) {
                                return ((0, jsx_runtime_1.jsx)("div", { role: "none", style: { height: itemPositions[itemPositions.length - 1] } }));
                            }
                            const { firstVisible, lastVisible } = state;
                            const spaceBefore = itemPositions[firstVisible];
                            const spaceAfter = itemPositions[itemPositions.length - 1] - itemPositions[lastVisible];
                            const visibleGroups = (0, base_select_util_1.sliceOptionGroups)(optionGroups, firstVisible, lastVisible);
                            return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)("div", { role: "none", style: { height: spaceBefore } }), visibleGroups.map(optionGroup => {
                                        const isFirstItemVisible = optionGroup.slice[0] === 0;
                                        return ((0, jsx_runtime_1.jsxs)(React.Fragment, { children: [optionGroup.originalIndex > 0 && isFirstItemVisible && ((0, jsx_runtime_1.jsx)("div", { className: base_select_css_1.default.groupDivider, children: (0, jsx_runtime_1.jsx)(divider_1.Divider, {}) })), (0, jsx_runtime_1.jsx)(OptionGroup, { Item: Item, menuId: id, id: hasMultipleGroups ? undefined : id, role: hasMultipleGroups ? 'group' : 'listbox', ariaLabel: hasMultipleGroups ? optionGroup.label : ariaLabel, ariaLabelledBy: hasMultipleGroups ? undefined : ariaLabelledBy, activeItemRef: activeItemRef, value: value, optionIndexOffset: flatOptions.findIndex(o => o === optionGroup.options[0]), activeIndex: activeIndex, label: isFirstItemVisible ? optionGroup.label : undefined, options: optionGroup.options, isSelected: isSelected, onItemClick: onItemClick, onItemHover: onItemHover, getLabel: getLabel })] }, optionGroup.originalIndex));
                                    }), (0, jsx_runtime_1.jsx)("div", { role: "none", style: { height: spaceAfter } })] }));
                        } })) })) }) }));
}
exports.WindowedSelectMenu = WindowedSelectMenu;
function WithHeaderAndFooter(props) {
    const { header, footer, children } = props;
    return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [header && ((0, jsx_runtime_1.jsx)("header", { className: base_select_css_1.default.menuHeader, children: typeof header === 'string' ? (0, jsx_runtime_1.jsx)(typography_1.Text, { children: header }) : header })), children, footer && ((0, jsx_runtime_1.jsx)("footer", { className: base_select_css_1.default.menuFooter, children: typeof footer === 'string' ? (0, jsx_runtime_1.jsx)(typography_1.Text, { children: footer }) : footer }))] }));
}
function renderEmptyMenuContent() {
    return ((0, jsx_runtime_1.jsx)(box_1.Box, { padding: "3u", children: (0, jsx_runtime_1.jsx)(typography_1.Text, { children: base_select_messages_1.BaseSelectMessages.defaultEmptyMessage() }) }));
}
exports.renderEmptyMenuContent = renderEmptyMenuContent;
exports.BaseSelectItem = React.memo(_BaseSelectItem);
function _BaseSelectItem(props) {
    var _a, _b, _c, _d;
    const { onItemClick, onItemHover, option, multiSelectable, } = props;
    const onClick = React.useCallback((event) => {
        onItemClick === null || onItemClick === void 0 ? void 0 : onItemClick(option, event);
    }, [onItemClick, option]);
    const onMouseEnter = React.useCallback((event) => {
        onItemHover === null || onItemHover === void 0 ? void 0 : onItemHover(option, event);
    }, [onItemHover, option]);
    const OptionIcon = option.Icon && (0, jsx_runtime_1.jsx)(option.Icon, { size: "medium" });
    const SelectedIcon = !multiSelectable && props.selected ? (0, jsx_runtime_1.jsx)(icon_2.TickIcon, { size: "medium" }) : undefined;
    const CheckboxIcon = (0, jsx_runtime_1.jsx)(checkbox_1.FakeCheckbox, { checked: props.selected, disabled: props.option.disabled });
    const start = multiSelectable
        ? ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [CheckboxIcon, (_a = props.start) !== null && _a !== void 0 ? _a : OptionIcon] }))
        : (_b = props.start) !== null && _b !== void 0 ? _b : OptionIcon;
    const end = (_c = props.end) !== null && _c !== void 0 ? _c : SelectedIcon;
    const content = (_d = props.children) !== null && _d !== void 0 ? _d : (props.option.description != null
        ? ((0, jsx_runtime_1.jsxs)(layout_1.Rows, { tagName: "span", spacing: "0", children: [(0, jsx_runtime_1.jsx)(typography_1.Text, { tagName: "span", lineClamp: 1, children: props.getLabel(props.option) }), (0, jsx_runtime_1.jsx)(typography_1.Text, { tagName: "span", size: "small", tone: "tertiary", children: props.option.description })] }))
        : props.getLabel(props.option));
    return ((0, jsx_runtime_1.jsx)(menu_1.MenuItem, { id: props.id, ariaSelected: props.selected, buttonRef: props.forwardedRef, tabIndex: -1, onClick: onClick, onMouseEnter: onMouseEnter, start: start, end: end, className: (0, classnames_1.default)(props.className, {
            [base_select_css_1.default.active]: props.active,
            [base_select_css_1.default.disabled]: props.option.disabled,
        }), disabled: props.option.disabled, children: content }));
}
