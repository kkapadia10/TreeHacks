"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SegmentedControl = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const compose_react_refs_1 = require("@seznam/compose-react-refs");
const classnames_1 = require("classnames");
const mobx_react_1 = require("mobx-react");
const React = require("react");
const pointer_input_state_1 = require('../../a11y/pointer_input_state/pointer_input_state');
const button_1 = require('../../button/button');
const controllable_value_1 = require('../../controllable_value/controllable_value');
const focusable_1 = require('../../focusable/focusable');
const use_key_combination_handler_1 = require('../../key_combinations/use_key_combination_handler');
const layout_1 = require('../../layout/layout');
const typography_1 = require('../../typography/typography');
const segmented_control_css_1 = require("./segmented_control.css");
function SegmentedControl(props) {
    const { id: idProp, ariaLabel, ariaLabelledBy, ariaDescribedBy, disabled, options, value: valueProp, defaultValue, onChange: onChangeProp, focusRef: focusRefProp, onFocus: onFocusProp, onBlur: onBlurProp, } = props;
    const [value, setValue] = (0, controllable_value_1.useControllableValue)({
        value: valueProp,
        defaultValue,
    });
    const fallbackId = React.useId();
    const id = idProp !== null && idProp !== void 0 ? idProp : fallbackId;
    const focusRef = (0, focusable_1.useFocusableRef)(focusRefProp);
    const containerRef = React.useRef(null);
    const availableOptions = React.useMemo(() => {
        return options.filter(option => {
            return !option.disabled;
        });
    }, [options]);
    const itemIds = options.map((option, itemIndex) => `${id}--${itemIndex}`);
    const activeIndex = options.findIndex(option => option.value === value);
    const onChange = React.useCallback((value) => {
        setValue(value);
        onChangeProp === null || onChangeProp === void 0 ? void 0 : onChangeProp(value);
    }, [onChangeProp, setValue]);
    const onFocus = React.useCallback((e) => {
        var _a;
        const previouslyFocussedElement = e.relatedTarget;
        if (previouslyFocussedElement && ((_a = containerRef === null || containerRef === void 0 ? void 0 : containerRef.current) === null || _a === void 0 ? void 0 : _a.contains(previouslyFocussedElement))) {
            return;
        }
        onFocusProp === null || onFocusProp === void 0 ? void 0 : onFocusProp(e);
    }, [onFocusProp]);
    const onBlur = React.useCallback((e) => {
        var _a;
        const nextElementToBeFocussed = e.relatedTarget;
        if (nextElementToBeFocussed && ((_a = containerRef === null || containerRef === void 0 ? void 0 : containerRef.current) === null || _a === void 0 ? void 0 : _a.contains(nextElementToBeFocussed))) {
            return;
        }
        onBlurProp === null || onBlurProp === void 0 ? void 0 : onBlurProp(e);
    }, [onBlurProp]);
    const moveSelection = React.useCallback((delta) => {
        const currentIndex = availableOptions.findIndex(option => option.value === value);
        const newIndex = ((currentIndex > -1 ? currentIndex : 0) + availableOptions.length + delta)
            % availableOptions.length;
        onChange(availableOptions[newIndex].value);
    }, [availableOptions, value, onChange]);
    const { ref: keyRef } = (0, use_key_combination_handler_1.useKeyCombinationHandler)([
        ['ArrowUp', () => moveSelection(-1)],
        ['ArrowDown', () => moveSelection(1)],
        ['previous', () => moveSelection(-1)],
        ['next', () => moveSelection(1)],
    ], { handleInputs: true });
    return ((0, jsx_runtime_1.jsx)("div", { ref: (0, compose_react_refs_1.default)(keyRef, focusRef, containerRef), "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy, className: (0, classnames_1.default)(segmented_control_css_1.default.segmentedControl, {
            [segmented_control_css_1.default.disabled]: disabled,
        }), id: id, role: "radiogroup", tabIndex: disabled ? -1 : 0, onFocus: onFocus, onBlur: onBlur, "aria-activedescendant": itemIds[activeIndex !== null && activeIndex !== void 0 ? activeIndex : -1], children: (0, jsx_runtime_1.jsx)(layout_1.Grid, { spacing: "0.5u", columns: options.length, children: options.map((option, index) => {
                var _a;
                return ((0, jsx_runtime_1.jsx)(SegmentedControlItem, { label: option.label, active: option.value === value, disabled: (_a = option.disabled) !== null && _a !== void 0 ? _a : disabled, onChange: onChange, value: option.value, ariaLabel: option.ariaLabel, id: itemIds[index] }, index));
            }) }) }));
}
exports.SegmentedControl = SegmentedControl;
function SegmentedControlItem(props) {
    const { active, ariaLabel, disabled, label, onChange, value, id } = props;
    return ((0, jsx_runtime_1.jsx)(mobx_react_1.Observer, { children: () => ((0, jsx_runtime_1.jsx)(button_1.BasicButton, { active: active, className: (0, classnames_1.default)(segmented_control_css_1.default.buttonItem, {
                [segmented_control_css_1.default.buttonItemActive]: active,
                [segmented_control_css_1.default.hoverSupported]: pointer_input_state_1.pointerInputState.isMouseInput,
            }), disabled: disabled, role: "radio", ariaLabel: ariaLabel, id: id, tabIndex: -1, onClick: () => !active && onChange(value), size: "small", noChildWrapper: true, children: typeof label === 'string'
                ? ((0, jsx_runtime_1.jsx)(typography_1.Text, { tagName: "span", alignment: "center", tone: typography_1.InheritColor, weight: active ? 'bold' : 'regular', children: label }))
                : (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: label }) })) }));
}
