"use strict";

const makeObservable = require('../../../../../base/make_observable/make_observable').makeObservable;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ButtonRadioGroup = void 0;
const tslib_1 = require("tslib");
const jsx_runtime_1 = require("react/jsx-runtime");
const compose_react_refs_1 = require("@seznam/compose-react-refs");
const classnames_1 = require("classnames");
const mobx = require("mobx");
const mobxReact = require("mobx-react");
const React = require("react");
const button_1 = require('../../../button/button');
const use_key_combination_handler_1 = require('../../../key_combinations/use_key_combination_handler');
const layout_1 = require('../../../layout/layout');
const typography_1 = require('../../../typography/typography');
const radio_group_css_1 = require("../radio_group.css");
const ButtonItem = React.memo(function ButtonItem({
  active,
  disabled,
  label,
  description,
  onClick,
  tabbable,
  className,
  ariaLabel,
  focusRef,
  onFocus,
  onBlur
}) {
  const descriptionId = React.useId();
  return (0, jsx_runtime_1.jsx)(button_1.BasicButton, {
    className: (0, classnames_1.default)(radio_group_css_1.default.buttonItem, {
      [radio_group_css_1.default.buttonItemActive]: active
    }, className),
    ariaLabel: ariaLabel,
    disabled: disabled,
    onClick: onClick,
    type: "button",
    role: "radio",
    active: active,
    tabIndex: active || tabbable ? undefined : -1,
    focusRef: focusRef,
    onFocus: onFocus,
    onBlur: onBlur,
    noChildWrapper: true,
    ariaDescribedBy: description ? descriptionId : undefined,
    children: (0, jsx_runtime_1.jsx)(ButtonItemLabel, {
      label: label,
      description: description,
      disabled: disabled,
      active: active,
      descriptionId: descriptionId
    })
  });
});
function ButtonItemLabel({
  label,
  description,
  disabled,
  active,
  descriptionId
}) {
  const labelElement = typeof label === 'string' ? (0, jsx_runtime_1.jsx)(typography_1.Text, {
    tagName: "span",
    margins: "none",
    alignment: "center",
    tone: disabled ? 'tertiary' : 'primary',
    weight: active ? 'bold' : 'regular',
    children: label
  }) : (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, {
    children: label
  });
  if (!description) {
    return labelElement;
  }
  return (0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, {
    children: [labelElement, (0, jsx_runtime_1.jsx)("div", {
      "aria-hidden": true,
      children: (0, jsx_runtime_1.jsx)(typography_1.Text, {
        id: descriptionId,
        tagName: "span",
        tone: "tertiary",
        size: "small",
        children: description
      })
    })]
  });
}
let ButtonItemContainer = class ButtonItemContainer extends React.Component {
  static _makeObservable(instance) {
    makeObservable(instance, {
      onClick: mobx.computed
    });
  }
  constructor(...args) {
    super(...args);
    ButtonItemContainer._makeObservable(this);
  }
  get onClick() {
    const {
      option,
      active,
      onChange
    } = this.props;
    return event => !active && (onChange === null || onChange === void 0 ? void 0 : onChange(option.value, event));
  }
  render() {
    var _a;
    const {
      active,
      disabled,
      option,
      tabbable,
      className,
      focusRef,
      onFocus,
      onBlur
    } = this.props;
    return (0, jsx_runtime_1.jsx)(ButtonItem, {
      ariaLabel: option.ariaLabel,
      active: active,
      disabled: (_a = option.disabled) !== null && _a !== void 0 ? _a : disabled,
      tabbable: tabbable,
      className: className,
      focusRef: focusRef,
      onClick: this.onClick,
      onFocus: onFocus,
      onBlur: onBlur,
      label: option.label,
      description: option.description
    });
  }
};
ButtonItemContainer = tslib_1.__decorate([mobxReact.observer], ButtonItemContainer);
function _ButtonRadioGroup(props, ref) {
  const {
    itemsPerRow,
    disabled,
    options,
    value,
    id,
    ariaLabel,
    ariaLabelledBy,
    ariaDescribedBy,
    className,
    focusRef: focusRefProp,
    onChange,
    onFocus,
    onBlur
  } = props;
  const shouldFocus = React.useRef(false);
  const activeRef = React.useRef(null);
  React.useEffect(() => {
    var _a;
    if (shouldFocus.current) {
      (_a = activeRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }
  }, [shouldFocus, value]);
  const availableOptions = options.filter(option => {
    return !option.disabled;
  });
  const firstAvailableOption = availableOptions[0];
  const moveSelection = delta => {
    const currentIndex = availableOptions.findIndex(option => option.value === value);
    const newIndex = ((currentIndex > -1 ? currentIndex : 0) + availableOptions.length + delta) % availableOptions.length;
    shouldFocus.current = true;
    onChange === null || onChange === void 0 ? void 0 : onChange(availableOptions[newIndex].value);
  };
  const {
    ref: keyRef
  } = (0, use_key_combination_handler_1.useKeyCombinationHandler)([['ArrowUp', () => moveSelection(-1)], ['ArrowDown', () => moveSelection(1)], ['previous', () => moveSelection(-1)], ['next', () => moveSelection(1)]], {
    handleInputs: true
  });
  return (0, jsx_runtime_1.jsx)("div", {
    ref: (0, compose_react_refs_1.default)(keyRef, ref),
    className: className,
    role: "radiogroup",
    id: id,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    "aria-describedby": ariaDescribedBy,
    children: (0, jsx_runtime_1.jsx)(layout_1.Grid, {
      spacing: "1u",
      columns: itemsPerRow || options.length,
      children: options.map((option, idx) => {
        const tabbable = option === firstAvailableOption && value === undefined;
        const isCurrentItemSelected = option.value === value;
        const hasFocusRef = value != null ? isCurrentItemSelected : option === firstAvailableOption;
        const focusRef = (0, compose_react_refs_1.default)(hasFocusRef ? focusRefProp : undefined, isCurrentItemSelected ? activeRef : undefined);
        return (0, jsx_runtime_1.jsx)(ButtonItemContainer, {
          disabled: disabled,
          active: isCurrentItemSelected,
          option: option,
          tabbable: tabbable,
          className: option.className,
          focusRef: focusRef,
          onChange: onChange,
          onFocus: onFocus,
          onBlur: onBlur
        }, idx);
      })
    })
  });
}
exports.ButtonRadioGroup = React.forwardRef(_ButtonRadioGroup);