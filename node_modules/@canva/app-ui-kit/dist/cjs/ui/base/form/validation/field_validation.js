"use strict";

const makeObservable = require('../../../../base/make_observable/make_observable').makeObservable;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ignoreNullValueInFactory = exports.ignoreNullValue = exports.allErrors = exports.anyError = exports.mapErrorMessage = exports.getValidationFn = exports.WithFieldValidation = exports.useFieldValidation = exports.isValid = exports.validateAll = exports.getError = exports.getResult = exports.startValidation = exports.setValue = exports.FieldValidationStore = exports.invalid = exports.valid = void 0;
const tslib_1 = require("tslib");
const jsx_runtime_1 = require("react/jsx-runtime");
const mobx = require("mobx");
const mobx_react_1 = require("mobx-react");
const React = require("react");
const validation_1 = require('../../validation/validation');
const form_validation_store_1 = require("./form_validation_store");
exports.valid = validation_1.Validation.valid;
exports.invalid = validation_1.Validation.invalid;
class FieldValidationStore {
  static _makeObservable(instance) {
    makeObservable(instance, {
      value: mobx.observable.ref,
      validationStarted: mobx.observable.ref,
      validationFn: mobx.observable.ref
    });
  }
  constructor({
    value,
    validator
  }) {
    FieldValidationStore._makeObservable(this);
    this.value = undefined;
    this.validationStarted = false;
    this.value = value;
    this.validator = validator;
  }
  get validator() {
    return this.validationFn;
  }
  set validator(validator) {
    this.validationFn = validator != null ? getValidationFn(validator) : undefined;
  }
}
exports.FieldValidationStore = FieldValidationStore;
exports.setValue = mobx.action((store, value) => {
  store.value = value;
});
exports.startValidation = mobx.action(store => {
  store.validationStarted = true;
});
const getResult = store => {
  var _a, _b;
  return (_b = (_a = store.validator) === null || _a === void 0 ? void 0 : _a.call(store, store.value)) !== null && _b !== void 0 ? _b : validation_1.Validation.valid();
};
exports.getResult = getResult;
const getError = store => {
  const result = store.validationStarted ? (0, exports.getResult)(store) : undefined;
  if ((result === null || result === void 0 ? void 0 : result.state) === 'invalid') {
    return result.error;
  }
};
exports.getError = getError;
const validateAll = (...stores) => {
  let isValid = true;
  for (const v of stores) {
    if (v == null) {
      continue;
    }
    (0, exports.startValidation)(v);
    isValid && (isValid = (0, exports.getResult)(v).state === 'valid');
  }
  return isValid;
};
exports.validateAll = validateAll;
const isValid = (...stores) => {
  for (const v of stores) {
    if (v != null && (0, exports.getError)(v) != null) {
      return false;
    }
  }
  return true;
};
exports.isValid = isValid;
function useFieldValidation(
  {
    store: storeProp,
    name,
    value,
    validator
  }
) {
  const [store, setStore] = React.useState(() => {
    if (storeProp != null) {
      return storeProp;
    }
    if (validator != null) {
      return new FieldValidationStore({
        value,
        validator
      });
    }
  });
  React.useEffect(() => {
    if (store == null && validator != null) {
      setStore(new FieldValidationStore({
        value,
        validator
      }));
    }
  }, [store, validator, value]);
  (0, form_validation_store_1.useRegisterFormValidation)({
    name,
    fieldValidation: store
  });
  React.useEffect(() => {
    if (storeProp == null && store != null) {
      mobx.runInAction(() => {
        store.value = value;
        store.validator = validator;
      });
    }
  }, [store, storeProp, value, validator]);
  return store;
}
exports.useFieldValidation = useFieldValidation;
exports.WithFieldValidation = (0, mobx_react_1.observer)(function WithFieldValidation({
  children,
  ...rest
}) {
  const store = useFieldValidation(rest);
  return (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, {
    children: children({
      store
    })
  });
});
function getValidationFn(validator) {
  if (Array.isArray(validator)) {
    if (isValidationMessageTuple(validator)) {
      return (0, exports.mapErrorMessage)(...validator);
    }
    return (0, exports.anyError)(validator);
  }
  return validator;
}
exports.getValidationFn = getValidationFn;
function isValidationMessageTuple(validator) {
  return validator.length === 2 && typeof validator[1] === 'string';
}
const mapErrorMessage = (boolValidator, errorMessage) => {
  return value => {
    const result = boolValidator(value);
    if (result.state === 'invalid') {
      return validation_1.Validation.invalid(errorMessage);
    }
    return result;
  };
};
exports.mapErrorMessage = mapErrorMessage;
const anyError = validators => validation_1.Validation.all(validators.map(v => getValidationFn(v)));
exports.anyError = anyError;
const allErrors = validators => value => {
  let errors = [];
  for (const validator of validators) {
    const validationFn = getValidationFn(validator);
    const result = validationFn(value);
    if (result.state === 'invalid') {
      if (Array.isArray(result.error)) {
        errors = errors.concat(result.error);
      } else {
        errors.push(result.error);
      }
    }
  }
  if (errors.length) {
    return validation_1.Validation.invalid(errors);
  }
  return validation_1.Validation.valid();
};
exports.allErrors = allErrors;
const ignoreNullValue = validationFn => {
  return value => {
    if (value == null) {
      return (0, exports.valid)();
    }
    return validationFn(value);
  };
};
exports.ignoreNullValue = ignoreNullValue;
const ignoreNullValueInFactory = fnFactory => {
  return args => (0, exports.ignoreNullValue)(fnFactory(args));
};
exports.ignoreNullValueInFactory = ignoreNullValueInFactory;