"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDraggableBottomSheet = exports.DeviceFrameSheet = exports.BottomSheet = exports.Sheet = exports.getDefaultSheetPeekHeight = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const preconditions_1 = require('../../../base/preconditions');
const React = require("react");
const react_dom_1 = require("react-dom");
const gesture_recognizer_view_1 = require('../gestures/gesture_recognizer_view');
const provider_1 = require('../provider/provider');
const layers_1 = require("./internal/layers");
const sheet_behavior_1 = require("./internal/sheet_behavior");
const internal_sheet_1 = require("./internal_sheet");
const getDefaultSheetPeekHeight = (window) => Math.round(window.innerHeight * 0.44);
exports.getDefaultSheetPeekHeight = getDefaultSheetPeekHeight;
const DEFAULT_SHEET_PEEK_HEIGHT = 
typeof window !== 'undefined' ? (0, exports.getDefaultSheetPeekHeight)(window) : undefined;
function useEaselConfiguration() {
    return {
        enableAnimations: (0, provider_1.useEnableAnimations)(),
        direction: (0, provider_1.useDirection)(),
        disableFocusTraps: (0, provider_1.useDisableFocusTraps)(),
        enableUserSelection: (0, provider_1.useEnableUserSelection)(),
        theme: (0, provider_1.useTheme)(),
        enableHighColorContrast: (0, provider_1.useEnableHighColorContrast)(),
        autoplayVideos: (0, provider_1.useAutoplayVideos)(),
        disableDialogBlur: (0, provider_1.useDisableDialogBlur)(),
        enableEaselUiRefresh: (0, provider_1.useEnableEaselUiRefresh)(),
    };
}
const layers = new layers_1.Layers();
const Sheet = (props) => ((0, jsx_runtime_1.jsx)(internal_sheet_1.InternalSheet, { ...props, easelConfiguration: useEaselConfiguration(), layers: layers, createPortal: react_dom_1.createPortal, enableLayerDraggable: false }));
exports.Sheet = Sheet;
const BottomSheet = ({ onRequestClose, onCloseAnimationComplete, peekHeightPx, ...restProps }) => {
    const [snapHeights, setSnapHeights] = React.useState([undefined]);
    React.useEffect(() => {
        if (peekHeightPx === 'none') {
            setSnapHeights([undefined]);
            return;
        }
        setSnapHeights([DEFAULT_SHEET_PEEK_HEIGHT, undefined]);
    }, [peekHeightPx]);
    const [snapIndex, setSnapIndex] = React.useState(0);
    const handleDragTrigger = React.useCallback((opts) => {
        switch (opts.direction) {
            case 'opening':
                const isFullyExpanded = snapIndex + 1 === snapHeights.length;
                if (!isFullyExpanded) {
                    setSnapIndex(snapIndex + 1);
                }
                break;
            case 'closing':
                const isSmallestHeight = snapIndex === 0;
                if (isSmallestHeight) {
                    onRequestClose && onRequestClose();
                }
                else {
                    setSnapIndex(snapIndex - 1);
                }
                break;
            default:
                throw new preconditions_1.UnreachableError(opts.direction);
        }
    }, [snapIndex, snapHeights.length, onRequestClose]);
    const handleCloseAnimationComplete = React.useCallback(() => {
        setSnapIndex(0);
        onCloseAnimationComplete && onCloseAnimationComplete();
    }, [onCloseAnimationComplete]);
    return ((0, jsx_runtime_1.jsx)(internal_sheet_1.InternalSheet, { ...restProps, easelConfiguration: useEaselConfiguration(), layers: layers, createPortal: react_dom_1.createPortal, hasShadow: true, largeRoundedCorners: true, expandContentIntoUnsafeArea: true, from: "bottom", maxSize: undefined, minSize: undefined, scrollable: false, enableLayerDraggable: true, maxVisibleSizePx: snapHeights[snapIndex], onRequestClose: onRequestClose, onLayerDraggingThresholdTriggered: handleDragTrigger, onCloseAnimationComplete: handleCloseAnimationComplete }));
};
exports.BottomSheet = BottomSheet;
const DeviceFrameSheet = (props) => ((0, jsx_runtime_1.jsx)(internal_sheet_1.InternalSheet, { ...props, windowOverride: props.window, easelConfiguration: useEaselConfiguration(), layers: layers, createPortal: react_dom_1.createPortal, enableLayerDraggable: false }));
exports.DeviceFrameSheet = DeviceFrameSheet;
function createDraggableBottomSheet(
    { onStateChanged, onPanning, peekSizePx, transparentOverlayOnPeek, viewportTopOffset, window, }
) {
    const sheetBehavior = new sheet_behavior_1.BottomSheetDragBehavior(window, onStateChanged, peekSizePx, transparentOverlayOnPeek, viewportTopOffset, onPanning);
    const recognizers = [sheetBehavior.recognizer];
    const Handle = ({ children }) => ((0, jsx_runtime_1.jsx)(gesture_recognizer_view_1.GestureRecognizerView, { recognizers: recognizers, children: ({ gestureRef }) => (0, jsx_runtime_1.jsx)("div", { ref: gestureRef, children: children }) }));
    const Sheet = (props) => ((0, jsx_runtime_1.jsx)(internal_sheet_1.InternalSheet, { ...props, easelConfiguration: useEaselConfiguration(), from: "bottom", layers: layers, windowOverride: window, createPortal: react_dom_1.createPortal, sheetBehavior: sheetBehavior, enableLayerDraggable: false }));
    const sheetController = sheetBehavior;
    return { Handle, Sheet, sheetController, isSwipingSheet: () => sheetBehavior.isSwiping };
}
exports.createDraggableBottomSheet = createDraggableBottomSheet;
