"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CardDecorator = exports.InternalHorizontalCard = exports.InternalCard = exports.InternalCardWithDetails = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const classnames_1 = require("classnames");
const mobx_react_1 = require("mobx-react");
const React = require("react");
const access_mode_state_1 = require('../../a11y/access_mode_state/access_mode_state');
const badge_container_1 = require('../../badge/badge_container/badge_container');
const button_1 = require('../../button/button');
const layout_1 = require('../../layout/layout');
const metrics_1 = require('../../metrics/metrics');
const provider_1 = require('../../provider/provider');
const card_css_1 = require("../card.css");
const card_bottom_badge_1 = require("../decorators/card_bottom_badge");
const card_button_1 = require("../decorators/card_button");
const card_checkbox_1 = require("../decorators/card_checkbox");
const card_content_1 = require("./card_content");
const card_context_1 = require("./card_context");
exports.InternalCardWithDetails = (0, mobx_react_1.observer)(function InternalCardWithDetails(props) {
    const { avatar, title, description, preTitle, containerClassName, ...internalCardProps } = props;
    const { onMouseEnter, onMouseLeave } = (0, card_context_1.useCardEventHandlers)();
    const titleId = React.useId();
    const descriptionId = React.useId();
    const cardButtonAriaLabelledBy = props.buttonAriaLabelledBy || (!!title && !props.buttonAriaLabel ? titleId : undefined);
    const hasDetails = !!(title || description || preTitle || avatar);
    if (!hasDetails) {
        return (0, jsx_runtime_1.jsx)(exports.InternalCard, { ...internalCardProps, containerClassName: containerClassName });
    }
    return ((0, jsx_runtime_1.jsxs)(badge_container_1.ExtendedBadgeVisibilityTrigger, { className: (0, classnames_1.default)(card_css_1.default.article, containerClassName), onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, role: "group", ariaLabelledBy: title ? titleId : undefined, ariaDescribedBy: description ? descriptionId : undefined, children: [(0, jsx_runtime_1.jsx)(exports.InternalCard, { buttonAriaLabelledBy: cardButtonAriaLabelledBy, trackHoverState: false, ...internalCardProps }), (0, jsx_runtime_1.jsx)(layout_1.Spacer, { size: "1u", direction: "vertical" }), (0, jsx_runtime_1.jsx)(card_content_1.CardContent, { title: title, description: description, preTitle: preTitle, avatar: avatar, titleId: titleId, descriptionId: descriptionId })] }));
});
exports.InternalCard = (0, mobx_react_1.observer)(function InternalCard(props) {
    const { children, ariaControls, ariaHasPopup, ariaExpanded, ariaLabel, buttonAriaLabel, buttonAriaLabelledBy, onClick, href, target, draggable, onDragStart, onContextMenu, buttonId, buttonRef, trackHoverState = true, containerClassName, outerClassName, innerClassName, outerStyle, innerStyle, selected, selectionIsPrimaryAction, } = props;
    const enableAnimations = (0, provider_1.useEnableAnimations)();
    const { sharp, size, disabled, border } = (0, card_context_1.useCardConfiguration)();
    const { thumbnails, decorators } = partitionChildren(children);
    const checkbox = decorators.find(decorator => decorator.type === card_checkbox_1.CardCheckbox);
    const _selected = checkbox ? !!checkbox.props.selected : selected;
    const hasInnerDiv = innerStyle || innerClassName;
    const contents = ((0, jsx_runtime_1.jsxs)(badge_container_1.BadgeContainer, { className: (0, classnames_1.default)(card_css_1.default.cardArea, containerClassName, {
            [card_css_1.default.animated]: enableAnimations,
            [card_css_1.default.cardBorder]: border && !hasInnerDiv,
            [card_css_1.default.roundBorders]: !sharp,
            [card_css_1.default.disabled]: disabled,
        }), paddingStyle: size === 'medium' ? 'standard' : 'compact', ariaLabel: ariaLabel, role: decorators.length ? 'group' : undefined, children: [hasInnerDiv
                ? ((0, jsx_runtime_1.jsx)("div", { className: (0, classnames_1.default)(innerClassName, {
                        [card_css_1.default.cardBorder]: border,
                        [card_css_1.default.roundBorders]: !sharp,
                    }), style: innerStyle, children: thumbnails }))
                : thumbnails, (0, jsx_runtime_1.jsx)(InternalCardButton, { href: href, target: target, onClick: onClick, ariaControls: ariaControls, ariaHasPopup: ariaHasPopup, ariaExpanded: ariaExpanded, buttonAriaLabel: buttonAriaLabel, buttonAriaLabelledBy: buttonAriaLabelledBy, ariaPressed: selectionIsPrimaryAction ? _selected || false : undefined, trackHoverState: trackHoverState, buttonId: buttonId, buttonRef: buttonRef, disabled: disabled, draggable: draggable, onDragStart: onDragStart, onContextMenu: onContextMenu }), decorators] }));
    if (selectionIsPrimaryAction || checkbox || outerStyle || outerClassName) {
        return ((0, jsx_runtime_1.jsx)("div", { style: outerStyle, className: (0, classnames_1.default)(outerClassName, card_css_1.default.outerWrapper, {
                [card_css_1.default.selectable]: selectionIsPrimaryAction || checkbox,
                [card_css_1.default.selectableBorderOnHover]: selectionIsPrimaryAction,
                [card_css_1.default.selected]: _selected,
                [card_css_1.default.animated]: enableAnimations,
                [card_css_1.default.roundBorders]: !sharp,
            }), children: contents }));
    }
    return contents;
});
exports.InternalHorizontalCard = (0, mobx_react_1.observer)((props) => {
    const { title, description, preTitle, ariaControls, ariaHasPopup, ariaExpanded, buttonAriaLabel, onClick, href, target, draggable, onDragStart, onContextMenu, buttonId, buttonRef, children, thumbnailSize, selected, selectionIsPrimaryAction, bleedX, } = props;
    const enableAnimations = (0, provider_1.useEnableAnimations)();
    const { sharp, disabled, size, hasHoverEffect, border, } = (0, card_context_1.useCardConfiguration)();
    const { onMouseEnter, onMouseLeave } = (0, card_context_1.useCardEventHandlers)();
    const { thumbnails, decorators } = partitionChildren(children);
    const checkbox = decorators.find(decorator => decorator.type === card_checkbox_1.CardCheckbox);
    const _selected = checkbox ? !!checkbox.props.selected : selected;
    const titleId = React.useId();
    const descriptionId = React.useId();
    const cardButtonAriaLabelledBy = props.buttonAriaLabelledBy || (!!title && !props.buttonAriaLabel ? titleId : undefined);
    const predefinedThumbnailSizes = {
        small: metrics_1.baseUnit * 7,
        medium: metrics_1.baseUnit * 9,
    };
    const thumbnailHeight = thumbnailSize
        ? typeof thumbnailSize === 'number'
            ? thumbnailSize
            : predefinedThumbnailSizes[thumbnailSize]
        : predefinedThumbnailSizes[size];
    return ((0, jsx_runtime_1.jsx)(badge_container_1.ExtendedBadgeVisibilityTrigger, { tagName: "div", role: "group", className: (0, classnames_1.default)(card_css_1.default.horizontalCard, {
            [card_css_1.default.cardHoverTrigger]: hasHoverEffect || selectionIsPrimaryAction,
            [card_css_1.default.selectable]: checkbox || selectionIsPrimaryAction,
            [card_css_1.default.selectableBorderOnHover]: selectionIsPrimaryAction,
            [card_css_1.default.selected]: _selected,
            [card_css_1.default.animated]: enableAnimations,
            [card_css_1.default.disabled]: disabled,
            [card_css_1.default.roundBorders]: hasHoverEffect,
            [card_css_1.default.bleedX]: bleedX,
        }), onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, ariaLabelledBy: title ? titleId : undefined, ariaDescribedBy: description ? descriptionId : undefined, children: (0, jsx_runtime_1.jsxs)(badge_container_1.BadgeContainer, { paddingStyle: size === 'medium' ? 'standard' : 'compact', className: card_css_1.default.cardArea, children: [(0, jsx_runtime_1.jsxs)("div", { className: card_css_1.default.article, children: [(0, jsx_runtime_1.jsx)("div", { style: {
                                height: `${thumbnailHeight}px`,
                                width: `${thumbnailHeight}px`,
                            }, className: (0, classnames_1.default)(card_css_1.default.thumbnailContainer, {
                                [card_css_1.default.cardBorder]: border,
                                [card_css_1.default.roundBorders]: !sharp,
                            }), children: thumbnails }), (0, jsx_runtime_1.jsx)(layout_1.Spacer, { size: "1.5u", direction: "horizontal" }), (0, jsx_runtime_1.jsx)(card_content_1.CardContent, { title: title, description: description, preTitle: preTitle, titleId: titleId, descriptionId: descriptionId })] }), (0, jsx_runtime_1.jsx)(InternalCardButton, { href: href, target: target, onClick: onClick, ariaControls: ariaControls, ariaHasPopup: ariaHasPopup, ariaExpanded: ariaExpanded, buttonAriaLabel: buttonAriaLabel, buttonAriaLabelledBy: cardButtonAriaLabelledBy, trackHoverState: true, buttonId: buttonId, buttonRef: buttonRef, disabled: disabled, draggable: draggable, onDragStart: onDragStart, onContextMenu: onContextMenu }), decorators] }) }));
});
const CardDecorator = ({ children }) => (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: children });
exports.CardDecorator = CardDecorator;
const InternalCardButton = (0, mobx_react_1.observer)(function InternalCardButton(props) {
    const { ariaControls, ariaHasPopup, ariaExpanded, buttonAriaLabelledBy, href, target, buttonAriaLabel, draggable, disabled, onDragStart, buttonId, buttonRef, trackHoverState, onContextMenu, } = props;
    const cardEventHandlers = (0, card_context_1.useCardEventHandlers)();
    const eventHandlers = {
        ...cardEventHandlers,
        onMouseEnter: trackHoverState ? cardEventHandlers.onMouseEnter : undefined,
        onMouseLeave: trackHoverState ? cardEventHandlers.onMouseLeave : undefined,
    };
    if (!(href || props.onClick)) {
        if (eventHandlers.onMouseEnter || eventHandlers.onMouseLeave) {
            return ((0, jsx_runtime_1.jsx)(
                "div",
                { role: "none", className: card_css_1.default.cardButton, onMouseEnter: eventHandlers.onMouseEnter, onMouseLeave: eventHandlers.onMouseLeave }
            ));
        }
        return null;
    }
    if (href) {
        return ((0, jsx_runtime_1.jsx)(button_1.BasicButtonLink, { href: href, target: target, className: card_css_1.default.cardButton, onClick: props.onClick, ariaControls: ariaControls, ariaHasPopup: ariaHasPopup, disclosure: !!ariaHasPopup, active: ariaExpanded, ariaLabelledBy: buttonAriaLabelledBy, ariaLabel: buttonAriaLabel, disabled: disabled, draggable: draggable, onMouseEnter: eventHandlers.onMouseEnter, onMouseLeave: eventHandlers.onMouseLeave, onDragStart: onDragStart, onContextMenu: onContextMenu, buttonRef: buttonRef }));
    }
    const onClick = (e) => {
        var _a;
        if (!disabled) {
            (_a = props.onClick) === null || _a === void 0 ? void 0 : _a.call(props, e);
        }
    };
    const onKeyUp = (e) => {
        if (!disabled && e.key === ' ') {
            e.preventDefault();
            onClick(e);
        }
    };
    const onKeyDown = (e) => {
        if (!disabled) {
            if (e.key === ' ') {
                e.preventDefault();
            }
            else if (e.key === 'Enter') {
                e.preventDefault();
                onClick(e);
            }
        }
    };
    return ((0, jsx_runtime_1.jsx)("div", { role: "button", "aria-disabled": disabled || undefined, "aria-controls": props.ariaControls, "aria-haspopup": props.ariaHasPopup, "aria-expanded": props.ariaExpanded, "aria-pressed": props.ariaPressed, "aria-label": props.buttonAriaLabelledBy ? undefined : props.buttonAriaLabel, "aria-labelledby": props.buttonAriaLabelledBy, className: (0, classnames_1.default)(card_css_1.default.divButton, card_css_1.default.cardButton, {
            [card_css_1.default.hideOutline]: access_mode_state_1.accessModeState.isMouseMode,
        }), draggable: draggable, id: buttonId, onClick: onClick, onContextMenu: onContextMenu, onMouseDown: eventHandlers.onMouseDown, onMouseUp: eventHandlers.onMouseUp, onMouseEnter: eventHandlers.onMouseEnter, onMouseLeave: eventHandlers.onMouseLeave, onFocus: eventHandlers.onFocus, onBlur: eventHandlers.onBlur, onKeyUp: onKeyUp, onKeyDown: onKeyDown, onDragStart: onDragStart, ref: buttonRef, tabIndex: 0 }));
});
function partitionChildren(children) {
    const thumbnails = [];
    const decorators = [];
    React.Children.toArray(children).forEach((child) => {
        if (React.isValidElement(child)) {
            if (isCardDecorator(child)) {
                decorators.push(child);
            }
            else {
                thumbnails.push(child);
            }
        }
    });
    return { thumbnails, decorators };
}
const cardDecorators = [card_bottom_badge_1.CardBottomBadge, card_button_1.CardButtonGroup, card_checkbox_1.CardCheckbox, exports.CardDecorator];
const isCardDecorator = ({ type }) => cardDecorators.includes(type);
