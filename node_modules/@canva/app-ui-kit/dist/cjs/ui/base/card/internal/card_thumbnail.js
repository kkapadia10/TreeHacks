"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CardVideoThumbnail = exports.CardImageThumbnail = exports.CardIconThumbnail = exports.CardPlaceholder = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const delay_1 = require('../../../../base/delay');
const classnames_1 = require("classnames");
const mobx_1 = require("mobx");
const mobx_react_1 = require("mobx-react");
const React = require("react");
const supports_animation_1 = require('../../animation/supports_animation');
const provider_1 = require('../../provider/provider');
const icon_thumbnail_1 = require('../../thumbnail/icon_thumbnail/icon_thumbnail');
const image_1 = require('../../thumbnail/image/image');
const image_thumbnail_1 = require('../../thumbnail/image_thumbnail/image_thumbnail');
const video_1 = require('../../video/video');
const card_css_1 = require("../card.css");
const card_context_1 = require("./card_context");
const TRANSPARENT_IMAGE = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';
exports.CardPlaceholder = image_thumbnail_1.ImagePlaceholder;
const CardIconThumbnail = (props) => ((0, jsx_runtime_1.jsx)(icon_thumbnail_1.IconThumbnail, { Icon: props.Icon, size: props.size, tone: "secondary" }));
exports.CardIconThumbnail = CardIconThumbnail;
exports.CardImageThumbnail = React.memo(function CardImageThumbnail(props) {
    const { ImageComponent = image_1.Image } = props;
    const { sharp } = (0, card_context_1.useCardConfiguration)();
    return ((0, jsx_runtime_1.jsx)(image_thumbnail_1.ImageThumbnail, { ...props, src: props.url, border: false, ImageComponent: ({ ...imageProps }) => {
            var _a;
            return ((0, jsx_runtime_1.jsx)(ImageComponent, { ...imageProps, className: (0, classnames_1.default)(props.className, card_css_1.default.image, {
                    [card_css_1.default.roundBorders]: !((_a = props.sharp) !== null && _a !== void 0 ? _a : sharp),
                }), crossOrigin: props.crossOrigin, src: props.url, alt: props.alt || '', elementTiming: props.elementTiming }));
        } }));
});
exports.CardImageThumbnail.displayName = 'CardImageThumbnail';
exports.CardVideoThumbnail = (0, mobx_react_1.observer)(React.forwardRef(function CardVideoThumbnail(props, ref) {
    var _a;
    const { className, loadVideo = simpleLoadVideo, VideoComponent = video_1.Video, ImageComponent, videoUrl, videoLoadingState, imageUrl, imageLoadingState, imageFallback, imagePlaceholder, imageAlt, } = props;
    const config = (0, card_context_1.useCardConfiguration)();
    const isFocused = (0, card_context_1.useCardFocus)();
    const autoplayVideos = (0, provider_1.useAutoplayVideos)() || 'ADAPTIVE';
    const prefersReducedMotion = (0, supports_animation_1.usePrefersReducedMotion)();
    const enableAutoplay = (!prefersReducedMotion && autoplayVideos === 'ADAPTIVE') || autoplayVideos === 'AUTOPLAY';
    const sharp = (_a = props.sharp) !== null && _a !== void 0 ? _a : config.sharp;
    const whenToPlay = imageUrl == null
        ? 'always'
        : props.whenToPlay === 'always' && enableAutoplay
            ? props.whenToPlay
            : 'on-hover';
    const isHovered = (0, card_context_1.useCardHover)({ track: whenToPlay === 'on-hover' });
    const store = (0, mobx_react_1.useLocalObservable)(() => ({
        videoLoadingState: 'loading',
        imageLoadingState: imageUrl == null ? 'loaded' : imageLoadingState == null ? 'loading' : imageLoadingState,
        playState: 'pause',
        setPlayState: (0, mobx_1.action)((value) => {
            store.playState = value;
        }),
        setImageLoadingState: (0, mobx_1.action)((imageLoadingState) => {
            store.imageLoadingState = imageLoadingState;
        }),
        setVideoLoadingState: (0, mobx_1.action)((videoLoadingState) => {
            store.videoLoadingState = videoLoadingState;
        }),
    }));
    const { setPlayState } = store;
    React.useEffect(() => (0, mobx_1.autorun)(() => {
        if (whenToPlay === 'always' && store.playState !== 'play') {
            setPlayState('play');
        }
    }), [whenToPlay, store.playState, setPlayState]);
    React.useEffect(() => (0, mobx_1.autorun)(() => {
        if (whenToPlay === 'on-hover') {
            if ((isHovered || isFocused) && store.playState !== 'play') {
                setPlayState('play');
            }
            else if (!isHovered && !isFocused && store.playState === 'play') {
                setPlayState('pause');
            }
        }
    }), [whenToPlay, isHovered, isFocused, store.playState, setPlayState]);
    const renderVideoThumbnail = React.useCallback((videoUrl_) => {
        const renderVideo = (loadingState) => loadingState === 'loaded' && ((0, jsx_runtime_1.jsx)(VideoComponent, { autoPlay: true, className: (0, classnames_1.default)(card_css_1.default.video, className, {
                [card_css_1.default.roundBorders]: !(sharp !== null && sharp !== void 0 ? sharp : config.sharp),
            }), controls: false, draggable: false, loop: true, muted: true, playsInline: true, ref: ref, src: videoUrl_, 
            poster: isIosCanvaEditor() ? TRANSPARENT_IMAGE : undefined }));
        if (videoLoadingState == null && store.videoLoadingState === 'loading') {
            const delay = whenToPlay === 'on-hover' ? 150 : 0;
            return ((0, jsx_runtime_1.jsx)(LoadVideo, { url: videoUrl_, delay: delay, loadVideo: loadVideo, callback: store.setVideoLoadingState, children: loadingState => renderVideo(loadingState) }));
        }
        return renderVideo(videoLoadingState || store.videoLoadingState);
    }, [
        ref,
        videoLoadingState,
        store.videoLoadingState,
        whenToPlay,
        sharp,
        config.sharp,
        className,
        VideoComponent,
        loadVideo,
        store.setVideoLoadingState,
    ]);
    const renderImageThumbnail = React.useCallback((imageUrl_) => ((0, jsx_runtime_1.jsx)(exports.CardImageThumbnail, { url: imageUrl_, loadingState: imageLoadingState, fallback: imageFallback, placeholder: imagePlaceholder, sharp: sharp, className: className, ImageComponent: ImageComponent, alt: imageAlt, onImageLoad: store.setImageLoadingState })), [
        imageLoadingState,
        imageFallback,
        imagePlaceholder,
        store.setImageLoadingState,
        className,
        sharp,
        ImageComponent,
        imageAlt,
    ]);
    return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [imageUrl != null && renderImageThumbnail(imageUrl), store.playState === 'play'
                && ((imageLoadingState && imageLoadingState !== 'loading')
                    || store.imageLoadingState !== 'loading')
                && renderVideoThumbnail(videoUrl)] }));
}));
function simpleLoadVideo(url) {
    return new Promise((resolve, reject) => {
        const onLoad = () => {
            video.removeEventListener('loadeddata', onLoad);
            resolve(video);
        };
        const onError = () => {
            video.removeEventListener('error', onError);
            reject();
        };
        const video = document.createElement('video');
        video.src = url;
        video.addEventListener('error', onError);
        video.addEventListener('loadeddata', onLoad);
        video.load();
    });
}
const LoadVideo = (0, mobx_react_1.observer)(function LoadVideo({ url, delay, callback, loadVideo = simpleLoadVideo, children, }) {
    const store = (0, mobx_react_1.useLocalObservable)(() => ({
        loadingState: 'loading',
        setLoadingState: (0, mobx_1.action)((loadingState) => {
            store.loadingState = loadingState;
        }),
    }));
    React.useEffect(() => {
        (async () => {
            await (0, delay_1.delay)(delay);
            callback && callback('loading');
            await loadVideo(url)
                .then(() => {
                store.setLoadingState('loaded');
                callback && callback('loaded');
            })
                .catch(() => {
                store.setLoadingState('error');
                callback && callback('error');
            });
        })();
    }, [url, store, callback, loadVideo, delay]);
    return (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: children(store.loadingState) });
});
const isIosCanvaEditor = () => {
    return (navigator != null
        && navigator.userAgent.indexOf('canvaeditor') >= 0 && !!navigator.userAgent.match(/iphone|ipad/gi));
};
