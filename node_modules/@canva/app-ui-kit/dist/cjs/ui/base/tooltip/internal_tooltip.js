"use strict";

var TriggeredTooltip_1;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StatelessTooltip = exports.TooltipArrow = exports.TooltipContent = exports.TriggeredTooltip = exports.InternalTooltip = void 0;
const tslib_1 = require("tslib");
const jsx_runtime_1 = require("react/jsx-runtime");
const classnames_1 = require("classnames");
const mobx = require("mobx");
const mobxReact = require("mobx-react");
const React = require("react");
const access_mode_state_1 = require('../a11y/access_mode_state/access_mode_state');
const identifier_1 = require('../a11y/identifier/identifier');
const pointer_input_state_1 = require('../a11y/pointer_input_state/pointer_input_state');
const screen_reader_content_1 = require('../a11y/screen_reader_content/screen_reader_content');
const layer_1 = require('../layer/layer');
const layout_1 = require('../layout/layout');
const pin_1 = require('../pin/pin');
const pin_motion_wrapper_1 = require('../pin/pin_motion_wrapper');
const responsive_image_1 = require('../responsive_image/responsive_image');
const shortcut_1 = require('../shortcut/shortcut');
const theme_1 = require('../theme/theme');
const typography_1 = require('../typography/typography');
const tooltip_css_1 = require("./tooltip.css");
const tooltip_presenter_1 = require("./tooltip_presenter");
function isRenderTrigger(children) {
  return typeof children === 'function';
}
const MOTION_DURATION_MS = 150;
const FADE_IN_DELAY = 150;
const FADE_OUT_DELAY = 0;
function InternalTooltip(props) {
  const {
    label,
    description,
    disabled = false,
    mode
  } = props;
  const timer = React.useRef(undefined);
  const [open, setOpen] = React.useState(false);
  const openRef = React.useRef(false);
  const withDelay = React.useCallback((cb, delay) => {
    window.clearTimeout(timer.current);
    if (!delay) {
      return Promise.resolve(cb());
    }
    return new Promise(resolve => {
      timer.current = window.setTimeout(() => {
        cb();
        resolve();
      }, delay);
    });
  }, []);
  const showTooltip = React.useCallback((delay = FADE_IN_DELAY) => {
    return withDelay(() => setOpen(true), delay);
  }, [withDelay]);
  const hideTooltip = React.useCallback(() => {
    return withDelay(() => setOpen(false), FADE_OUT_DELAY);
  }, [withDelay]);
  const onDocumentKeydown = React.useCallback(e => {
    if (e.key === 'Escape' && openRef.current) {
      e.stopPropagation();
      hideTooltip();
    }
  }, [hideTooltip]);
  React.useEffect(() => {
    document.addEventListener('keydown', onDocumentKeydown, {
      capture: true
    });
    return () => {
      document.removeEventListener('keydown', onDocumentKeydown, {
        capture: true
      });
    };
  }, [onDocumentKeydown]);
  React.useEffect(() => {
    openRef.current = open;
  }, [open]);
  React.useEffect(() => {
    if (disabled) {
      hideTooltip();
    }
  }, [disabled, hideTooltip]);
  const screenReaderLabel = description != null ? `${label}: ${description}` : label;
  if (mode === 'toggletip') {
    return (0, jsx_runtime_1.jsx)(BaseToggleTip, {
      ...props,
      hideTooltip: hideTooltip,
      open: open,
      screenReaderLabel: screenReaderLabel,
      showTooltip: showTooltip,
      disabled: disabled
    });
  }
  return (0, jsx_runtime_1.jsx)(BaseTooltip, {
    ...props,
    hideTooltip: hideTooltip,
    open: open,
    screenReaderLabel: screenReaderLabel,
    showTooltip: showTooltip,
    disabled: disabled
  });
}
exports.InternalTooltip = InternalTooltip;
function BaseTooltip({
  children,
  closeOnClick = true,
  disabled,
  forwardedRef,
  hideTooltip,
  open,
  screenReaderLabel,
  showTooltip,
  ...props
}) {
  const [tooltipId] = (0, identifier_1.useIdentifiers)(1);
  const isMouseInput = (0, pointer_input_state_1.useIsMouseInput)();
  const isMouseAccessMode = (0, access_mode_state_1.useIsMouseAccessMode)();
  const showTooltipIfMouseInput = React.useCallback(() => {
    if (disabled || !isMouseInput) {
      return;
    }
    showTooltip();
  }, [disabled, showTooltip, isMouseInput]);
  const showTooltipIfKeyboardMode = React.useCallback(() => {
    if (disabled || isMouseAccessMode) {
      return;
    }
    showTooltip(0);
  }, [disabled, showTooltip, isMouseAccessMode]);
  const renderedChildren = React.useMemo(() => {
    if (isRenderTrigger(children)) {
      return children({
        onBlur: hideTooltip,
        onFocus: showTooltipIfKeyboardMode,
        onMouseDown: closeOnClick ? hideTooltip : undefined,
        onMouseEnter: showTooltipIfMouseInput,
        onMouseLeave: hideTooltip,
        tabIndex: 0,
        tooltipId
      });
    }
  }, [children, closeOnClick, hideTooltip, showTooltipIfKeyboardMode, showTooltipIfMouseInput, tooltipId]);
  if (isRenderTrigger(children)) {
    return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, {
        children: [(0, jsx_runtime_1.jsx)(StatelessTooltip, {
          ...props,
          open: open,
          children: renderedChildren
        }), (0, jsx_runtime_1.jsx)(screen_reader_content_1.ScreenReaderContent, {
          id: tooltipId,
          children: screenReaderLabel
        })]
      }));
  }
  return closeOnClick ?
  (0, jsx_runtime_1.jsx)("div", {
    onMouseEnter: showTooltipIfMouseInput,
    onMouseLeave: hideTooltip,
    onMouseDown: hideTooltip,
    ref: forwardedRef,
    children: (0, jsx_runtime_1.jsx)(StatelessTooltip, {
      ...props,
      children: children,
      open: open
    })
  }) : (0, jsx_runtime_1.jsx)("div", {
    onMouseEnter: showTooltipIfMouseInput,
    onMouseLeave: hideTooltip,
    ref: forwardedRef,
    children: (0, jsx_runtime_1.jsx)(StatelessTooltip, {
      ...props,
      children: children,
      open: open
    })
  });
}
function BaseToggleTip({
  open,
  hideTooltip,
  showTooltip,
  children,
  screenReaderLabel,
  ...props
}) {
  const [renderScreenReaderLabel, setRenderScreenReaderLabel] = React.useState(false);
  const showToggletip = React.useCallback(async e => {
    e.currentTarget.focus({
      preventScroll: true
    });
    setRenderScreenReaderLabel(false);
    await showTooltip(0);
    setTimeout(() => setRenderScreenReaderLabel(true), 50);
  }, [showTooltip, setRenderScreenReaderLabel]);
  const renderedChildren = React.useMemo(() => {
    return children({
      onClick: showToggletip,
      onBlur: hideTooltip
    });
  }, [children, hideTooltip, showToggletip]);
  return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, {
      children: [(0, jsx_runtime_1.jsx)(StatelessTooltip, {
        ...props,
        open: open,
        children: renderedChildren
      }), (0, jsx_runtime_1.jsx)(screen_reader_content_1.ScreenReaderContent, {
        role: "status",
        ariaRelevant: "all",
        children: renderScreenReaderLabel ? screenReaderLabel : ''
      })]
    }));
}
let TriggeredTooltip = TriggeredTooltip_1 = class TriggeredTooltip extends React.Component {
  constructor() {
    super(...arguments);
    this.presenter = new tooltip_presenter_1.TooltipPresenter();
  }
  render() {
    const {
      state,
      ...rest
    } = this.props;
    return (0, jsx_runtime_1.jsx)(StatelessTooltip, {
      ...rest,
      open: state.open,
      mode: "tooltip"
    });
  }
  componentDidMount() {
    mobxReact.disposeOnUnmount(this, mobx.autorun(() => {
      if (this.props.autoclose && this.props.state.open) {
        this.presenter.hideTooltip(this.props, TriggeredTooltip_1.fadeOutDelay);
      }
    }));
  }
};
exports.TriggeredTooltip = TriggeredTooltip;
TriggeredTooltip.defaultProps = {
  autoclose: true
};
TriggeredTooltip.fadeOutDelay = 2000;
exports.TriggeredTooltip = TriggeredTooltip = TriggeredTooltip_1 = tslib_1.__decorate([mobxReact.observer], TriggeredTooltip);
function TooltipContent(props) {
  const {
    id,
    withLayout,
    label,
    description,
    align = 'center',
    shortcut,
    lineClamp,
    thumbnail,
    mode
  } = props;
  const shortcutElement = shortcut ? (0, jsx_runtime_1.jsx)(shortcut_1.Shortcut, {
    className: tooltip_css_1.default.shortcut,
    combination: shortcut,
    size: "small"
  }) : null;
  const lines = lineClamp ? [label] : label.trim().split('\n');
  const labelContent = lines.length === 1 ? (0, jsx_runtime_1.jsx)(typography_1.Text, {
    size: "small",
    weight: "bold",
    tagName: "div",
    lineClamp: lineClamp,
    tone: "primary",
    className: tooltip_css_1.default.label,
    alignment: align,
    id: id,
    children: label
  }) : (0, jsx_runtime_1.jsx)("div", {
    className: tooltip_css_1.default.label,
    id: id,
    children: lines.map((line, i) => (0, jsx_runtime_1.jsx)(typography_1.Text, {
      size: "small",
      alignment: align,
      tone: "primary",
      children: line
    }, i))
  });
  const descriptionContent = description != null && (0, jsx_runtime_1.jsx)(typography_1.Text, {
    size: "small",
    tone: "secondary",
    alignment: align,
    className: tooltip_css_1.default.description,
    children: description
  });
  const thumbnailContent = thumbnail != null && (0, jsx_runtime_1.jsx)("div", {
    className: tooltip_css_1.default.thumbnail,
    children: typeof thumbnail === 'string' ? (0, jsx_runtime_1.jsx)("img", {
      src: thumbnail,
      alt: ""
    }) : (0, jsx_runtime_1.jsx)(responsive_image_1.PixelDensityResponsiveImage, {
      sources: thumbnail,
      alt: ""
    })
  });
  const ariaProps = mode === 'toggletip' ? {} : {
    ['role']: 'tooltip'
  };
  return (0, jsx_runtime_1.jsx)(theme_1.ThemeBoundary, {
    light: "dark",
    dark: "dark",
    classicLight: "dark",
    classicDark: "dark",
    children: ({
      className
    }) => (0, jsx_runtime_1.jsx)("div", {
      className: (0, classnames_1.default)(className, tooltip_css_1.default.tooltip, {
        [tooltip_css_1.default.tooltipLayout]: withLayout
      }),
      ...ariaProps,
      children: (0, jsx_runtime_1.jsxs)(layout_1.Rows, {
        spacing: "0",
        align: align,
        children: [thumbnailContent, labelContent, descriptionContent, shortcutElement]
      })
    })
  });
}
exports.TooltipContent = TooltipContent;
function TooltipArrow({
  withLayout
}) {
  return (0, jsx_runtime_1.jsxs)("svg", {
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    className: (0, classnames_1.default)(tooltip_css_1.default.arrow, {
      [tooltip_css_1.default.arrowLayout]: withLayout
    }),
    children: [(0, jsx_runtime_1.jsx)("path", {
      d: "M15 9L10.3972 4.67335C9.04995 3.40695 6.95006 3.40695 5.60282 4.67335L1 9L15 9Z",
      className: tooltip_css_1.default.arrowInner
    }), (0, jsx_runtime_1.jsx)("path", {
      d: "M15 9L10.3972 4.67335C9.04995 3.40695 6.95006 3.40695 5.60282 4.67335L1 9L2.46004 9L6.28773 5.40198C7.25004 4.4974 8.74996 4.4974 9.71228 5.40198L13.54 9L15 9Z",
      className: tooltip_css_1.default.arrowOutline
    })]
  });
}
exports.TooltipArrow = TooltipArrow;
function StatelessTooltip({
  children,
  placement = 'bottom',
  open,
  arrow = true,
  refObj,
  overflowBoundariesElement,
  direction,
  expandTooltipWrapper,
  ...contentProps
}) {
  const contentElement = (0, jsx_runtime_1.jsx)(TooltipContent, {
    withLayout: true,
    ...contentProps
  });
  const arrowElement = arrow ? (0, jsx_runtime_1.jsx)(TooltipArrow, {
    withLayout: true
  }) : null;
  return (0, jsx_runtime_1.jsx)(pin_1.Pin, {
    placement: placement,
    level: layer_1.LayerLevel.TOOLTIPS,
    overflowBoundariesElement: overflowBoundariesElement,
    content: contentElement,
    arrow: arrowElement,
    MotionWrapper: TooltipMotionWrapper,
    open: open,
    noPointerEventsForDisabledChildren: true,
    refObj: refObj,
    direction: direction,
    expandChildren: expandTooltipWrapper,
    children: children
  });
}
exports.StatelessTooltip = StatelessTooltip;
const TooltipMotionWrapper = (0, pin_motion_wrapper_1.createPinMotionWrapper)({
  enterStyle: {
    opacity: 0
  },
  enteredStyle: {
    opacity: 1
  },
  leaveStyle: {
    opacity: 0
  },
  style: {
    transition: `opacity ${MOTION_DURATION_MS}ms ease-in-out`
  },
  durationMs: MOTION_DURATION_MS
});