"use strict";

const makeObservable = require('../../../base/make_observable/make_observable').makeObservable;
var TriggeredTooltip_1;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FloatingTooltip = exports.TriggeredTooltip = exports.Tooltip = exports.TooltipContent = exports.TooltipArrow = void 0;
const tslib_1 = require("tslib");
const jsx_runtime_1 = require("react/jsx-runtime");
const mobx = require("mobx");
const mobxReact = require("mobx-react");
const React = require("react");
const metrics_1 = require('../metrics/metrics');
const internal_tooltip_1 = require("./internal_tooltip");
Object.defineProperty(exports, "TooltipArrow", {
  enumerable: true,
  get: function () {
    return internal_tooltip_1.TooltipArrow;
  }
});
Object.defineProperty(exports, "TooltipContent", {
  enumerable: true,
  get: function () {
    return internal_tooltip_1.TooltipContent;
  }
});
const tooltip_presenter_1 = require("./tooltip_presenter");
exports.Tooltip = React.forwardRef((props,
ref) => (0, jsx_runtime_1.jsx)(internal_tooltip_1.InternalTooltip, {
  ...props,
  forwardedRef: ref
}));
exports.Tooltip.displayName = 'Tooltip';
let TriggeredTooltip = TriggeredTooltip_1 = class TriggeredTooltip extends React.Component {
  constructor() {
    super(...arguments);
    this.presenter = new tooltip_presenter_1.TooltipPresenter();
  }
  render() {
    const {
      state,
      ...rest
    } = this.props;
    return (0, jsx_runtime_1.jsx)(internal_tooltip_1.StatelessTooltip, {
      ...rest,
      open: state.open,
      mode: "tooltip"
    });
  }
  componentDidMount() {
    mobxReact.disposeOnUnmount(this, mobx.autorun(() => {
      if (this.props.autoclose && this.props.state.open) {
        this.presenter.hideTooltip(this.props, TriggeredTooltip_1.fadeOutDelay);
      }
    }));
  }
};
exports.TriggeredTooltip = TriggeredTooltip;
TriggeredTooltip.defaultProps = {
  autoclose: true
};
TriggeredTooltip.fadeOutDelay = 2000;
exports.TriggeredTooltip = TriggeredTooltip = TriggeredTooltip_1 = tslib_1.__decorate([mobxReact.observer], TriggeredTooltip);
let FloatingTooltip = class FloatingTooltip extends React.Component {
  static _makeObservable(instance) {
    makeObservable(instance, {
      info: mobx.observable.ref
    });
  }
  constructor() {
    super(...arguments);
    FloatingTooltip._makeObservable(this);
    this.refObj = new FloatingTooltipReferenceObject(this);
    this.info = this.props;
  }
  componentDidMount() {
    this.dispose = mobx.reaction(() => this.props, ({
      open,
      label,
      placement,
      direction,
      x,
      y
    }) => open && (this.info = {
      label,
      placement,
      direction,
      x,
      y
    }));
  }
  componentWillUnmount() {
    this.dispose && this.dispose();
  }
  render() {
    const {
      refObj,
      props: {
        arrow,
        open
      },
      info: {
        label,
        placement = 'right-end',
        direction
      }
    } = this;
    return (0, jsx_runtime_1.jsx)(internal_tooltip_1.StatelessTooltip, {
      label: label,
      open: open,
      arrow: !!arrow,
      refObj: refObj,
      placement: placement,
      direction: direction,
      mode: "tooltip"
    });
  }
};
exports.FloatingTooltip = FloatingTooltip;
exports.FloatingTooltip = FloatingTooltip = tslib_1.__decorate([mobxReact.observer], FloatingTooltip);
class FloatingTooltipReferenceObject {
  constructor(tooltip) {
    this.tooltip = tooltip;
  }
  get left() {
    return this.tooltip.info.x - FloatingTooltipReferenceObject.horizontalOffset;
  }
  get top() {
    return this.tooltip.info.y - FloatingTooltipReferenceObject.verticalOffset;
  }
  get width() {
    return 2 * FloatingTooltipReferenceObject.horizontalOffset;
  }
  get height() {
    return 2 * FloatingTooltipReferenceObject.verticalOffset;
  }
  get right() {
    return this.left + this.width;
  }
  get bottom() {
    return this.top + this.height;
  }
  get clientWidth() {
    return this.width;
  }
  get clientHeight() {
    return this.height;
  }
  get x() {
    return this.tooltip.info.x;
  }
  get y() {
    return this.tooltip.info.y;
  }
  toJSON() {
    const {
      bottom,
      height,
      left,
      right,
      top,
      width,
      x,
      y
    } = this;
    return {
      bottom,
      height,
      left,
      right,
      top,
      width,
      x,
      y
    };
  }
  getBoundingClientRect() {
    return this;
  }
}
FloatingTooltipReferenceObject.horizontalOffset = 3 * metrics_1.baseUnit;
FloatingTooltipReferenceObject.verticalOffset = 8 * metrics_1.baseUnit;