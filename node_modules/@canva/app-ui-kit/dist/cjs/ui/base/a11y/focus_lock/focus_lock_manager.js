"use strict";

const makeObservable = require('../../../../base/make_observable/make_observable').makeObservable;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useFocusLockManager = exports.FocusLockManagerContextProvider = void 0;
const tslib_1 = require("tslib");
const mobx = require("mobx");
const mobxReact = require("mobx-react");
const React = require("react");
function isRealFocusLockManager(manager) {
  return manager.kind === 'real';
}
class FakeFocusLockManager {
  constructor() {
    this.kind = 'fake';
    this.surrenderLock = true;
    this.isReady = false;
  }
}
class RealFocusLockManager {
  static _makeObservable(instance) {
    makeObservable(instance, {
      windowToChildrenManagers: mobx.observable.shallow,
      browserWindow: mobx.observable.ref
      ,
      _isReady: mobx.observable.ref,
      _isEnabled: mobx.observable.ref,
      hasEnabledDescendant: mobx.computed,
      isActiveBranch: mobx.computed,
      surrenderLock: mobx.computed,
      isReady: mobx.computed,
      setReady: mobx.action.bound,
      isEnabled: mobx.computed,
      setEnabled: mobx.action.bound,
      setWindow: mobx.action.bound,
      addChildManager: mobx.action.bound,
      removeChildManager: mobx.action.bound
    });
  }
  constructor(parentManager) {
    RealFocusLockManager._makeObservable(this);
    this.parentManager = parentManager;
    this.kind = 'real';
    this.windowToChildrenManagers = new Map();
    this.browserWindow = window;
    this._isReady = false;
    this._isEnabled = false;
  }
  get hasEnabledDescendant() {
    const childManagers = this.windowToChildrenManagers.get(this.browserWindow);
    if (childManagers == null || childManagers.length === 0) {
      return false;
    }
    return childManagers.some(manager => manager.isEnabled || manager.hasEnabledDescendant);
  }
  get isActiveBranch() {
    var _a;
    if (!this.parentManager) {
      return true;
    }
    const childrenManagers = (_a = this.parentManager.windowToChildrenManagers.get(this.browserWindow)) !== null && _a !== void 0 ? _a : [];
    const siblingManagers = childrenManagers.filter(manager => manager !== this);
    const isSelfOrDescendantsEnabled = this.isEnabled || this.hasEnabledDescendant;
    if (siblingManagers == null || siblingManagers.length === 0 || childrenManagers[childrenManagers.length - 1] === this) {
      return this.parentManager.isActiveBranch && isSelfOrDescendantsEnabled;
    } else {
      const selfIndex = childrenManagers.indexOf(this);
      if (selfIndex === -1) {
        return false;
      }
      const hasActiveNewerSiblings = childrenManagers.slice(selfIndex + 1).some(manager => manager.isActiveBranch);
      return !hasActiveNewerSiblings && this.parentManager.isActiveBranch && isSelfOrDescendantsEnabled;
    }
  }
  get surrenderLock() {
    if (!this.isReady) {
      return true;
    }
    if (!this.isActiveBranch) {
      return true;
    }
    return this.hasEnabledDescendant;
  }
  get isReady() {
    return this._isReady;
  }
  setReady() {
    this._isReady = true;
  }
  get isEnabled() {
    return this._isEnabled;
  }
  setEnabled(enabled) {
    this._isEnabled = enabled;
  }
  setWindow(browserWindow) {
    this.browserWindow = browserWindow;
  }
  addChildManager(newManager, browserWindow) {
    var _a;
    const childrenManagers = (_a = this.windowToChildrenManagers.get(browserWindow)) !== null && _a !== void 0 ? _a : [];
    this.windowToChildrenManagers.set(browserWindow, [...childrenManagers, newManager]);
  }
  removeChildManager(manager, browserWindow) {
    const childrenManagers = this.windowToChildrenManagers.get(browserWindow);
    if (!childrenManagers) {
      return;
    }
    const resultManagers = childrenManagers.filter(childManager => childManager !== manager);
    if (resultManagers.length === 0) {
      this.windowToChildrenManagers.delete(browserWindow);
    } else {
      this.windowToChildrenManagers.set(browserWindow, resultManagers);
    }
  }
}
function createFocusLockManager(parentManager) {
  if (typeof window !== 'undefined') {
    return new RealFocusLockManager(parentManager);
  } else {
    return new FakeFocusLockManager();
  }
}
const FocusLockManagerContext = React.createContext(createFocusLockManager());
exports.FocusLockManagerContextProvider = FocusLockManagerContext.Provider;
function useFocusLockManager({
  browserWindow,
  disabled
}) {
  const parentManager = React.useContext(FocusLockManagerContext);
  const manager = mobxReact.useLocalObservable(() => {
    if (isRealFocusLockManager(parentManager)) {
      return new RealFocusLockManager(parentManager);
    } else {
      return new FakeFocusLockManager();
    }
  });
  React.useLayoutEffect(() => {
    if (
    !isRealFocusLockManager(manager) || !isRealFocusLockManager(parentManager) || browserWindow == null) {
      return;
    }
    manager.setWindow(browserWindow);
    parentManager.addChildManager(manager, browserWindow);
    manager.setReady();
    return () => {
      parentManager.removeChildManager(manager, browserWindow);
    };
  }, [browserWindow, manager, parentManager]);
  React.useLayoutEffect(() => {
    if (
    !isRealFocusLockManager(manager) || !isRealFocusLockManager(parentManager) || browserWindow == null) {
      return;
    }
    manager.setEnabled(!disabled);
  }, [browserWindow, disabled, manager, parentManager]);
  return {
    manager
  };
}
exports.useFocusLockManager = useFocusLockManager;