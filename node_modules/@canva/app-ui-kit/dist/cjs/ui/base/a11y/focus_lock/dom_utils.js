"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.focusPrevElement = exports.focusNextElement = exports.focusWithConditionalDelayHack = exports.findAutoFocusElement = exports.getFocusablesInside = exports.FOCUS_LOCK_EXCEPTED_ATTR = exports.AUTO_FOCUS_ATTR = exports.FOCUS_GUARD_ATTR = void 0;
const focusablesSelector = [
    'button:enabled',
    'select:enabled',
    'textarea:enabled',
    'input:enabled',
    'a[href]',
    'area[href]',
    'summary',
    'iframe',
    'object',
    'embed',
    'audio[controls]',
    'video[controls]',
    '[tabindex]',
    '[contenteditable]',
    '[autofocus]',
].join(',');
exports.FOCUS_GUARD_ATTR = 'data-focus-guard';
exports.AUTO_FOCUS_ATTR = 'data-focus-lock-autofocus';
exports.FOCUS_LOCK_EXCEPTED_ATTR = 'data-focus-lock-excepted';
const isNotFocusGuard = (element) => !element.hasAttribute(exports.FOCUS_GUARD_ATTR);
const isTabbable = (element) => element.getAttribute('tabIndex') !== '-1';
function getFocusablesInside(node) {
    const focusables = Array.from(node.querySelectorAll(focusablesSelector));
    return focusables.filter(isNotFocusGuard).filter(isTabbable);
}
exports.getFocusablesInside = getFocusablesInside;
function findAutoFocusElement(node) {
    const autoFocusGroup = node.querySelector(`[${exports.AUTO_FOCUS_ATTR}='true']`);
    if (!autoFocusGroup) {
        return null;
    }
    const focusables = Array.from(autoFocusGroup.querySelectorAll(focusablesSelector));
    return focusables.length > 0 ? focusables[0] : null;
}
exports.findAutoFocusElement = findAutoFocusElement;
function focusWithConditionalDelayHack(element, options) {
    if (element.tagName === 'INPUT') {
        setTimeout(() => {
            element.focus(options);
        }, 50);
    }
    else {
        element.focus(options);
    }
}
exports.focusWithConditionalDelayHack = focusWithConditionalDelayHack;
function focusNextElement(baseElement, opts = {}) {
    var _a, _b;
    const scope = (_a = opts.scope) !== null && _a !== void 0 ? _a : window.document.body;
    const cycle = (_b = opts.cycle) !== null && _b !== void 0 ? _b : true;
    if (!scope.contains(baseElement)) {
        return;
    }
    const focusables = getFocusablesInside(scope);
    const currentIndex = focusables.findIndex(node => node === baseElement);
    if (currentIndex === -1) {
        return;
    }
    const first = focusables[0];
    const next = currentIndex !== focusables.length - 1
        ? focusables[currentIndex + 1]
        : cycle
            ? first
            : undefined;
    next === null || next === void 0 ? void 0 : next.focus();
}
exports.focusNextElement = focusNextElement;
function focusPrevElement(baseElement, opts = {}) {
    var _a, _b;
    const scope = (_a = opts.scope) !== null && _a !== void 0 ? _a : window.document.body;
    const cycle = (_b = opts.cycle) !== null && _b !== void 0 ? _b : true;
    if (!scope.contains(baseElement)) {
        return;
    }
    const focusables = getFocusablesInside(scope);
    const currentIndex = focusables.findIndex(node => node === baseElement);
    if (currentIndex === -1) {
        return;
    }
    const last = focusables[focusables.length - 1];
    const prev = currentIndex !== 0 ? focusables[currentIndex - 1] : cycle ? last : undefined;
    prev === null || prev === void 0 ? void 0 : prev.focus();
}
exports.focusPrevElement = focusPrevElement;
