"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FocusLock = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const compose_react_refs_1 = require("@seznam/compose-react-refs");
const exists_1 = require('../../../../base/exists');
const mobxReact = require("mobx-react");
const React = require("react");
const use_key_combination_handler_1 = require('../../key_combinations/use_key_combination_handler');
const dom_utils_1 = require("./dom_utils");
const focus_lock_manager_1 = require("./focus_lock_manager");
const FOCUS_GUARD_PROP = {
    [dom_utils_1.FOCUS_GUARD_ATTR]: true,
};
exports.FocusLock = mobxReact.observer(React.forwardRef(function FocusLock({ autoFocus = true, children, className, disabled: propsDisabled = false, lockProps, returnFocus = true, preventScroll = false, makeContainerFocusable = false, onRequestEscape, keyCombinationMap = [], handleKeysOnInputs = true, }, ref) {
    const [browserWindow, setBrowserWindow] = React.useState();
    const previouslyFocusedElement = React.useRef(null);
    const rootRef = React.useRef(null);
    const focusables = React.useRef([]);
    const isFocusablesOutdated = React.useRef(true);
    React.useEffect(() => {
        setBrowserWindow(window);
        previouslyFocusedElement.current = window.document.activeElement;
    }, []);
    React.useLayoutEffect(() => {
        var _a;
        const currentWindow = (_a = rootRef.current) === null || _a === void 0 ? void 0 : _a.ownerDocument.defaultView;
        if (currentWindow && currentWindow !== browserWindow) {
            setBrowserWindow(currentWindow);
            previouslyFocusedElement.current = currentWindow.document.activeElement;
        }
    }, [browserWindow]);
    React.useLayoutEffect(() => {
        if (!propsDisabled && browserWindow) {
            previouslyFocusedElement.current = browserWindow.document.activeElement;
            isFocusablesOutdated.current = true;
        }
    }, [propsDisabled, browserWindow]);
    const { manager } = (0, focus_lock_manager_1.useFocusLockManager)({
        browserWindow,
        disabled: propsDisabled,
    });
    const disabled = propsDisabled || manager.surrenderLock;
    React.useLayoutEffect(() => {
        if (!rootRef.current || disabled) {
            return;
        }
        const observer = new MutationObserver(() => {
            isFocusablesOutdated.current = true;
        });
        observer.observe(rootRef.current, { childList: true, subtree: true });
        return () => {
            observer.disconnect();
        };
    }, [disabled]);
    const regenerateFocusables = React.useCallback(() => {
        if (isFocusablesOutdated.current && rootRef.current) {
            isFocusablesOutdated.current = false;
            focusables.current = (0, dom_utils_1.getFocusablesInside)(rootRef.current);
        }
    }, []);
    const findFirstFocusable = React.useCallback(() => {
        regenerateFocusables();
        if (focusables.current.length > 0) {
            return focusables.current[0];
        }
    }, [regenerateFocusables]);
    const focusFirst = React.useCallback(() => {
        const firstFocusable = findFirstFocusable();
        if (firstFocusable) {
            firstFocusable.focus({ preventScroll });
        }
    }, [preventScroll, findFirstFocusable]);
    const focusLast = React.useCallback(() => {
        regenerateFocusables();
        if (focusables.current.length > 0) {
            focusables.current[focusables.current.length - 1].focus({ preventScroll });
        }
    }, [preventScroll, regenerateFocusables]);
    const onFocusIn = React.useCallback((e) => {
        if (!rootRef.current || e.target == null) {
            return;
        }
        if (isTargetExceptedFromFocusLock(e.target)) {
            return;
        }
        if (e.relatedTarget == null && !rootRef.current.contains(e.target)) {
            focusFirst();
            return;
        }
    }, [focusFirst]);
    const onFocusOut = React.useCallback((e) => {
        if (!rootRef.current || manager.surrenderLock) {
            return;
        }
        if (!e.relatedTarget
            || rootRef.current.contains(e.relatedTarget)
            || isTargetExceptedFromFocusLock(e.relatedTarget)) {
            return;
        }
        if (e.target && rootRef.current.contains(e.target)) {
            e.target.focus({ preventScroll });
            return;
        }
        focusFirst();
    }, [focusFirst, manager, preventScroll]);
    React.useLayoutEffect(() => {
        if (!disabled && browserWindow) {
            browserWindow.document.addEventListener('focusout', onFocusOut, true);
            browserWindow.document.addEventListener('focusin', onFocusIn, true);
            return () => {
                browserWindow.document.removeEventListener('focusout', onFocusOut, true);
                browserWindow.document.removeEventListener('focusin', onFocusIn, true);
            };
        }
    }, [browserWindow, disabled, onFocusIn, onFocusOut]);
    React.useLayoutEffect(() => {
        if (!manager.isReady || browserWindow == null) {
            return;
        }
        if (propsDisabled || manager.surrenderLock || !rootRef.current) {
            return;
        }
        const { activeElement } = browserWindow.document;
        if (rootRef.current.contains(activeElement)) {
            return;
        }
        if (!autoFocus) {
            activeElement === null || activeElement === void 0 ? void 0 : activeElement.blur();
            return;
        }
        const autoFocusElement = (rootRef.current ? (0, dom_utils_1.findAutoFocusElement)(rootRef.current) : null) || findFirstFocusable();
        if (autoFocusElement) {
            (0, dom_utils_1.focusWithConditionalDelayHack)(autoFocusElement, { preventScroll });
        }
    }, [
        autoFocus,
        browserWindow,
        findFirstFocusable,
        manager.isReady,
        manager,
        preventScroll,
        propsDisabled,
    ]);
    const returnFocusRef = React.useRef(returnFocus && !disabled);
    returnFocusRef.current = returnFocus && !disabled;
    React.useEffect(() => {
        if (!propsDisabled) {
            const el = previouslyFocusedElement.current;
            return () => {
                if (returnFocusRef.current && !manager.surrenderLock && el) {
                    el.focus({ preventScroll });
                }
            };
        }
    }, [propsDisabled]);
    const finalKeyCombinationMap = React.useMemo(() => {
        const escapeKeyHandler = onRequestEscape && !disabled
            ? [
                'Escape',
                (e) => {
                    e.stopPropagation();
                    onRequestEscape();
                },
            ]
            : undefined;
        return [escapeKeyHandler, ...keyCombinationMap].filter(exists_1.exists);
    }, [disabled, keyCombinationMap, onRequestEscape]);
    const { ref: keyHandlerRef } = (0, use_key_combination_handler_1.useKeyCombinationHandler)(finalKeyCombinationMap, {
        handleInputs: handleKeysOnInputs,
    });
    return ((0, jsx_runtime_1.jsx)(focus_lock_manager_1.FocusLockManagerContextProvider, { value: manager, children: (0, jsx_runtime_1.jsxs)("div", { ...lockProps, className: className, ref: (0, compose_react_refs_1.default)(rootRef, ref, keyHandlerRef), tabIndex: makeContainerFocusable ? -1 : undefined, children: [(0, jsx_runtime_1.jsx)("div", { onFocus: disabled ? undefined : focusLast, tabIndex: disabled ? undefined : 0, ...FOCUS_GUARD_PROP }), children, (0, jsx_runtime_1.jsx)("div", { onFocus: disabled ? undefined : focusFirst, tabIndex: disabled ? undefined : 0, ...FOCUS_GUARD_PROP })] }) }));
}));
function isTargetExceptedFromFocusLock(target) {
    if ('hasAttribute' in target) {
        return target.hasAttribute(dom_utils_1.FOCUS_LOCK_EXCEPTED_ATTR);
    }
    return false;
}
