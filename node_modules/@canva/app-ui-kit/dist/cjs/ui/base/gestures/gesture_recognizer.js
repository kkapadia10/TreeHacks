"use strict";

const makeObservable = require('../../../base/make_observable/make_observable').makeObservable;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GestureRecognizer = exports.longPressTime = exports.TapRecognizer = exports.PressRecognizer = exports.PinchRecognizer = exports.PanRecognizer = void 0;
const tslib_1 = require("tslib");
const exists_1 = require('../../../base/exists');
const mobx = require("mobx");
const combine_allowed_touch_actions_1 = require("./combine_allowed_touch_actions");
const gesture_recognizer_css_1 = require("./gesture_recognizer.css");
const pointer_tracker_1 = require("./pointer_tracker");
const touch_action_polyfill_1 = require("./touch_action_polyfill");
var pan_recognizer_1 = require("./pan_recognizer");
Object.defineProperty(exports, "PanRecognizer", {
  enumerable: true,
  get: function () {
    return pan_recognizer_1.PanRecognizer;
  }
});
var pinch_recognizer_1 = require("./pinch_recognizer");
Object.defineProperty(exports, "PinchRecognizer", {
  enumerable: true,
  get: function () {
    return pinch_recognizer_1.PinchRecognizer;
  }
});
var press_recognizer_1 = require("./press_recognizer");
Object.defineProperty(exports, "PressRecognizer", {
  enumerable: true,
  get: function () {
    return press_recognizer_1.PressRecognizer;
  }
});
var tap_recognizer_1 = require("./tap_recognizer");
Object.defineProperty(exports, "TapRecognizer", {
  enumerable: true,
  get: function () {
    return tap_recognizer_1.TapRecognizer;
  }
});
exports.longPressTime = 750;
class GestureRecognizer {
  static _makeObservable(instance) {
    makeObservable(instance, {
      onPointerDown: mobx.action.bound,
      onPointerEnd: mobx.action.bound,
      processMoved: mobx.action.bound
    });
  }
  constructor(recognizers, raf, caf) {
    GestureRecognizer._makeObservable(this);
    this.raf = raf;
    this.caf = caf;
    this.element = null;
    this.allPointers = new Map();
    this.currentBatchPointerIds = new Set();
    this.moveFrame = 0;
    this.actions = new Set();
    this._setRef = ele => {
      var _a, _b;
      if (this.element) {
        this.processMoved();
        for (const recognizer of this.recognizers) {
          (_a = recognizer.onUnmount) === null || _a === void 0 ? void 0 : _a.call(recognizer, this.allPointers);
        }
        this.element.style.touchAction = '';
      }
      (_b = this.tracker) === null || _b === void 0 ? void 0 : _b.disconnect();
      this.tracker = undefined;
      this.element = ele;
      if (this.element) {
        this.tracker = new pointer_tracker_1.PointerTracker(this.element, this.onPointerDown, this.onPointerMove, this.onPointerUp, this.onPointerCancel);
        const actions = (0, combine_allowed_touch_actions_1.combineAllowedTouchActions)(this.recognizers.map(r => r.getBrowserHandledTouchActions()));
        this.element.classList.add(gesture_recognizer_css_1.default.gestureElement);
        this.element.style.touchAction = actions.join(' ');
        this.actions = new Set(actions);
      }
    };
    this.onPointerMove = pointer => {
      var _a;
      const state = this.allPointers.get(pointer.id);
      if (!state) {
        return;
      }
      state.current = pointer;
      (0, touch_action_polyfill_1.manuallyApplyTouchAction)(this.actions, pointer, this.allPointers);
      this.currentBatchPointerIds.add(pointer.id);
      this.moveFrame = this.moveFrame || ((_a = this.raf) === null || _a === void 0 ? void 0 : _a.call(this, this.processMoved)) || requestAnimationFrame(this.processMoved);
    };
    this.onPointerUp = pointer => {
      this.onPointerEnd(pointer, 'up');
    };
    this.onPointerCancel = pointer => {
      this.onPointerEnd(pointer, 'cancel');
    };
    this.recognizers = recognizers.slice();
    this.setRef = this.recognizers.length ? this._setRef : undefined;
  }
  onPointerDown(pointer) {
    const state = {
      start: pointer,
      previous: pointer,
      current: pointer
    };
    this.allPointers.set(pointer.id, state);
    (0, touch_action_polyfill_1.manuallyApplyTouchAction)(this.actions, pointer, this.allPointers);
    this.processMoved();
    for (const recognizer of this.recognizers) {
      recognizer.onPointerDown(state, this.allPointers);
    }
  }
  onPointerEnd(pointer, action) {
    const state = this.allPointers.get(pointer.id);
    if (!state) {
      return;
    }
    this.processMoved();
    state.current = pointer;
    (0, touch_action_polyfill_1.manuallyApplyTouchAction)(this.actions, pointer, this.allPointers);
    this.allPointers.delete(pointer.id);
    for (const recognizer of this.recognizers) {
      switch (action) {
        case 'up':
          recognizer.onPointerUp(state, this.allPointers);
          break;
        case 'cancel':
          recognizer.onPointerCancel ? recognizer.onPointerCancel(state, this.allPointers) : recognizer.onPointerUp(state, this.allPointers);
          break;
        default:
      }
    }
  }
  processMoved() {
    var _a;
    if (this.moveFrame) {
      const {
        caf = window.cancelAnimationFrame
      } = this;
      caf(this.moveFrame);
    }
    this.moveFrame = 0;
    if (!this.currentBatchPointerIds.size) {
      return;
    }
    const pointers = Array.from(this.currentBatchPointerIds, id => this.allPointers.get(id)).filter(exists_1.exists);
    this.currentBatchPointerIds.clear();
    for (const recognizer of this.recognizers) {
      (_a = recognizer.onPointerMove) === null || _a === void 0 ? void 0 : _a.call(recognizer, pointers, this.allPointers);
    }
    for (const pointer of pointers) {
      pointer.previous = pointer.current;
    }
  }
}
exports.GestureRecognizer = GestureRecognizer;