"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPanEventProperties = exports.PanRecognizer = void 0;
const recognizer_1 = require("./recognizer");
class PanRecognizer {
    constructor(opts) {
        this.opts = opts;
    }
    getBrowserHandledTouchActions() {
        const allowedTouchActions = ['pinch-zoom'];
        if (this.opts.direction) {
            if (['up', 'down', 'vertical'].includes(this.opts.direction)) {
                allowedTouchActions.push('pan-x');
            }
            else if (['left', 'right', 'horizontal'].includes(this.opts.direction)) {
                allowedTouchActions.push('pan-y');
            }
        }
        return allowedTouchActions;
    }
    onPointerDown(pointer, allPointers) {
        var _a;
        if (pointer.start.button == null || pointer.start.button === 0 || (pointer.start.button === 1 && ((_a = this.opts.middleMouseButtonSupported) !== null && _a !== void 0 ? _a : false))) {
            this.checkState(allPointers);
        }
    }
    onPointerUp(pointer, allPointers) {
        this.checkState(allPointers);
    }
    onPointerMove(pointers, allPointers) {
        if (!this.state) {
            return;
        }
        const { start, pointer: { current }, } = this.state;
        const event = getPanEventProperties(current, start, current);
        if (this.state.recognized) {
            this.opts.onMove && this.opts.onMove(event);
            return;
        }
        if (this.shouldStart(event)) {
            this.state.recognized = true;
            this.opts.onStart && this.opts.onStart(event);
            return;
        }
    }
    onUnmount() {
        var _a;
        if (this.opts.onEnd && ((_a = this.state) === null || _a === void 0 ? void 0 : _a.recognized)) {
            const { start, pointer: { current }, } = this.state;
            this.opts.onEnd(getPanEventProperties(current, start, current));
        }
    }
    checkState(allPointers) {
        if (allPointers.size !== 1 && this.state) {
            const { recognized, start, pointer: { current }, } = this.state;
            this.state = undefined;
            if (recognized && this.opts.onEnd) {
                this.opts.onEnd(getPanEventProperties(current, start, current));
            }
        }
        if (allPointers.size === 1 && !this.state) {
            const pointer = allPointers.values().next().value;
            this.state = { recognized: false, pointer, start: pointer.current };
        }
    }
    shouldStart(event) {
        var _a;
        if (event.distance < ((_a = this.opts.minDistance) !== null && _a !== void 0 ? _a : 10)) {
            return false;
        }
        return this.checkDirection(event);
    }
    checkDirection(event) {
        if (!this.opts.direction) {
            return true;
        }
        else if (this.opts.direction === 'vertical') {
            return event.direction === 'up' || event.direction === 'down';
        }
        else if (this.opts.direction === 'horizontal') {
            return event.direction === 'left' || event.direction === 'right';
        }
        else {
            return event.direction === this.opts.direction;
        }
    }
}
exports.PanRecognizer = PanRecognizer;
function getPanEventProperties(pointer, start, current) {
    const distanceX = current.x - start.x;
    const distanceY = current.y - start.y;
    const distance = Math.sqrt(distanceX ** 2 + distanceY ** 2);
    const deltaX = current.x - start.x;
    const deltaY = current.y - start.y;
    const delta = Math.sqrt(deltaX ** 2 + deltaY ** 2);
    const deltaTime = current.timestamp - start.timestamp;
    return {
        ...(0, recognizer_1.getCommonEventProperties)(pointer, current),
        velocityX: deltaX / deltaTime,
        velocityY: deltaY / deltaTime,
        velocity: delta / deltaTime,
        distanceX,
        distanceY,
        distance,
        direction: getDirection(deltaX, deltaY),
        button: start.button,
    };
}
exports.getPanEventProperties = getPanEventProperties;
function getDirection(distanceX, distanceY) {
    if (distanceX === distanceY) {
        return 'none';
    }
    if (Math.abs(distanceX) >= Math.abs(distanceY)) {
        return distanceX < 0 ? 'left' : 'right';
    }
    return distanceY < 0 ? 'up' : 'down';
}
