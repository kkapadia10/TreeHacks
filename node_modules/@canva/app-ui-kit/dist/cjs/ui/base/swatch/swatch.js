"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddColorButton = exports.Swatch = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const classnames_1 = require("classnames");
const React = require("react");
const react_measure_1 = require("react-measure");
const aspect_ratio_1 = require('../aspect_ratio/aspect_ratio');
const icon_1 = require('../icons/plus/icon');
const internal_swatch_1 = require("./internal/internal_swatch");
const swatch_util_1 = require("./internal/swatch_util");
const swatch_css_1 = require("./swatch.css");
const swatch_messages_1 = require("./swatch.messages");
const getClassName = ({ size, stretch, aspectRatio, }) => {
    const fluidStyles = {
        [swatch_css_1.default.stretch]: stretch,
        [swatch_css_1.default.aspectRatio]: stretch && aspectRatio,
    };
    const sizeStyles = {
        [swatch_css_1.default.xxsmall]: size === 'xxsmall',
        [swatch_css_1.default.xsmall]: size === 'xsmall',
        [swatch_css_1.default.small]: size === 'small',
        [swatch_css_1.default.medium]: size === 'medium',
        [swatch_css_1.default.large]: size === 'large',
    };
    return (0, classnames_1.default)(swatch_css_1.default.swatch, sizeStyles, fluidStyles);
};
const getBackgroundClassName = ({ variant, fill, contrastingColors, isCheckeredBgPresent, areNoColorsApplied, }) => {
    const variantStyles = {
        [swatch_css_1.default.outline]: variant === 'outline',
    };
    const fillStyles = {
        [swatch_css_1.default.colorSpectrumCircular]: areNoColorsApplied || fill === 'circularSpectrum' || contrastingColors === 'circularSpectrum',
        [swatch_css_1.default.colorSpectrumLinear]: fill === 'linearSpectrum',
        [swatch_css_1.default.colorTransparent]: isCheckeredBgPresent,
    };
    return (0, classnames_1.default)(swatch_css_1.default.background, variantStyles, fillStyles);
};
const getInlineStyles = (colors, width) => {
    if (!(colors === null || colors === void 0 ? void 0 : colors.length)) {
        return undefined;
    }
    const backgroundImage = colors
        .map(color => {
        if (typeof color === 'string') {
            return (0, swatch_util_1.getValidGradientString)(color);
        }
        if (color == null) {
            return (0, swatch_util_1.getValidGradientString)('transparent');
        }
        if ((0, swatch_util_1.isFillObject)(color)) {
            return (0, swatch_util_1.gradientToCssBackground)(color);
        }
        return undefined;
    })
        .filter(Boolean)
        .join(', ');
    const backgroundSize = colors.length > 1
        ? `${colors.map((c, i) => (0, swatch_util_1.toStripeWidth)(width, colors.length)).join(', ')}`
        : undefined;
    const backgroundPositionX = colors.length > 1
        ? `${colors.map((c, i) => (0, swatch_util_1.toStripePosition)(i, colors.length - 1)).join(', ')}`
        : undefined;
    const backgroundRepeat = colors.length > 1 ? 'no-repeat' : undefined;
    return { backgroundImage, backgroundRepeat, backgroundSize, backgroundPositionX };
};
const getSwatchContent = ({ areAllColorsTransparent, isCheckeredBgPresent, inlineStyles, }) => {
    if (areAllColorsTransparent) {
        return (0, jsx_runtime_1.jsx)("span", { className: swatch_css_1.default.strike });
    }
    if (isCheckeredBgPresent) {
        return (0, jsx_runtime_1.jsx)("span", { className: (0, classnames_1.default)(swatch_css_1.default.colors), style: inlineStyles });
    }
    return null;
};
const Swatch = ({ fill, size = 'medium', variant = 'solid', Icon, onClick, active, disabled, disclosure, role, focusRef, tabIndex, tooltipLabel, disableTooltip, tooltipOverflowBoundariesElement, stretch, colorNames, rgbToCmyk, id, ariaLabel, ariaDescribedBy, ariaLabelledBy, onDelete, deleteButtonVisibility = 'on-hover', aspectRatio, ariaHasPopup, ariaControls, }) => {
    const [spanWidth, setSpanWidth] = React.useState(0);
    const contrastingColors = (0, swatch_util_1.useContrastingColors)(fill, variant === 'contrast');
    const colors = contrastingColors instanceof Array ? contrastingColors : undefined;
    const areNoColorsApplied = (colors === null || colors === void 0 ? void 0 : colors.length) === 0;
    const isAtleastOneColorTransparent = (!areNoColorsApplied && (colors === null || colors === void 0 ? void 0 : colors.some(c => !c))) || false;
    const areAllColorsTransparent = (!areNoColorsApplied && (colors === null || colors === void 0 ? void 0 : colors.every(c => !c))) || false;
    const isCheckeredBgPresent = fill !== 'linearSpectrum'
        && fill !== 'circularSpectrum'
        && contrastingColors !== 'circularSpectrum'
        && !areNoColorsApplied;
    const className = getClassName({
        size,
        stretch,
        aspectRatio,
    });
    const backgroundClassName = getBackgroundClassName({
        variant,
        fill,
        contrastingColors,
        isCheckeredBgPresent,
        areNoColorsApplied,
    });
    const inlineStyles = React.useMemo(() => getInlineStyles(colors, spanWidth), [colors, spanWidth]);
    const content = getSwatchContent({
        areAllColorsTransparent,
        isCheckeredBgPresent,
        inlineStyles,
    });
    const defaultLabel = React.useMemo(() => (0, swatch_util_1.generateSwatchLabel)({
        colors,
        colorNames,
        rgbToCmyk,
        areNoColorsApplied,
        areAllColorsTransparent,
        isAtleastOneColorTransparent,
        fill,
    }), [
        colors,
        colorNames,
        rgbToCmyk,
        areNoColorsApplied,
        areAllColorsTransparent,
        isAtleastOneColorTransparent,
        fill,
    ]);
    const tooltipLabelText = !disableTooltip ? tooltipLabel !== null && tooltipLabel !== void 0 ? tooltipLabel : defaultLabel : '';
    const ariaLabelText = ariaLabel !== null && ariaLabel !== void 0 ? ariaLabel : defaultLabel;
    const isClickable = !!onClick;
    const isDeletable = !!onDelete;
    const swatch = ((0, jsx_runtime_1.jsxs)(internal_swatch_1.StaticSwatch, { className: className, ariaLabel: ariaLabelText, ariaLabelledBy: ariaLabelledBy, ariaDescribedBy: ariaDescribedBy, id: id, children: [(0, jsx_runtime_1.jsx)(react_measure_1.default, { bounds: true, onResize: ({ bounds }) => setSpanWidth((bounds === null || bounds === void 0 ? void 0 : bounds.width) || 0), children: ({ measureRef }) => ((0, jsx_runtime_1.jsx)("span", { ref: measureRef, className: backgroundClassName, style: content ? undefined : inlineStyles, children: content })) }), Icon && (0, jsx_runtime_1.jsx)("span", { className: swatch_css_1.default.icon, children: Icon() })] }));
    const interactiveSwatch = isClickable
        ? ((0, jsx_runtime_1.jsx)(internal_swatch_1.ClickableSwatch, { onClick: onClick, active: active, disabled: disabled, disclosure: disclosure, ariaLabel: ariaLabelText, role: role, focusRef: focusRef, tabIndex: tabIndex, stretch: stretch, aspectRatio: aspectRatio, ariaHasPopup: ariaHasPopup, ariaControls: ariaControls, tooltipLabel: tooltipLabelText, disableTooltip: disableTooltip, tooltipOverflowBoundariesElement: tooltipOverflowBoundariesElement, children: swatch }))
        : swatch;
    const fluidSwatch = stretch && aspectRatio
        ? (0, jsx_runtime_1.jsx)(aspect_ratio_1.AspectRatio, { ratio: aspectRatio, children: interactiveSwatch })
        : interactiveSwatch;
    const swatchWithDeleteButton = isDeletable
        ? ((0, jsx_runtime_1.jsx)(internal_swatch_1.DeletableSwatch, { onDelete: onDelete, stretch: stretch, aspectRatio: aspectRatio, deleteButtonVisibility: deleteButtonVisibility, disableTooltip: disableTooltip, tooltipOverflowBoundariesElement: tooltipOverflowBoundariesElement, children: fluidSwatch }))
        : fluidSwatch;
    return swatchWithDeleteButton;
};
exports.Swatch = Swatch;
const iconSizeMap = {
    ['xxsmall']: 'tiny',
    ['xsmall']: 'small',
    ['small']: 'small',
    ['medium']: 'small',
    ['large']: 'medium',
};
const AddColorButton = (props) => {
    const { size = 'medium' } = props;
    const Icon = () => ((0, jsx_runtime_1.jsx)("span", { className: swatch_css_1.default.iconOverlay, children: (0, jsx_runtime_1.jsx)(icon_1.PlusIcon, { size: iconSizeMap[size], tone: "primary" }) }));
    return ((0, jsx_runtime_1.jsx)(exports.Swatch, { ...props, fill: "circularSpectrum", tooltipLabel: swatch_messages_1.SwatchMessages.addColor(), ariaLabel: swatch_messages_1.SwatchMessages.addColor(), Icon: Icon }));
};
exports.AddColorButton = AddColorButton;
