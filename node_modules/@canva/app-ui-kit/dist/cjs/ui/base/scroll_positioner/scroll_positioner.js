"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScrollPositioner = void 0;
const easings_1 = require('../animation/easings');
class ScrollPositioner {
    static animate(
        getScrollTop,
        setScrollTop,
        newScrollTop,
        duration = 150,
        easingFn = easings_1.Easings.linear
    ) {
        const oldScrollTop = getScrollTop();
        let startTime;
        const scroll = (timestamp) => {
            startTime = startTime || timestamp;
            const progress = timestamp - startTime;
            if (progress < duration) {
                setScrollTop(easingFn(oldScrollTop, newScrollTop, progress, duration));
                window.requestAnimationFrame(scroll);
            }
            else {
                setScrollTop(newScrollTop);
            }
        };
        window.requestAnimationFrame(scroll);
    }
    static animateElement(element, newScrollTop, duration = 150, easingFn = easings_1.Easings.linear) {
        ScrollPositioner.animate(() => element.scrollTop, (scrollTop) => (element.scrollTop = scrollTop), newScrollTop, duration, easingFn);
    }
    static isAboveVisibleScroll(container, element) {
        return element.offsetTop < container.scrollTop;
    }
    static isBelowVisibleScroll(container, element) {
        const elementBottom = element.offsetTop + element.offsetHeight;
        const visibleScrollBottom = container.scrollTop + container.clientHeight;
        return elementBottom > visibleScrollBottom;
    }
    static scrollToPutAtTop(container, element, withAnimation = false) {
        const containerOuterToInnerHeightDiff = (container.offsetHeight - container.clientHeight) / 2;
        const newScrollTop = element.offsetTop - containerOuterToInnerHeightDiff;
        if (withAnimation) {
            ScrollPositioner.animateElement(container, newScrollTop);
        }
        else {
            container.scrollTop = newScrollTop;
        }
    }
    static scrollToPutAtBottom(container, element, withAnimation = false) {
        const containerOuterToInnerHeightDiff = (container.offsetHeight - container.clientHeight) / 2;
        const elementBottom = element.offsetTop + element.offsetHeight;
        const newScrollTop = elementBottom - container.offsetHeight + containerOuterToInnerHeightDiff;
        if (withAnimation) {
            ScrollPositioner.animateElement(container, newScrollTop);
        }
        else {
            container.scrollTop = newScrollTop;
        }
    }
    static scrollToCenter(container, element, withAnimation = false) {
        const oldScrollTop = container.scrollTop;
        const containerHeight = container.offsetHeight;
        const elementTop = element.offsetTop - oldScrollTop;
        const elementHeight = element.offsetHeight;
        const newScrollTop = elementTop + elementHeight / 2 + oldScrollTop - containerHeight / 2;
        if (withAnimation) {
            ScrollPositioner.animateElement(container, newScrollTop);
        }
        else {
            container.scrollTop = newScrollTop;
        }
    }
}
exports.ScrollPositioner = ScrollPositioner;
