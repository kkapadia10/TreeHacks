"use strict";

const makeObservable = require('../../../../base/make_observable/make_observable').makeObservable;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WindowedList = void 0;
const tslib_1 = require("tslib");
const mobx_1 = require("mobx");
const mobx_react_1 = require("mobx-react");
const React = require("react");
let WindowedList = class WindowedList extends React.Component {
  static _makeObservable(instance) {
    makeObservable(instance, {
      visibleRange: mobx_1.observable.ref,
      itemPositions: mobx_1.computed
    });
  }
  constructor(...args) {
    super(...args);
    WindowedList._makeObservable(this);
  }
  get itemPositions() {
    return this.props.itemSizes.reduce((arr, size, index) => {
      arr.push(size + arr[index]);
      return arr;
    }, [0]);
  }
  componentDidMount() {
    (0, mobx_react_1.disposeOnUnmount)(this, (0, mobx_1.reaction)(() => ({
      positions: this.props.scrollState.positions,
      itemPositions: this.itemPositions
    }), ({
      positions,
      itemPositions
    }) => {
      if (positions == null) {
        this.visibleRange = undefined;
      } else {
        const {
          overscan = 1
        } = this.props;
        const {
          containerSize,
          scrollPosition
        } = positions;
        if (scrollPosition > itemPositions[itemPositions.length - 1]) {
          this.setVisibleRange(Math.max(itemPositions.length - 1 - overscan, 0), itemPositions.length - 1);
          return;
        }
        if (scrollPosition + containerSize < 0) {
          this.setVisibleRange(0, Math.min(overscan, itemPositions.length - 1));
          return;
        }
        const boundedFirstVisible = Math.min(scrollPosition, itemPositions[itemPositions.length - 1] - containerSize);
        const firstVisible = Math.max(0, itemPositions.findIndex(p => p > boundedFirstVisible) - 1 - overscan);
        const boundedLastVisible = Math.min(itemPositions[itemPositions.length - 1], scrollPosition + containerSize);
        const lastVisible = Math.min(itemPositions.length - 1, itemPositions.findIndex(p => p >= boundedLastVisible) + overscan);
        this.setVisibleRange(firstVisible, lastVisible);
      }
    }, {
      fireImmediately: true
    }));
  }
  setVisibleRange(firstVisible, lastVisible) {
    if (this.visibleRange == null) {
      this.visibleRange = (0, mobx_1.observable)({
        firstVisible,
        lastVisible
      });
    } else {
      this.visibleRange.firstVisible = firstVisible;
      this.visibleRange.lastVisible = lastVisible;
    }
  }
  render() {
    const {
      visibleRange,
      itemPositions
    } = this;
    if (visibleRange == null) {
      return this.props.children(undefined, itemPositions);
    }
    const {
      firstVisible,
      lastVisible
    } = visibleRange;
    return this.props.children({
      firstVisible,
      lastVisible
    }, itemPositions);
  }
};
exports.WindowedList = WindowedList;
exports.WindowedList = WindowedList = tslib_1.__decorate([mobx_react_1.observer], WindowedList);