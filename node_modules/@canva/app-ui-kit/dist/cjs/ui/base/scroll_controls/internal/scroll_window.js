"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OptionalScrollWindow = exports.ScrollWindow = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const mobx_1 = require("mobx");
const React = require("react");
const resize_observer_polyfill_1 = require("resize-observer-polyfill");
const provider_1 = require('../../provider/provider');
const utilities_1 = require("./utilities");
function ScrollWindow(props) {
    const { layout, innerRef, doNotUseForceLTRForPageNavigator, children } = props;
    const direction = (0, provider_1.useDirection)();
    const privateFields = React.useRef({
        resizeObserver: null,
        scrollableEl: null,
        isRtl: doNotUseForceLTRForPageNavigator ? false : direction === 'RTL',
        scrollState: (0, mobx_1.observable)({
            layout,
        }),
    });
    const dispatch = React.useCallback(() => {
        (0, mobx_1.runInAction)(() => {
            if (!privateFields.current.scrollableEl) {
                privateFields.current.scrollState.positions = undefined;
                return;
            }
            if (privateFields.current.scrollableEl.offsetParent == null) {
                return;
            }
            privateFields.current.scrollState.positions = (0, utilities_1.calculateScrollStatePosition)(privateFields.current.scrollableEl, layout, privateFields.current.isRtl);
        });
    }, [layout]);
    const scrollableRef = React.useCallback((el) => {
        if (privateFields.current.scrollableEl === el) {
            return;
        }
        if (!privateFields.current.resizeObserver) {
            privateFields.current.resizeObserver = new resize_observer_polyfill_1.default(dispatch);
        }
        innerRef === null || innerRef === void 0 ? void 0 : innerRef(el);
        if (privateFields.current.scrollableEl) {
            privateFields.current.resizeObserver.unobserve(privateFields.current.scrollableEl);
            privateFields.current.scrollableEl.removeEventListener('scroll', dispatch);
        }
        privateFields.current.scrollableEl = el;
        if (privateFields.current.scrollableEl) {
            privateFields.current.resizeObserver.observe(privateFields.current.scrollableEl);
            privateFields.current.scrollableEl.addEventListener('scroll', dispatch, { passive: true });
        }
        dispatch();
    }, [innerRef, dispatch]);
    React.useEffect(() => {
        privateFields.current.isRtl = doNotUseForceLTRForPageNavigator ? false : direction === 'RTL';
    }, [doNotUseForceLTRForPageNavigator, direction]);
    React.useEffect(() => {
        const resizeObserver = privateFields.current.resizeObserver;
        return () => resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.disconnect();
    }, []);
    return (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: children({ scrollableRef, scrollState: privateFields.current.scrollState }) });
}
exports.ScrollWindow = ScrollWindow;
class OptionalScrollWindow extends React.Component {
    render() {
        const { enabled, innerRef, children } = this.props;
        if (enabled) {
            return (0, jsx_runtime_1.jsx)(ScrollWindow, { ...this.props });
        }
        return children({ scrollableRef: innerRef });
    }
}
exports.OptionalScrollWindow = OptionalScrollWindow;
