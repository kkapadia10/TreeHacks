"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Pin = void 0;
const tslib_1 = require("tslib");
const jsx_runtime_1 = require("react/jsx-runtime");
const preconditions_1 = require('../../../base/preconditions');
const classnames_1 = require("classnames");
const mobx_1 = require("mobx");
const mobx_react_1 = require("mobx-react");
const popper_js_1 = require("popper.js");
const React = require("react");
const layer_1 = require('../layer/layer');
const provider_1 = require('../provider/provider');
const pin_css_1 = require("./pin.css");
const pin_motion_wrapper_1 = require("./pin_motion_wrapper");
exports.Pin = React.forwardRef((props, ref) => {
  const pinRef = React.useRef(null);
  React.useImperativeHandle(ref, () => ({
    update() {
      var _a;
      (_a = pinRef.current) === null || _a === void 0 ? void 0 : _a.update();
    },
    dangerouslyForceUpdate() {
      var _a;
      (_a = pinRef.current) === null || _a === void 0 ? void 0 : _a.dangerouslyForceUpdate();
    }
  }), []);
  const direction = (0, provider_1.useDirection)();
  return (0, jsx_runtime_1.jsx)(_Pin, {
    direction: direction,
    ...props,
    ref: pinRef
  });
});
const popperFactory = (reference, popper, options) => new popper_js_1.default(reference, popper, options);
const RTLPlacementConversionTable = new Map([['top-start', 'top-end'], ['top-end', 'top-start'], ['right-start', 'left-start'], ['right', 'left'], ['right-end', 'left-end'], ['bottom-end', 'bottom-start'], ['bottom-start', 'bottom-end'], ['left-end', 'right-end'], ['left', 'right'], ['left-start', 'right-start']]);
let _Pin = class _Pin extends React.Component {
  constructor(props) {
    super(props);
    this.contentKey = 0;
    this.onOutsideLayerPointerDown = event => {
      const {
        open,
        onOutsideContentPointerDown,
        onChildrenPointerDown
      } = this.props;
      if (!onOutsideContentPointerDown && !onChildrenPointerDown || !open) {
        return;
      }
      const target = event && event.target;
      if (target && target instanceof this.parentGlobal.Node && this.targetRef && this.targetRef.contains(target)) {
        onChildrenPointerDown && onChildrenPointerDown(event);
        return;
      }
      onOutsideContentPointerDown && onOutsideContentPointerDown(event);
    };
    this.updateTargetRef = targetRef => this.targetRef = targetRef;
    this.updateArrowRef = arrowRef => {
      if (this.arrowRef !== arrowRef) {
        this.arrowRef = arrowRef;
        this.maybeCreatePopper();
        this.update();
      }
    };
    this.updateContentRef = contentRef => {
      if (this.contentRef !== contentRef) {
        this.contentRef = contentRef;
        this.maybeCreatePopper();
        this.update();
      }
    };
    this.onModalMouseDown = () => {
      if (this.props.onOutsideContentPointerDown) {
        window.setTimeout(this.props.onOutsideContentPointerDown, 0);
      }
    };
    (0, mobx_react_1.disposeOnUnmount)(this, [(0, mobx_1.reaction)(() => this.props.open, open => open && (this.contentKey = 1 - this.contentKey)), (0, mobx_1.reaction)(() => this.props.placement, _ => {
      this.maybeDestroyPopper();
      this.maybeCreatePopper();
    })]);
  }
  componentDidUpdate(prevProps) {
    preconditions_1.Preconditions.checkState(prevProps.refObj === this.props.refObj, 'refObj must never be changed');
    if (this.popper && !this.props.open) {
      this.maybeDestroyPopper();
    } else {
      this.update();
    }
  }
  componentWillUnmount() {
    this.maybeDestroyPopper();
  }
  dangerouslyForceUpdate() {
    if (this.popper && this.props.open) {
      this.popper.update();
    }
  }
  update() {
    if (this.popper && this.props.open) {
      this.popper.scheduleUpdate();
    }
  }
  maybeDestroyPopper() {
    if (this.popper) {
      this.popper.disableEventListeners();
      this.popper = undefined;
    }
  }
  maybeCreatePopper() {
    const popperFactory = preconditions_1.Preconditions.checkExists(this.props._popperFactory);
    const {
      open,
      refObj,
      positionFixed,
      direction
    } = this.props;
    let {
      placement
    } = this.props;
    if (this.popper || !open || !this.contentRef || !this.arrowRef && this.props.arrow != null) {
      return;
    }
    let targetWrapperRef;
    if (refObj) {
      preconditions_1.Preconditions.checkState(!this.targetRef, 'Pin must not contain children when refObj is specified');
      targetWrapperRef = refObj;
    } else if (this.targetRef) {
      preconditions_1.Preconditions.checkState(this.targetRef.children.length === 1, 'Pin must contain exactly one child');
      targetWrapperRef = this.targetRef.children[0];
    } else {
      return;
    }
    if (placement && direction === 'RTL' && RTLPlacementConversionTable.has(placement)) {
      placement = RTLPlacementConversionTable.get(placement);
    }
    const options = {
      placement,
      positionFixed,
      modifiers: {
        arrow: {
          element: this.arrowRef || undefined,
          enabled: this.arrowRef != null
        },
        offset: {
          enabled: !!this.props.calculateOffset,
          fn: (data, options) => {
            const offset = this.props.calculateOffset();
            data.offsets.popper.left = Math.round(offset.left);
            data.offsets.popper.top = Math.round(offset.top);
            return data;
          }
        },
        preventOverflow: {
          escapeWithReference: this.props.overflowParent,
          boundariesElement: this.props.overflowBoundariesElement || 'scrollParent'
        }
      }
    };
    if (this.props.onPlacementUpdate) {
      options.onUpdate = this.props.onPlacementUpdate;
    }
    this.popper = popperFactory(targetWrapperRef, this.contentRef, options);
  }
  get parentGlobal() {
    var _a, _b;
    return ((_b = (_a = this.targetRef) === null || _a === void 0 ? void 0 : _a.ownerDocument) === null || _b === void 0 ? void 0 : _b.defaultView) || window;
  }
  render() {
    var _a;
    const {
      open,
      level,
      children,
      content,
      arrow,
      MotionWrapper = pin_motion_wrapper_1.DefaultMotionWrapper,
      expandChildren,
      noPointerEventsForDisabledChildren,
      onOutsideContentPointerDown,
      onChildrenPointerDown,
      parentLayer,
      blockOutsidePointerEvents,
      modalBackdrop,
      noPointerEvents
    } = this.props;
    const onOutsideLayerPointerDownHandler = !onOutsideContentPointerDown && !onChildrenPointerDown || !open ? undefined : this.onOutsideLayerPointerDown;
    return (0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, {
      children: [children && (0, jsx_runtime_1.jsx)("div", {
        className: (0, classnames_1.default)({
          [pin_css_1.default.noPointerEventsForDisabledChildren]: noPointerEventsForDisabledChildren,
          [pin_css_1.default.expandChildren]: expandChildren
        }),
        ref: this.updateTargetRef,
        children: children
      }), (0, jsx_runtime_1.jsx)(MotionWrapper, {
        show: open,
        childRef: {
          current: (_a = this.contentRef) !== null && _a !== void 0 ? _a : null
        },
        children: ({
          style,
          showLayer
        }) => (0, jsx_runtime_1.jsxs)(layer_1.Layer, {
          open: showLayer,
          level: level,
          parentLayer: parentLayer,
          onOutsideLayerPointerDown: onOutsideLayerPointerDownHandler,
          children: [blockOutsidePointerEvents && open &&
          (0, jsx_runtime_1.jsx)("div", {
            className: (0, classnames_1.default)(pin_css_1.default.backdrop, {
              [pin_css_1.default.backdropDark]: modalBackdrop === 'dark'
            }),
            onMouseDown: this.onModalMouseDown
          }), (0, jsx_runtime_1.jsxs)("div", {
            ref: this.updateContentRef,
            className: (0, classnames_1.default)(pin_css_1.default.content, {
              [pin_css_1.default.closed]: !open,
              [pin_css_1.default.noPointerEvents]: noPointerEvents
            }),
            style: style,
            children: [content, arrow && (0, jsx_runtime_1.jsx)("div", {
              ref: this.updateArrowRef,
              className: pin_css_1.default.arrow,
              children: arrow
            })]
          }, this.contentKey)]
        })
      })]
    });
  }
};
_Pin.defaultProps = {
  placement: 'top',
  positionFixed: false,
  open: true,
  _popperFactory: popperFactory,
  content: ''
};
_Pin = tslib_1.__decorate([mobx_react_1.observer], _Pin);