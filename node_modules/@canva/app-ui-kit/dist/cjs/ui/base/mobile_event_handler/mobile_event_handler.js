"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MobileEventHandler = exports.MobileEvents = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const React = require("react");
class HandlerContext {
    constructor(handler) {
        this.handler = handler;
        this.childContexts = [];
    }
}
const MobileEventHandlerContext = React.createContext(undefined);
var MobileEvents;
(function (MobileEvents) {
    MobileEvents["BACK"] = "backbutton";
})(MobileEvents || (exports.MobileEvents = MobileEvents = {}));
const MobileEventHandler = function MobileEventHandler({ onBackButton, children }) {
    const [nodeContext] = React.useState(() => new HandlerContext(onBackButton));
    const parentContext = React.useContext(MobileEventHandlerContext);
    React.useEffect(() => {
        if (parentContext) {
            parentContext.childContexts.unshift(nodeContext);
            return () => {
                const { childContexts } = parentContext;
                const index = childContexts.indexOf(nodeContext);
                if (index > -1) {
                    childContexts.splice(index, 1);
                }
            };
        }
        else {
            const processHandlerTree = () => processContext(nodeContext);
            return backButtonTrigger(processHandlerTree);
        }
    }, 
    []);
    return ((0, jsx_runtime_1.jsx)(MobileEventHandlerContext.Provider, { value: nodeContext, children: children }));
};
exports.MobileEventHandler = MobileEventHandler;
const backButtonTrigger = (onTrigger) => {
    try {
        document.addEventListener(MobileEvents.BACK, onTrigger);
        return () => document.removeEventListener(MobileEvents.BACK, onTrigger);
    }
    catch (e) {
        if (window.self === window.top) {
            throw e;
        }
    }
};
const processContext = ({ childContexts, handler }) => {
    let propagationStopped = false;
    for (const ctx of childContexts) {
        propagationStopped = processContext(ctx);
        if (propagationStopped) {
            break;
        }
    }
    if (!propagationStopped) {
        handler({
            stopPropagation: () => (propagationStopped = true),
        });
    }
    return propagationStopped;
};
