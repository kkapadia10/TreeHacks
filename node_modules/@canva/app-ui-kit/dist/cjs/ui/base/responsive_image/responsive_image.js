"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ViewportResponsivePicture = exports.ViewportResponsiveImage = exports.PixelDensityResponsiveImage = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const React = require("react");
const metrics_1 = require('../metrics/metrics');
const metrics_css_1 = require('../metrics/metrics.css');
const responsive_image_css_1 = require("./responsive_image.css");
const breakpointsOrder = {
    [metrics_1.Breakpoint.DEFAULT]: 0,
    [metrics_1.Breakpoint.SMALL]: 1,
    [metrics_1.Breakpoint.MEDIUM]: 2,
    [metrics_1.Breakpoint.LARGE]: 3,
};
exports.PixelDensityResponsiveImage = React.forwardRef((props, ref) => {
    const { alt, sources, ...otherImgProps } = props;
    const imageSources = React.useMemo(() => sources.map(s => ({
        size: s.pixelDensity,
        unit: 'x',
        src: s.src,
    })), [sources]);
    const srcSet = React.useMemo(() => toSrcSet(imageSources), [imageSources]);
    const src = React.useMemo(() => chooseFallbackSource(imageSources, otherImgProps.src), [otherImgProps.src, imageSources]);
    return (0, jsx_runtime_1.jsx)("img", { ...otherImgProps, ref: ref, alt: alt, srcSet: srcSet, src: src });
});
exports.ViewportResponsiveImage = React.forwardRef((props, ref) => {
    const { alt, sources, sizes, ...otherImgProps } = props;
    const imageSources = React.useMemo(() => sources.map(s => ({
        src: s.src,
        size: s.intrinsicWidth,
        unit: 'w',
    })), [sources]);
    const srcSet = React.useMemo(() => toSrcSet(imageSources), [imageSources]);
    const src = React.useMemo(() => chooseFallbackSource(imageSources, otherImgProps.src), [otherImgProps.src, imageSources]);
    const sizesAttr = React.useMemo(() => toSizes(sizes), [sizes]);
    return ((0, jsx_runtime_1.jsx)("img", { ...otherImgProps, ref: ref, alt: alt, srcSet: srcSet, sizes: sizesAttr, src: src }));
});
exports.ViewportResponsivePicture = React.forwardRef((props, ref) => {
    const { alt, sources, className, ...otherImgProps } = props;
    const imageSources = React.useMemo(() => sources
        .sort((a, b) => {
        if (a.breakpoint && b.breakpoint) {
            return breakpointsOrder[b.breakpoint] - breakpointsOrder[a.breakpoint];
        }
        if (!a.breakpoint) {
            return 1;
        }
        if (!b.breakpoint) {
            return -1;
        }
        return 0;
    })
        .map(source => {
        const { breakpoint, images } = source;
        const imageSource = images.map(s => ({
            src: s.src,
            size: s.intrinsicWidth,
            unit: 'w',
        }));
        const srcSet = toSrcSet(imageSource);
        const media = toMediaBreakpoint(breakpoint);
        return {
            media,
            imageSource,
            srcSet,
        };
    }), [sources]);
    const fallbackSrc = React.useMemo(() => chooseFallbackSource(imageSources.flatMap(s => s.imageSource), otherImgProps.src), [otherImgProps.src, imageSources]);
    return ((0, jsx_runtime_1.jsxs)("picture", { ref: ref, className: responsive_image_css_1.default.responsiveImage, children: [imageSources.map(({ media, srcSet }) => ((0, jsx_runtime_1.jsx)("source", { media: media, srcSet: srcSet }, srcSet))), (0, jsx_runtime_1.jsx)("img", { ...otherImgProps, src: fallbackSrc, alt: alt, className: className })] }));
});
function toSrcSet(sources) {
    if (sources.length > 0) {
        return sources.map(source => `${source.src} ${source.size}${source.unit}`).join(', ');
    }
}
function toSizes(sizes) {
    if (sizes.length === 0) {
        return;
    }
    const breakpoints = sizes.map(size => size.breakpoint);
    breakpoints.sort();
    const viewportWidths = sizes.reduce((map, size) => {
        const width = `${size.width.value}${size.width.type}`;
        map.set(size.breakpoint, width);
        return map;
    }, new Map());
    return breakpoints
        .map(breakpoint => breakpoint != null
        ? `(max-width: ${breakpoint.value}${breakpoint.type}) ${viewportWidths.get(breakpoint)}`
        : `${viewportWidths.get(breakpoint)}`)
        .join(', ');
}
function chooseFallbackSource(sources, explicitSrc) {
    if (explicitSrc != null) {
        return explicitSrc;
    }
    return toLargestSource(sources);
}
function toLargestSource(sources) {
    const largestSource = sources.reduce((max, source) => (max == null || source.size > max.size ? source : max), undefined);
    return largestSource != null ? largestSource.src : undefined;
}
function toMediaBreakpoint(breakpoint) {
    switch (breakpoint) {
        case metrics_1.Breakpoint.SMALL:
            return metrics_css_1.default.smallUp;
        case metrics_1.Breakpoint.MEDIUM:
            return metrics_css_1.default.mediumUp;
        case metrics_1.Breakpoint.LARGE:
            return metrics_css_1.default.largeUp;
        default:
            return metrics_css_1.default.defaultDown;
    }
}
