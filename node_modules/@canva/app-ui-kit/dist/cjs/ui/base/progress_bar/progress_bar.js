"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProgressBar = exports.TRANSITION_END_TIMEOUT_MS = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const preconditions_1 = require('../../../base/preconditions');
const classnames_1 = require("classnames");
const React = require("react");
const react_measure_1 = require("react-measure");
const provider_1 = require('../provider/provider');
const progress_bar_css_1 = require("./progress_bar.css");
exports.TRANSITION_END_TIMEOUT_MS = parseInt(progress_bar_css_1.default.widthTransitionDurationMs, 10) + 100 || 2000;
const bubbleStyles = [progress_bar_css_1.default.bubble0, progress_bar_css_1.default.bubble1, progress_bar_css_1.default.bubble2, progress_bar_css_1.default.bubble3];
const bubbleTTLs = [2000, 3000, 4000, 2000];
const bubbleUpdateInterval = 1000;
const bubblePerPixelRatio = 0.13;
const ProgressBar = (props) => {
    const { value, ariaLabel, size = 'medium', tone = 'info', disableAnimations, onProgressAnimationEnd, disableBubbles, } = props;
    const [bubbles, setBubbles] = React.useState([]);
    const enableAnimations = (0, provider_1.useEnableAnimations)();
    const privateFields = React.useRef({
        bubbleUpdateTimer: 0,
        currentProgressValueTransitionEndHandled: false,
        onProgressAnimationEndTimeout: 0,
        width: 0,
    });
    const updateBubbles = React.useCallback(() => {
        const now = Date.now();
        const valueWidth = (privateFields.current.width / 100) * value;
        const requiredBubblesAmount = Math.ceil(valueWidth * bubblePerPixelRatio);
        const requiredBubblesAmountDelta = requiredBubblesAmount - bubbles.length;
        const newBubblesAmount = requiredBubblesAmountDelta < 0
            ? requiredBubblesAmount
            : Math.ceil(bubbles.length + requiredBubblesAmountDelta / 2);
        let bubblesChanged = false;
        const newBubbles = Array.from({ length: newBubblesAmount }, (_, i) => {
            const bubble = bubbles[i];
            if (bubble === undefined || now > bubbleTTLs[bubble.type] + bubble.start) {
                bubblesChanged = true;
                return {
                    swap: bubble ? !bubble.swap : false,
                    type: Math.floor(Math.random() * bubbleStyles.length),
                    position: Math.floor(Math.random() * valueWidth),
                    start: now,
                };
            }
            return bubble;
        });
        if (bubblesChanged) {
            setBubbles(newBubbles);
        }
        window.clearTimeout(privateFields.current.bubbleUpdateTimer);
        privateFields.current.bubbleUpdateTimer = window.setTimeout(updateBubbles, bubbleUpdateInterval);
    }, [bubbles, value]);
    const onProgressTransitionEnd = React.useCallback(() => {
        window.clearTimeout(privateFields.current.onProgressAnimationEndTimeout);
        if (!privateFields.current.currentProgressValueTransitionEndHandled) {
            privateFields.current.currentProgressValueTransitionEndHandled = true;
            onProgressAnimationEnd && onProgressAnimationEnd(value);
        }
    }, [onProgressAnimationEnd, value]);
    React.useEffect(() => {
        const bubbleUpdateTimer = privateFields.current.bubbleUpdateTimer;
        return () => {
            window.clearTimeout(bubbleUpdateTimer);
        };
    }, []);
    React.useEffect(() => {
        if (enableAnimations && !disableBubbles) {
            updateBubbles();
        }
        validateProgressValue(value);
        privateFields.current.currentProgressValueTransitionEndHandled = false;
        window.clearTimeout(privateFields.current.onProgressAnimationEndTimeout);
        privateFields.current.onProgressAnimationEndTimeout = window.setTimeout(onProgressTransitionEnd, exports.TRANSITION_END_TIMEOUT_MS);
    }, [value, disableBubbles, onProgressTransitionEnd, updateBubbles, enableAnimations]);
    const onResize = (contentRect) => {
        if (contentRect.entry) {
            privateFields.current.width = contentRect.entry.width;
        }
    };
    const valueBackgroundStyle = {
        transform: `scaleX(${value / 100})`,
    };
    return ((0, jsx_runtime_1.jsx)(react_measure_1.default, { onResize: onResize, children: ({ measureRef }) => ((0, jsx_runtime_1.jsx)("div", { ref: measureRef, className: (0, classnames_1.default)(progress_bar_css_1.default.progressBar, {
                [progress_bar_css_1.default.small]: size === 'small',
                [progress_bar_css_1.default.critical]: tone === 'critical',
                [progress_bar_css_1.default.animate]: !disableAnimations && enableAnimations,
            }), role: "progressbar", "aria-label": ariaLabel, "aria-valuemin": 0, "aria-valuenow": value, "aria-valuemax": 100, children: (0, jsx_runtime_1.jsx)("div", { className: progress_bar_css_1.default.valueContainer, style: { [progress_bar_css_1.customProperties.valueContainerOffset]: `${value - 100}%` }, children: (0, jsx_runtime_1.jsxs)("div", { className: progress_bar_css_1.default.valueContainer, style: { [progress_bar_css_1.customProperties.valueContainerOffset]: `${100 - value}%` }, children: [(0, jsx_runtime_1.jsx)("div", { className: progress_bar_css_1.default.valueBackground, style: valueBackgroundStyle, onTransitionEnd: onProgressTransitionEnd }), bubbles.map(({ position, type, swap }, i) => ((0, jsx_runtime_1.jsx)("div", { className: (0, classnames_1.default)(bubbleStyles[type], {
                                [progress_bar_css_1.default.bubbleSwap]: swap,
                            }), style: { [progress_bar_css_1.customProperties.bubbleSide]: `${position}px` } }, i)))] }) }) })) }));
};
exports.ProgressBar = ProgressBar;
function validateProgressValue(value) {
    preconditions_1.Preconditions.checkState(value >= 0 && value <= 100, `value must be in [0, 100]; got ${value}`);
}
