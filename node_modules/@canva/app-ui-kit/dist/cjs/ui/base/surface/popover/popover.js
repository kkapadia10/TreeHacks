"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Popover = exports.isReferenceObject = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const compose_react_refs_1 = require("@seznam/compose-react-refs");
const classnames_1 = require("classnames");
const React = require("react");
const react_measure_1 = require("react-measure");
const react_transition_group_1 = require("react-transition-group");
const metrics_1 = require('../../metrics/metrics');
const pin_1 = require('../../pin/pin');
const provider_1 = require('../../provider/provider');
const content_container_1 = require('../internal/content_container');
const popover_css_1 = require("./popover.css");
const WIDTH_CLASS = {
    ['16u']: popover_css_1.default.width16U,
    ['32u']: popover_css_1.default.width32U,
    ['40u']: popover_css_1.default.width40U,
    ['45u']: popover_css_1.default.width45U,
    ['52u']: popover_css_1.default.width52U,
    ['reference']: popover_css_1.default.widthReference,
    auto: undefined,
};
const isReferenceObject = (reference) => {
    const refObj = reference;
    return refObj && typeof refObj.getBoundingClientRect === 'function';
};
exports.isReferenceObject = isReferenceObject;
function Popover(
    { id: idProp, open, onRequestClose, onCloseComplete, blockOutsidePointerEvents = false, reference, placement = 'auto', width = 'auto', widthMode = 'fixed', offset = '1u', children, ...contentContainerProps }
) {
    const defaultId = React.useId();
    const id = idProp || defaultId;
    const customOffsetProvided = typeof offset === 'object';
    const PinComponent = (0, provider_1.useEnableAnimations)() ? TransitionPin : StaticPin;
    const contentContainerRef = React.useRef(null);
    const contentContainerClassName = (0, classnames_1.default)(popover_css_1.default.content, WIDTH_CLASS[width], widthMode === 'maximum' && popover_css_1.default.widthModeMaximum, customOffsetProvided && popover_css_1.default.customOffset);
    const onPlacementUpdate = React.useCallback(data => {
        if (contentContainerRef.current == null) {
            return;
        }
        contentContainerRef.current.style.setProperty(popover_css_1.customProperties.referenceWidth, `${Math.floor(data.offsets.reference.width)}px`);
    }, []);
    const finalPlacement = placement === 'auto' ? 'bottom-start' : placement;
    const offsetStyle = customOffsetProvided
        ? {
            marginTop: offset.top,
            [popover_css_1.customProperties.offsetSpace]: offset.start,
        }
        : {
            [popover_css_1.customProperties.offsetSpace]: (0, metrics_1.getSpaceValue)(offset),
        };
    const pinRef = React.useRef(null);
    const contentHeightRef = React.useRef(0);
    const updatePinPosition = React.useCallback(() => {
        pinRef.current && pinRef.current.dangerouslyForceUpdate();
    }, []);
    const onResize = React.useCallback((contentRect) => {
        var _a, _b;
        const contentHeight = (_b = (_a = contentRect.client) === null || _a === void 0 ? void 0 : _a.height) !== null && _b !== void 0 ? _b : 0;
        if (contentHeightRef.current !== contentHeight) {
            contentHeightRef.current = contentHeight;
            updatePinPosition();
        }
    }, [updatePinPosition]);
    const content = ((0, jsx_runtime_1.jsx)(react_measure_1.default, { onResize: onResize, client: true, children: ({ measureRef }) => {
            return ((0, jsx_runtime_1.jsx)(content_container_1.ContentContainer, { ref: (0, compose_react_refs_1.default)(contentContainerRef, measureRef), className: contentContainerClassName, style: offsetStyle, id: id, onRequestEscape: onRequestClose, ...contentContainerProps, children: children }));
        } }));
    const refObj = (0, exports.isReferenceObject)(reference) ? reference : undefined;
    return ((0, jsx_runtime_1.jsx)(PinComponent, { ref: pinRef, placement: finalPlacement, open: open, onOutsideContentPointerDown: onRequestClose, onCloseComplete: onCloseComplete, blockOutsidePointerEvents: blockOutsidePointerEvents, onPlacementUpdate: onPlacementUpdate, content: content, overflowBoundariesElement: "viewport", positionFixed: true, refObj: refObj, children: typeof reference === 'function'
            ? reference({
                ariaControls: open ? id : undefined,
                active: open,
                disclosure: true,
                ariaHasPopup: contentContainerProps.role,
            })
            : !(0, exports.isReferenceObject)(reference) && reference }));
}
exports.Popover = Popover;
const TRANSITION_DURATION = parseInt(popover_css_1.default.transitionTime, 10);
const TRANSITION_CLASS_NAMES = {
    appear: popover_css_1.default.visible,
    appearActive: popover_css_1.default.visible,
    appearDone: popover_css_1.default.visible,
    enter: popover_css_1.default.visible,
    enterActive: popover_css_1.default.visible,
    enterDone: popover_css_1.default.visible,
    exit: popover_css_1.default.hidden,
    exitActive: popover_css_1.default.hidden,
    exitDone: popover_css_1.default.hidden,
};
const TransitionPin = React.forwardRef(function TransitionPin({ open, onCloseComplete, ...props }, ref) {
    const [transitionOpen, setTransitionOpen] = React.useState(open);
    const nodeRef = React.useRef(null);
    return ((0, jsx_runtime_1.jsx)(pin_1.Pin, { ...props, ref: ref, open: open || transitionOpen, content: (0, jsx_runtime_1.jsx)(react_transition_group_1.CSSTransition, { in: open, appear: true, timeout: TRANSITION_DURATION, classNames: TRANSITION_CLASS_NAMES, onEnter: () => setTransitionOpen(true), onExited: () => {
                setTransitionOpen(false);
                onCloseComplete === null || onCloseComplete === void 0 ? void 0 : onCloseComplete();
            }, nodeRef: nodeRef, children: (0, jsx_runtime_1.jsx)("div", { ref: nodeRef, children: props.content }) }) }));
});
const StaticPin = React.forwardRef(function StaticPin({ open, onCloseComplete, ...props }, ref) {
    const prevOpen = React.useRef(open);
    React.useEffect(() => {
        if (prevOpen.current && !open) {
            onCloseComplete === null || onCloseComplete === void 0 ? void 0 : onCloseComplete();
        }
        prevOpen.current = open;
    }, [open, onCloseComplete]);
    return ((0, jsx_runtime_1.jsx)(pin_1.Pin, { ...props, ref: ref, open: open, content: (0, jsx_runtime_1.jsx)("div", { className: popover_css_1.default.visible, children: props.content }) }));
});
