"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pointForIndex = exports.useResolvedSnapPoints = void 0;
const preconditions_1 = require('../../../../../base/preconditions');
const React = require("react");
const get_safe_area_insets_1 = require('../../../platform_quirks/get_safe_area_insets');
const stable_function_1 = require('../../../stable_function/stable_function');
function useResolvedSnapPoints({ snapPoints, getScrollHeight, }) {
    const resolved = React.useRef();
    const get = (0, stable_function_1.useStableFunction)(() => {
        if (resolved.current != null) {
            return resolved.current;
        }
        const scrollHeight = snapPoints.some(snapPoint => snapPoint.type === 'auto')
            ? getScrollHeight()
            : 0;
        const pending = [];
        for (let index = 0; index < snapPoints.length; index++) {
            const height = resolveSnapPoint(snapPoints[index], scrollHeight);
            const resolvedIndex = pending.findIndex(point => point.height === height);
            if (resolvedIndex === -1) {
                pending.push({ height, indices: [index] });
            }
            else {
                pending[resolvedIndex].indices.push(index);
            }
        }
        resolved.current = pending;
        return resolved.current;
    });
    const clear = (0, stable_function_1.useStableFunction)(() => {
        resolved.current = undefined;
    });
    return {
        snapPointControls: { get, clear },
    };
}
exports.useResolvedSnapPoints = useResolvedSnapPoints;
function resolveSnapPoint(snapPoint, elHeight) {
    const { top, bottom } = (0, get_safe_area_insets_1.getSafeAreaInsets)();
    const availableHeight = window.innerHeight - top - bottom;
    const percentHeight = (availableHeight / 100) * snapPoint.height + bottom;
    switch (snapPoint.type) {
        case 'fixed':
            return percentHeight;
        case 'auto':
            return Math.min(elHeight, percentHeight);
        default:
            throw new preconditions_1.UnreachableError(snapPoint);
    }
}
function pointForIndex(points, snapPointIndex) {
    return preconditions_1.Preconditions.checkExists(points.find(point => point.indices.includes(snapPointIndex)));
}
exports.pointForIndex = pointForIndex;
