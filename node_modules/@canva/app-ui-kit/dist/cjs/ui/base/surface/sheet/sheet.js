"use strict";
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sheet = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const compose_react_refs_1 = require("@seznam/compose-react-refs");
const preconditions_1 = require('../../../../base/preconditions');
const classnames_1 = require("classnames");
const React = require("react");
const react_transition_group_1 = require("react-transition-group");
const keyboard_1 = require('../../device_capabilities/keyboard');
const layer_1 = require('../../layer/layer');
const spacer_1 = require('../../layout/spacer/spacer');
const get_safe_area_insets_1 = require('../../platform_quirks/get_safe_area_insets');
const provider_1 = require('../../provider/provider');
const stable_function_1 = require('../../stable_function/stable_function');
const content_container_1 = require('../internal/content_container');
const behavior_1 = require("./behavior");
const content_scrollable_1 = require("./internal/content_scrollable");
const viewport_difference_1 = require("./internal/viewport_difference");
const visual_viewport_1 = require("./internal/visual_viewport");
const sheet_css_1 = require("./sheet.css");
exports.Sheet = React.forwardRef(function Sheet({ open, onCloseComplete, ...inner }, ref) {
    const Wrapper = (0, provider_1.useEnableAnimations)() ? TransitionWrapper : StaticWrapper;
    return ((0, jsx_runtime_1.jsx)(Wrapper, { open: open, onCloseComplete: onCloseComplete, children: (0, jsx_runtime_1.jsx)(SheetInner, { ...inner, handleRef: ref }) }));
});
const TRANSITION_DURATION = parseInt(sheet_css_1.default.transitionTime, 10);
const TRANSITION_CLASS_NAMES = {
    appear: sheet_css_1.default.transitioning,
    enter: sheet_css_1.default.transitioning,
    exit: sheet_css_1.default.transitioning,
    appearActive: sheet_css_1.default.visible,
    appearDone: sheet_css_1.default.visible,
    enterActive: sheet_css_1.default.visible,
    enterDone: sheet_css_1.default.visible,
};
function TransitionWrapper({ open: propOpen, onCloseComplete, children }) {
    const [transitionOpen, setTransitionOpen] = React.useState(propOpen);
    const nodeRef = React.useRef(null);
    return ((0, jsx_runtime_1.jsx)(layer_1.Layer, { open: propOpen || transitionOpen, children: (0, jsx_runtime_1.jsx)(react_transition_group_1.CSSTransition, { in: propOpen, appear: true, timeout: TRANSITION_DURATION, classNames: TRANSITION_CLASS_NAMES, onEnter: () => setTransitionOpen(true), onExited: () => {
                setTransitionOpen(false);
                onCloseComplete === null || onCloseComplete === void 0 ? void 0 : onCloseComplete();
            }, nodeRef: nodeRef, children: (0, jsx_runtime_1.jsx)("div", { ref: nodeRef, children: children }) }) }));
}
function StaticWrapper({ open, onCloseComplete, children }) {
    const prevOpen = React.useRef(open);
    React.useEffect(() => {
        if (prevOpen.current && !open) {
            onCloseComplete === null || onCloseComplete === void 0 ? void 0 : onCloseComplete();
        }
        prevOpen.current = open;
    }, [open, onCloseComplete]);
    return ((0, jsx_runtime_1.jsx)(layer_1.Layer, { open: open, children: (0, jsx_runtime_1.jsx)("div", { className: sheet_css_1.default.visible, children: children }) }));
}
const heightMap = {
    ['half']: 52,
    ['full']: 100,
};
const dismissPoint = { type: 'fixed', height: 0 };
const isSafari = !!((_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent.match(/AppleWebKit\//))
    && !((_b = window.navigator) === null || _b === void 0 ? void 0 : _b.userAgent.match(/(Chrome|Chromium)\//));
function resolveHeight(height) {
    if (height === 'auto') {
        height = { autoUpTo: 'full' };
    }
    return typeof height === 'string'
        ? { type: 'fixed', height: heightMap[height] }
        : { type: 'auto', height: heightMap[height.autoUpTo] };
}
function SheetInner({ handleRef, height = 'auto', scrollToResizeBelow, onRequestClose, backdropVisible = true, handleSafeAreaInsetBottom = true, id, children, ...contentContainerProps }) {
    var _a, _b;
    const heights = Array.isArray(height) ? height : [height];
    preconditions_1.Preconditions.checkArgument(heights.length > 0, 'Sheets require at least one height value');
    const snapPoints = [
        ...heights.map(resolveHeight),
        ...(onRequestClose != null ? [dismissPoint] : []),
    ];
    const [snapPointIndex, setSnapPointIndex] = useStabilizedSnapPoint(snapPoints);
    const containerRef = React.useRef(null);
    const contentRef = React.useRef(null);
    React.useImperativeHandle(handleRef, () => ({
        setHeight: height => {
            const newPoint = resolveHeight(height);
            const newIndex = snapPoints.findIndex(point => pointsEqual(point, newPoint));
            preconditions_1.Preconditions.checkArgument(newIndex !== -1);
            setSnapPointIndex(newIndex);
        },
        scrollTo: options => { var _a; return (_a = contentRef.current) === null || _a === void 0 ? void 0 : _a.scrollTo(options); },
    }));
    const { resizing, controls } = (0, behavior_1.useSheetControls)({
        snapPoints,
        snapPointIndex,
        setSnapPointIndex: index => {
            setSnapPointIndex(index);
            if (onRequestClose != null && snapPoints[index] === dismissPoint) {
                onRequestClose();
            }
        },
        getScrollHeight: () => {
            const el = containerRef.current;
            if (el == null) {
                return 0;
            }
            const snapHeight = el.style.getPropertyValue(sheet_css_1.customProperties.snapHeight);
            const isAuto = el.classList.contains(sheet_css_1.default.auto);
            el.style.setProperty(sheet_css_1.customProperties.snapHeight, '100%');
            el.classList.add(sheet_css_1.default.auto);
            const scrollHeight = el.scrollHeight;
            el.style.setProperty(sheet_css_1.customProperties.snapHeight, snapHeight);
            el.classList.toggle(sheet_css_1.default.auto, isAuto);
            return scrollHeight;
        },
        setOffset: offset => {
            const el = containerRef.current;
            if (el == null) {
                return;
            }
            el.style.transform = offset != null ? `translateY(${-offset}px)` : '';
        },
    });
    const viewportDifferenceHeight = (0, viewport_difference_1.useViewportHeightDifference)();
    const visualViewport = (0, visual_viewport_1.useVisualViewport)();
    const virtualKeyboardHeight = (0, keyboard_1.getVirtualKeyboardOverlayHeight)() + 'px';
    const hasHandle = heights.length > 1;
    const snapPoint = snapPoints[snapPointIndex];
    const snapHeight = calculateSnapHeight(snapPoint, resizing, (_b = (_a = containerRef.current) === null || _a === void 0 ? void 0 : _a.clientHeight) !== null && _b !== void 0 ? _b : 0);
    const safariTransition = (0, provider_1.useEnableAnimations)() && isSafari;
    return ((0, jsx_runtime_1.jsx)(
        "div",
        { className: (0, classnames_1.default)(sheet_css_1.default.sheetContainer, backdropVisible && sheet_css_1.default.backdrop, 
            safariTransition && sheet_css_1.default.safariTransition), style: {
                [sheet_css_1.customProperties.virtualKeyboardHeight]: virtualKeyboardHeight,
            }, children: (0, jsx_runtime_1.jsx)("div", { className: sheet_css_1.default.safeAreaHandler, style: {
                    [sheet_css_1.customProperties.viewportDifferenceHeight]: viewportDifferenceHeight,
                }, children: (0, jsx_runtime_1.jsxs)("div", { className: (0, classnames_1.default)(sheet_css_1.default.contentContainer, snapPoint.type === 'auto' && sheet_css_1.default.auto, resizing && sheet_css_1.default.resizing), style: {
                        [sheet_css_1.customProperties.snapHeight]: snapHeight,
                        [sheet_css_1.customProperties.visualViewportHeight]: visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.height,
                    }, ref: containerRef, children: [backdropVisible && onRequestClose != null && ((0, jsx_runtime_1.jsx)("div", { role: "none", className: sheet_css_1.default.dismissArea, onClick: onRequestClose })), hasHandle ? (0, jsx_runtime_1.jsx)(SheetDragHandle, { controls: controls }) : (0, jsx_runtime_1.jsx)(spacer_1.Spacer, { size: "3u" }), (0, jsx_runtime_1.jsx)(SheetContent, { ref: contentRef, scrollToResizeBelow: scrollToResizeBelow && resolveHeight(scrollToResizeBelow), controls: controls, handleSafeAreaInsetBottom: handleSafeAreaInsetBottom, id: id, ...contentContainerProps, children: children })] }) }) }
    ));
}
function useStabilizedSnapPoint(snapPoints) {
    const [rawIndex, rawSetIndex] = React.useState(0);
    const currentPoint = snapPoints[rawIndex];
    const previousPoint = React.useRef(currentPoint);
    const setSnapPointIndex = (0, stable_function_1.useStableFunction)((index) => {
        rawSetIndex(index);
        previousPoint.current = snapPoints[index];
    });
    let snapPointIndex = rawIndex;
    if (!pointsEqual(currentPoint, previousPoint.current)) {
        snapPointIndex = snapPoints.findIndex(point => pointsEqual(point, previousPoint.current));
        if (snapPointIndex === -1) {
            snapPointIndex = 0;
        }
        setSnapPointIndex(snapPointIndex);
    }
    return [snapPointIndex, setSnapPointIndex];
}
const pointsEqual = (a, b) => a != null && b != null && a.type === b.type && a.height === b.height;
function calculateSnapHeight(snapPoint, resizing, containerHeight) {
    switch (snapPoint.type) {
        case 'fixed':
            return snapPoint.height + '%';
        case 'auto':
            if (!resizing) {
                return snapPoint.height + '%';
            }
            return containerHeight - (0, get_safe_area_insets_1.getSafeAreaInsets)().bottom + 'px';
        default:
            throw new preconditions_1.UnreachableError(snapPoint);
    }
}
function SheetDragHandle({ controls }) {
    const { dragRef } = (0, behavior_1.useSheetDrag)({ controls });
    return ((0, jsx_runtime_1.jsx)("div", { className: sheet_css_1.default.dragHandleContainer, ref: dragRef, children: (0, jsx_runtime_1.jsx)("div", { className: sheet_css_1.default.dragHandle }) }));
}
const SheetContent = React.forwardRef(function SheetContent({ controls, scrollToResizeBelow, handleSafeAreaInsetBottom, id, children, ...contentContainerProps }, ref) {
    const { contentRef } = (0, behavior_1.useSheetScroll)({ controls, scrollToResizeBelow });
    const { hasScroll, contentScrollRef } = (0, content_scrollable_1.useContentScrollable)();
    const imperativeScrollRef = useImperativeScrollRef(ref);
    return ((0, jsx_runtime_1.jsx)(
        content_container_1.ContentContainer,
        { ref: (0, compose_react_refs_1.default)(contentRef, contentScrollRef, imperativeScrollRef), id: id, className: (0, classnames_1.default)(sheet_css_1.default.content, {
                [sheet_css_1.default.handleSafeAreaInsetBottom]: handleSafeAreaInsetBottom,
                [sheet_css_1.default.noTouchAction]: !hasScroll,
            }), ...contentContainerProps, children: children }
    ));
});
function useImperativeScrollRef(ref) {
    const innerRef = React.useRef(null);
    React.useImperativeHandle(ref, () => ({
        scrollTo: (options) => {
            const el = innerRef === null || innerRef === void 0 ? void 0 : innerRef.current;
            if (el == null) {
                return;
            }
            if (typeof options === 'number') {
                el.scrollTo(0, options);
            }
            else {
                el.scrollTo(options);
            }
        },
    }));
    return innerRef;
}
