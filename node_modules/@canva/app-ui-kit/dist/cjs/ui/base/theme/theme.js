"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WithThemeData = exports.useThemeData = exports.ThemeBoundary = exports.ApplyThemeRoot = exports.cleanThemePreload = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const preconditions_1 = require('../../../base/preconditions');
const mobx_1 = require("mobx");
const mobx_react_1 = require("mobx-react");
const React = require("react");
const provider_1 = require('../provider/provider');
const adaptive_1 = require("./adaptive");
const internal_1 = require("./internal");
const ADAPTIVE_APPEARANCES = ['classicAdaptive', 'adaptive'];
function cleanThemePreload() {
    document.body.classList.remove(...(0, internal_1.getAllPreloadClasses)());
}
exports.cleanThemePreload = cleanThemePreload;
function ApplyThemeRoot({ appearance: givenAppearance, ...ccTheme }) {
    const appearance = useAppearance({ theme: (0, provider_1.useTheme)(), enableHighColorContrast: (0, provider_1.useEnableHighColorContrast)() }, givenAppearance);
    const theme = useThemeMapping(ccTheme);
    const adaptiveColorScheme = (0, adaptive_1.useAdaptiveColorScheme)({
        enabled: ADAPTIVE_APPEARANCES.includes(appearance),
    });
    const resolvedAppearance = resolveAdaptiveAppearance({
        colorScheme: adaptiveColorScheme,
        appearance,
    });
    const mountedRef = React.useRef(false);
    if (!mountedRef.current) {
        mountedRef.current = true;
        (0, mobx_1.runInAction)(() => {
            internal_1.rootThemeStore.setAppearance(resolvedAppearance);
            internal_1.rootThemeStore.setThemeMapping(theme);
        });
    }
    useIsomorphicLayoutEffect((0, mobx_1.action)(() => {
        internal_1.rootThemeStore.setAppearance(resolvedAppearance);
        internal_1.rootThemeStore.setThemeMapping(theme);
    }), [resolvedAppearance, theme]);
    useIsomorphicLayoutEffect(() => (0, mobx_1.action)(() => {
        internal_1.rootThemeStore.setAppearance(undefined);
        internal_1.rootThemeStore.setThemeMapping({});
    }), []);
    useIsomorphicLayoutEffect(() => (0, mobx_1.reaction)(() => internal_1.rootThemeStore.currentTheme, (newTheme, prevTheme) => {
        const { classList } = document.body;
        if (prevTheme != null) {
            classList.remove(...(0, internal_1.getThemeClasses)(prevTheme));
        }
        if (newTheme != null) {
            classList.add(...(0, internal_1.getThemeClasses)(newTheme));
        }
    }, { fireImmediately: true }), []);
    return null;
}
exports.ApplyThemeRoot = ApplyThemeRoot;
function resolveAdaptiveAppearance({ colorScheme, appearance, }) {
    switch (appearance) {
        case 'classicAdaptive':
            return colorScheme === 'dark' ? 'classicDark' : 'classicLight';
        case 'adaptive':
            return colorScheme !== null && colorScheme !== void 0 ? colorScheme : 'light';
        default:
            return appearance;
    }
}
const canUseDOM = () => typeof window !== 'undefined'
    && typeof window.document !== 'undefined'
    && typeof window.document.createElement !== 'undefined';
const useIsomorphicLayoutEffect = canUseDOM() ? React.useLayoutEffect : React.useEffect;
exports.ThemeBoundary = (0, mobx_react_1.observer)(function ThemeBoundary({ children, ...ccTheme }) {
    const theme = useThemeMapping(ccTheme);
    const [themeContext] = React.useState(() => {
        const store = new internal_1.ThemeStore();
        return {
            store,
            data: new internal_1.ThemeData(store),
        };
    });
    const { store: parentStore } = React.useContext(internal_1.ThemeContext);
    themeContext.store.setParent(parentStore);
    themeContext.store.setThemeMapping(theme);
    return ((0, jsx_runtime_1.jsx)(
        internal_1.ThemeContext.Provider,
        { value: themeContext, children: children(themeContext.data) }
    ));
});
function useThemeMapping(theme) {
    return React.useMemo(() => ({
        ['classicLight']: theme.classicLight,
        ['classicDark']: theme.classicDark,
        ['light']: theme.light,
        ['dark']: theme.dark,
    }), [theme.classicLight, theme.classicDark, theme.light, theme.dark]);
}
const useThemeData = () => React.useContext(internal_1.ThemeContext).data;
exports.useThemeData = useThemeData;
exports.WithThemeData = (0, mobx_react_1.observer)(function WithThemeData({ children }) {
    const data = (0, exports.useThemeData)();
    return children(data);
});
function useAppearance({ theme, enableHighColorContrast }, givenAppearance) {
    switch (theme) {
        case undefined:
            return givenAppearance;
        case 'ADAPTIVE':
            return enableHighColorContrast ? 'adaptive' : 'classicAdaptive';
        case 'LIGHT':
            return enableHighColorContrast ? 'light' : 'classicLight';
        case 'DARK':
            return enableHighColorContrast ? 'dark' : 'classicDark';
        default:
            throw new preconditions_1.UnreachableError(theme);
    }
}
