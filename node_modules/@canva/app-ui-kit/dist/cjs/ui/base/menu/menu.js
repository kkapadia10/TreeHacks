"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ToggleMenu = exports.MenuDivider = exports.MenuItemButton = exports.MenuItem = exports.Menu = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const preconditions_1 = require('../../../base/preconditions');
const classnames_1 = require("classnames");
const mobx_react_1 = require("mobx-react");
const React = require("react");
const access_mode_state_1 = require('../a11y/access_mode_state/access_mode_state');
const box_1 = require('../box/box');
const button_1 = require('../button/button');
const controllable_value_1 = require('../controllable_value/controllable_value');
const divider_1 = require('../divider/divider');
const icon_1 = require('../icons/chevron_down/icon');
const icon_2 = require('../icons/chevron_right/icon');
const layout_1 = require('../layout/layout');
const typography_1 = require('../typography/typography');
const menu_css_1 = require("./menu.css");
const menu_messages_1 = require("./menu.messages");
const MenuContext = React.createContext(undefined);
exports.Menu = React.forwardRef(function Menu(props, ref) {
    var _a;
    const navigationRole = props.role === 'navigation';
    const [hasToggleMenu, setHasToggleMenu] = React.useState(false);
    const menuClassName = (0, classnames_1.default)(menu_css_1.default.menu, !navigationRole && props.className, {
        [menu_css_1.default.rounded]: props.variant === 'rounded',
        [menu_css_1.default.bleedX]: !!props.bleedX,
        [menu_css_1.default.spacing]: props.spacing === '1u' || (props.variant === 'rounded' && props.spacing !== '0'),
        [menu_css_1.default.horizontal]: props.role !== 'listbox' && props.direction === 'horizontal',
        [menu_css_1.default.hasToggleMenu]: hasToggleMenu,
    });
    const content = ((0, jsx_runtime_1.jsx)(box_1.Box, { id: props.id, ariaActiveDescendant: props.ariaActiveDescendant, ariaMultiSelectable: props.ariaMultiSelectable, ariaLabel: props.ariaLabel, ariaLabelledBy: props.ariaLabelledBy, tagName: (_a = props.tagName) !== null && _a !== void 0 ? _a : 'ul', role: props.role === 'navigation' ? 'list' : props.role, ref: ref, className: menuClassName, children: props.children }));
    const maybeWrappedContent = navigationRole
        ? (0, jsx_runtime_1.jsx)("nav", { className: navigationRole && props.className, children: content })
        : content;
    const context = React.useMemo(() => ({
        menuRole: props.role,
        menuDirection: props.role !== 'listbox' ? props.direction : undefined,
        menuVariant: props.variant,
        menuSpacing: props.spacing,
        registerToggleMenu: () => setHasToggleMenu(true),
    }), [props.role, props.direction, props.variant, props.spacing]);
    return (0, jsx_runtime_1.jsx)(MenuContext.Provider, { value: context, children: maybeWrappedContent });
});
exports.Menu.displayName = 'Menu';
function getMenuItemRoles(menuRole) {
    switch (menuRole) {
        case 'menu':
        case 'menubar':
            return { boxRole: 'none', buttonRole: 'menuitem' };
        case 'listbox':
        case 'group':
            return { boxRole: 'option', buttonRole: undefined };
        default:
            return { boxRole: undefined, buttonRole: undefined };
    }
}
exports.MenuItem = React.memo(function MenuItem({ id, buttonId, children, className, active, disabled, disclosure, draggable, onFocus, onBlur, onMouseEnter, onMouseLeave, tabIndex, start, end, label, description, lineClamp, buttonRef, focusRef, tooltipLabel, ariaLabel, ariaLabelledBy, ariaHasPopup, ariaControls, ariaSelected, href, target, onClick, }) {
    const context = preconditions_1.Preconditions.checkExists(React.useContext(MenuContext), 'MenuItem should not be used outside of a Menu');
    const { boxRole, buttonRole } = getMenuItemRoles(context.menuRole);
    return ((0, jsx_runtime_1.jsx)(box_1.Box, { tagName: "li", id: id, role: boxRole, className: menu_css_1.default.menuItem, ariaDisabled: disabled, ariaSelected: ariaSelected, children: (0, jsx_runtime_1.jsx)(exports.MenuItemButton, { id: buttonId, role: buttonRole, tabIndex: tabIndex, buttonRef: buttonRef, focusRef: focusRef, className: className, href: href, target: target, onClick: onClick, start: start, end: end, label: label, description: description, lineClamp: lineClamp, alignment: context.menuDirection === 'horizontal' ? 'center' : 'start', active: active, disabled: disabled, disclosure: disclosure, draggable: draggable, onFocus: onFocus, onBlur: onBlur, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, tooltipLabel: tooltipLabel, ariaLabel: ariaLabel, ariaLabelledBy: ariaLabelledBy, ariaHasPopup: ariaHasPopup, ariaControls: ariaControls, children: children }) }));
});
exports.MenuItem.displayName = 'MenuItem';
exports.MenuItemButton = (0, mobx_react_1.observer)(function MenuItemButton({ id, role, alignment, children, className, active, disabled, draggable, disclosure, onFocus, onBlur, onMouseEnter, onMouseLeave, tabIndex, start, end, label, description, lineClamp, buttonRef, focusRef, tooltipLabel, ariaLabel, ariaLabelledBy, ariaHasPopup, ariaControls, ariaSelected, ...props }) {
    const hideOutline = access_mode_state_1.accessModeState.isMouseMode;
    const labelId = React.useId();
    const descriptionId = React.useId();
    const buttonClassName = (0, classnames_1.default)(menu_css_1.default.menuItemButton, {
        [menu_css_1.default.hideOutline]: hideOutline,
    }, className);
    const buttonOrLinkProps = props.href
        ? { type: 'link', href: props.href, target: props.target, onClick: props.onClick }
        : { onClick: props.onClick };
    const contentNodes = [];
    if (children && typeof children !== 'string' && typeof children !== 'number') {
        contentNodes.push(children);
    }
    else {
        const text = label !== null && label !== void 0 ? label : children;
        text !== undefined
            && contentNodes.push((0, jsx_runtime_1.jsx)(typography_1.Text, { id: label ? labelId : undefined, tagName: "span", tone: typography_1.InheritColor, alignment: alignment, lineClamp: lineClamp, children: text }, contentNodes.length));
        label
            && description
            && contentNodes.push((0, jsx_runtime_1.jsx)(typography_1.Text, { id: descriptionId, tagName: "span", size: "small", tone: "tertiary", alignment: alignment, children: description }, contentNodes.length));
    }
    const content = contentNodes.length > 1
        ? ((0, jsx_runtime_1.jsx)(layout_1.Rows, { tagName: "span", spacing: "0", children: contentNodes }))
        : contentNodes;
    return ((0, jsx_runtime_1.jsx)(button_1.BasicButton, { id: id, role: role, tabIndex: tabIndex, buttonRef: buttonRef, focusRef: focusRef, className: buttonClassName, noChildWrapper: true, alignment: "start", active: active, disabled: disabled, draggable: draggable, disclosure: disclosure, onFocus: onFocus, onBlur: onBlur, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, tooltipLabel: tooltipLabel, ariaLabel: ariaLabel, ariaLabelledBy: label ? labelId : ariaLabelledBy, ariaDescribedBy: description ? descriptionId : undefined, ariaHasPopup: ariaHasPopup, ariaControls: ariaControls, ...buttonOrLinkProps, children: start || end
            ? ((0, jsx_runtime_1.jsxs)(layout_1.Columns, { tagName: "span", alignY: "center", spacing: "1u", children: [start ? renderDecorator(typeof start === 'function' ? start() : start) : null, (0, jsx_runtime_1.jsx)(layout_1.Column, { tagName: "span", children: content }), end ? renderDecorator(typeof end === 'function' ? end() : end) : null] }))
            : content }));
});
const renderDecorator = (decorator) => React.isValidElement(decorator) && decorator.type === React.Fragment
    ? ((0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: React.Children.map(decorator.props.children, (child) => child && renderDecorator(child)) }))
    : ((0, jsx_runtime_1.jsx)(layout_1.Column, { tagName: "span", width: "content", children: decorator }));
exports.MenuDivider = React.memo(function MenuDivider({ id, children, }) {
    const context = preconditions_1.Preconditions.checkExists(React.useContext(MenuContext), 'MenuDivider should not be used outside of a Menu');
    const dividerDirection = context.menuDirection === 'horizontal' ? 'vertical' : 'horizontal';
    return ((0, jsx_runtime_1.jsxs)("li", { role: "none", id: id, children: [(0, jsx_runtime_1.jsx)("div", { className: menu_css_1.default.menuDivider, children: (0, jsx_runtime_1.jsx)(divider_1.Divider, { direction: dividerDirection }) }), children && ((0, jsx_runtime_1.jsx)(typography_1.Text, { size: "small", weight: "bold", tagName: "div", tone: "secondary", className: menu_css_1.default.menuDividerText, children: children }))] }));
});
exports.MenuDivider.displayName = 'MenuDivider';
exports.ToggleMenu = React.forwardRef(function ToggleMenu({ id, menuId: menuIdProp, labelId: labelIdProp, label, labelNode, disabled, draggable, start, end, active, buttonRef, tooltipLabel, href, onClick, onToggleClick, toggleLabel, defaultExpanded, expanded: expandedProp, buttonClassName, ...props }, ref) {
    const [expanded, setExpanded] = (0, controllable_value_1.useControllableValue)({
        value: expandedProp,
        defaultValue: defaultExpanded,
        onChange: onToggleClick,
    });
    const toggleExpanded = React.useCallback(() => setExpanded(!expanded), [expanded, setExpanded]);
    const context = React.useContext(MenuContext);
    React.useEffect(() => {
        context === null || context === void 0 ? void 0 : context.registerToggleMenu();
    }, [context]);
    const Icon = expanded ? icon_1.ChevronDownIcon : icon_2.ChevronRightIcon;
    const generatedMenuId = React.useId();
    const menuId = menuIdProp !== null && menuIdProp !== void 0 ? menuIdProp : generatedMenuId;
    const generatedLabelId = React.useId();
    const labelId = labelIdProp !== null && labelIdProp !== void 0 ? labelIdProp : generatedLabelId;
    const toggleButtonProps = {
        onClick: toggleExpanded,
        disclosure: true,
        ariaControls: expanded ? menuId : undefined,
        active: expanded,
    };
    const showSeparateToggleButton = href || onClick;
    const menuItemClickProps = showSeparateToggleButton
        ? {
            href,
            onClick,
        }
        : {
            className: menu_css_1.default.activeOverride,
            ...toggleButtonProps,
        };
    return ((0, jsx_runtime_1.jsxs)(box_1.Box, { ref: ref, tagName: context ? 'li' : 'div', id: id, className: menu_css_1.default.toggleMenuBox, children: [(0, jsx_runtime_1.jsx)(exports.MenuItemButton, { id: labelId, className: buttonClassName, active: active, disabled: disabled, start: (0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [showSeparateToggleButton
                            ? (0, jsx_runtime_1.jsx)(layout_1.Spacer, { size: "1u", direction: "horizontal" })
                            : ((0, jsx_runtime_1.jsxs)(box_1.Box, { tagName: "span", className: menu_css_1.default.toggleMenuIconBox, children: [(0, jsx_runtime_1.jsx)(layout_1.Spacer, { size: "1u", direction: "horizontal" }), (0, jsx_runtime_1.jsx)(Icon, { size: "small", className: menu_css_1.default.toggleMenuIcon })] })), start] }), end: end, lineClamp: 1, buttonRef: buttonRef, tooltipLabel: tooltipLabel, ariaLabel: labelNode ? label : undefined, draggable: draggable, ...menuItemClickProps, children: labelNode || label }), showSeparateToggleButton && ((0, jsx_runtime_1.jsx)(button_1.Button, { className: (0, classnames_1.default)(menu_css_1.default.activeOverride, menu_css_1.default.toggleButton), variant: "tertiary", iconSize: "small", icon: Icon, ariaLabel: (toggleLabel !== null && toggleLabel !== void 0 ? toggleLabel : expanded)
                    ? menu_messages_1.MenuMessages.collapseMenu(label)
                    : menu_messages_1.MenuMessages.expandMenu(label), disabled: disabled, ...toggleButtonProps })), expanded && props.children && ((0, jsx_runtime_1.jsx)(exports.Menu, { id: menuId, ariaLabelledBy: labelId, variant: context === null || context === void 0 ? void 0 : context.menuVariant, spacing: context === null || context === void 0 ? void 0 : context.menuSpacing, ...props }))] }));
});
