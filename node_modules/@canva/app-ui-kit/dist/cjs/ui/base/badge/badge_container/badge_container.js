"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExtendedBadgeVisibilityTrigger = exports.SwapOnHover = exports.VisibleOnHover = exports.BadgeGroup = exports.BadgeContainer = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const classnames_1 = require("classnames");
const mobx_react_1 = require("mobx-react");
const React = require("react");
const access_mode_state_1 = require('../../a11y/access_mode_state/access_mode_state');
const pointer_input_state_1 = require('../../a11y/pointer_input_state/pointer_input_state');
const badge_container_css_1 = require("./badge_container.css");
const paddingStyleClassMap = {
    ['compact']: badge_container_css_1.default.compact,
    ['standard']: undefined,
};
const transitionClassMap = {
    ['fade']: badge_container_css_1.default.fxFade,
    ['slide']: badge_container_css_1.default.fxSlide,
    ['none']: badge_container_css_1.default.fxAppear,
};
exports.BadgeContainer = React.forwardRef(({ children, paddingStyle = 'standard', className, ariaLabel, ariaLabelledBy, role, }, ref) => ((0, jsx_runtime_1.jsx)(mobx_react_1.Observer, { children: () => ((0, jsx_runtime_1.jsx)("div", { ref: ref, className: (0, classnames_1.default)(badge_container_css_1.default.container, badge_container_css_1.default.hoverTrigger, paddingStyleClassMap[paddingStyle], className, {
            [badge_container_css_1.default.focusVisible]: access_mode_state_1.accessModeState.isKeyboardMode,
        }), role: role, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, children: children })) })));
function BadgeGroup({ location, visibility = 'always', transition, children, stretch, }) {
    return ((0, jsx_runtime_1.jsx)(
        "span",
        { className: (0, classnames_1.default)(badge_container_css_1.default.badgeGroup, location && getLocationClasses(location), transition ? transitionClassMap[transition] : badge_container_css_1.default.defaultFx, {
                [badge_container_css_1.default.hoverTarget]: visibility === 'on-hover',
                [badge_container_css_1.default.pinning]: location != null,
                [badge_container_css_1.default.stretch]: stretch,
            }), children: children }
    ));
}
exports.BadgeGroup = BadgeGroup;
exports.VisibleOnHover = (0, mobx_react_1.observer)(({ children, transition, showOnTouchDevice = false, }) => {
    const isMouseInput = pointer_input_state_1.pointerInputState.isMouseInput;
    if (!isMouseInput && !showOnTouchDevice) {
        return (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, {});
    }
    return ((0, jsx_runtime_1.jsx)("span", { className: (0, classnames_1.default)(badge_container_css_1.default.badgeGroup, transition ? transitionClassMap[transition] : badge_container_css_1.default.defaultFx, {
            [badge_container_css_1.default.hoverTarget]: isMouseInput,
        }), children: children }));
});
const SwapOnHover = ({ onHover, children, }) => ((0, jsx_runtime_1.jsxs)("span", { className: badge_container_css_1.default.swapOnHoverWrapper, children: [(0, jsx_runtime_1.jsx)("span", { className: badge_container_css_1.default.hideOnHover, children: children }), (0, jsx_runtime_1.jsx)("span", { className: badge_container_css_1.default.showOnHover, children: onHover })] }));
exports.SwapOnHover = SwapOnHover;
function getLocationClasses(location) {
    return {
        [badge_container_css_1.default.top]: location === 'top-start' || location === 'top-end',
        [badge_container_css_1.default.bottom]: location === 'bottom-start' || location === 'bottom-end',
        [badge_container_css_1.default.left]: location === 'top-start' || location === 'bottom-start' || location === 'center-start',
        [badge_container_css_1.default.right]: location === 'top-end' || location === 'bottom-end' || location === 'center-end',
        [badge_container_css_1.default.verticalCenter]: location === 'center-start' || location === 'center-end',
    };
}
exports.ExtendedBadgeVisibilityTrigger = (0, mobx_react_1.observer)(React.forwardRef(({ children, tagName = 'div', role, className, onMouseEnter, onMouseLeave, ariaLabelledBy, ariaDescribedBy, }, ref) => React.createElement(tagName, {
    className: (0, classnames_1.default)(className, badge_container_css_1.default.hoverTrigger, {
        [badge_container_css_1.default.focusVisible]: access_mode_state_1.accessModeState.isKeyboardMode,
    }),
    onMouseEnter,
    onMouseLeave,
    ['aria-labelledby']: ariaLabelledBy,
    ['aria-describedby']: ariaDescribedBy,
    role,
    ref,
}, children)));
