"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderButtonOrAnchor = exports.renderAnchor = exports.renderButton = exports.CircleButtonWithLabel = exports.CircleButtonWithoutLabel = exports.AnchorWithTooltip = exports.ButtonWithTooltip = exports.Anchor = exports.InternalButton = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const compose_react_refs_1 = require("@seznam/compose-react-refs");
const classnames_1 = require("classnames");
const mobx_react_1 = require("mobx-react");
const React = require("react");
const access_mode_state_1 = require('../../a11y/access_mode_state/access_mode_state');
const button_aria_attributes_1 = require('../../a11y/button_aria_attributes/button_aria_attributes');
const pointer_input_state_1 = require('../../a11y/pointer_input_state/pointer_input_state');
const screen_reader_content_1 = require('../../a11y/screen_reader_content/screen_reader_content');
const device_capabilities_1 = require('../../device_capabilities/device_capabilities');
const focusable_1 = require('../../focusable/focusable');
const icon_1 = require('../../icons/animated_loading/icon');
const link_messages_1 = require('../../link/link.messages');
const provider_1 = require('../../provider/provider');
const tooltip_1 = require('../../tooltip/tooltip');
const typography_1 = require('../../typography/typography');
const button_css_1 = require("../button.css");
const button_messages_1 = require("../button.messages");
const repeat_click_wrapper_1 = require("./repeat_click_wrapper");
const submit_store_1 = require("./submit_store");
const getButtonContent = (props) => {
    const { children, iconPosition = 'start', noChildWrapper, icon: Icon, LoadingIcon = icon_1.AnimatedLoadingIcon, } = props;
    const content = [];
    let displayIcon = null;
    const hiddenAttrs = { ['aria-hidden']: props.loading || undefined };
    if (Icon) {
        displayIcon = ((0, jsx_runtime_1.jsx)("span", { className: button_css_1.default.iconWrapper, ...hiddenAttrs, children: (0, jsx_runtime_1.jsx)(Icon, { size: props.iconSize || 'medium' }) }, "icon"));
    }
    if (iconPosition === 'start' || iconPosition === 'top') {
        content.push(displayIcon);
    }
    if (children) {
        content.push(noChildWrapper
            ? children
            : ((0, jsx_runtime_1.jsx)("span", { className: button_css_1.default.text, ...hiddenAttrs, children: children }, "content")));
    }
    if (iconPosition === 'end') {
        content.push(displayIcon);
    }
    if (props.loading) {
        const loadingIconSize = props.iconSize || 'medium';
        content.push((0, jsx_runtime_1.jsxs)("span", { className: button_css_1.default.loadingIconWrapper, children: [(0, jsx_runtime_1.jsx)(LoadingIcon, { size: loadingIconSize }), (0, jsx_runtime_1.jsx)(screen_reader_content_1.ScreenReaderContent, { ariaLive: "assertive", children: props.loadingMessage || button_messages_1.ButtonMessages.loading() })] }, "loading"));
    }
    return content;
};
const useClassName = (isAnchor, { children, alignment = 'center', on, loading, disabled, stretch, variant, hideOutline, iconPosition, shape, size, icon, iconSize, }) => {
    const trueSize = getSize({ children, iconSize, size, variant });
    const squareSizing = allowSquareSizing({ children, variant, stretch, icon });
    return (0, classnames_1.default)(button_css_1.default.base, {
        [button_css_1.default.anchor]: isAnchor,
        [button_css_1.default.button]: variant !== 'basic',
        [button_css_1.default.hideOutline]: hideOutline,
        [button_css_1.default.topIcon]: iconPosition === 'top',
        [button_css_1.default.startIcon]: icon && (!iconPosition || iconPosition === 'start'),
        [button_css_1.default.endIcon]: icon && iconPosition === 'end',
        [button_css_1.default.noMinWidth]: squareSizing,
        [button_css_1.default.circleShape]: shape === 'circle',
    }, (0, button_css_1.getStyle)(variant), trueSize && (0, button_css_1.getStyle)(trueSize), {
        [button_css_1.default.on]: on,
        [button_css_1.default.stretch]: stretch,
        [button_css_1.default.loading]: loading,
        [button_css_1.default.disabled]: disabled,
        [button_css_1.default.startAlign]: alignment === 'start',
        [button_css_1.default.centerAlign]: alignment === 'center',
        [button_css_1.default.endAlign]: alignment === 'end',
        [button_css_1.default.hoverSupported]: !pointer_input_state_1.pointerInputState.isTouchInput && (0, device_capabilities_1.canHover)(),
        [button_css_1.default.animate]: (0, provider_1.useEnableAnimations)(),
        [button_css_1.default.tinyWidth]: trueSize === 'tiny' && squareSizing,
        [button_css_1.default.smallWidth]: trueSize === 'small' && squareSizing,
        [button_css_1.default.mediumWidth]: trueSize === 'medium' && squareSizing,
        [button_css_1.default.largeWidth]: trueSize === 'large' && squareSizing,
    });
};
exports.InternalButton = (0, mobx_react_1.observer)(function InternalButton(props) {
    const buttonSubmitStore = props._submitStore || submitStore;
    const ref = (0, compose_react_refs_1.default)((0, focusable_1.useFocusableRef)(props.focusRef), props.buttonRef);
    React.useEffect(() => buttonSubmitStore.enable(), [buttonSubmitStore]);
    const disabledAttribute = props.type === 'submit' && buttonSubmitStore.shouldDisableSubmit;
    const disabledStyle = disabledAttribute || props.disabled;
    const disabled = disabledAttribute || props.disabled || props.loading;
    const className = useClassName(false, {
        ...props,
        hideOutline: access_mode_state_1.accessModeState.isMouseMode,
        on: props.active,
        disabled: disabledStyle,
    });
    const children = !props.expandClickableArea
        ? getButtonContent(props)
        : (0, jsx_runtime_1.jsx)("span", { className: className, children: getButtonContent(props) });
    const onClickImpl = props.onClick;
    const onClick = React.useCallback((e) => {
        if (disabled) {
            e.preventDefault();
        }
        else {
            onClickImpl === null || onClickImpl === void 0 ? void 0 : onClickImpl(e);
        }
    }, [disabled, onClickImpl]);
    const stopPropagationWhenDisabled = disabled
        ? (e) => {
            const shouldPrevent = ['click', 'mousedown', 'mouseup', 'submit'].includes(e.type)
                || !('code' in e)
                || ['Enter', 'Space'].includes(e.code);
            if (shouldPrevent) {
                e.stopPropagation();
                e.preventDefault();
            }
        }
        : undefined;
    return ((0, jsx_runtime_1.jsx)(repeat_click_wrapper_1.RepeatClickWrapper, { onClick: onClick, repeatSpeed: props.repeatSpeed, disabled: disabled, children: repeatClickWrapperProps => {
            var _a;
            return ((0, jsx_runtime_1.jsx)("button", { id: props.id, onMouseDown: e => { var _a; return access_mode_state_1.accessModeState.setAccessMode('mouse') && ((_a = props.onMouseDown) === null || _a === void 0 ? void 0 : _a.call(props, e)); }, className: (0, classnames_1.default)(props.expandClickableArea ? button_css_1.default.expandClickableAreaContainer : className, props.className), form: props.form, onMouseUp: props.onMouseUp, onMouseEnter: props.onMouseEnter, onMouseLeave: props.onMouseLeave, onContextMenu: props.onContextMenu, onBlur: props.onBlur, onFocus: props.onFocus, onDragStart: props.onDragStart, onDragEnd: props.onDragEnd, draggable: props.draggable, onClickCapture: stopPropagationWhenDisabled, onMouseDownCapture: stopPropagationWhenDisabled, onKeyDownCapture: stopPropagationWhenDisabled, onMouseUpCapture: stopPropagationWhenDisabled, disabled: disabledAttribute, type: props.type || 'button', ...(0, button_aria_attributes_1.getButtonAriaAttributes)({
                    ...props,
                    tagName: 'button',
                    active: (_a = props.ariaPressed) !== null && _a !== void 0 ? _a : props.active,
                    disabled,
                }), ...repeatClickWrapperProps, ref: ref, children: children }));
        } }));
});
exports.Anchor = (0, mobx_react_1.observer)(function InternalAnchor(props) {
    const ref = (0, compose_react_refs_1.default)((0, focusable_1.useFocusableRef)(props.focusRef), props.buttonRef);
    const semanticallyDisabled = props.disabled || props.loading;
    const targetBlank = props.target === '_blank';
    const rel = targetBlank && !props.rel ? 'noopener' : props.rel;
    const className = useClassName(true, {
        ...props,
        hideOutline: access_mode_state_1.accessModeState.isMouseMode,
        on: props.active,
    });
    const children = !props.expandClickableArea
        ? getButtonContent(props)
        : (0, jsx_runtime_1.jsx)("span", { className: className, children: getButtonContent(props) });
    let linkProps;
    if (!semanticallyDisabled) {
        linkProps = {
            onClick: props.onClick,
            onDragStart: props.onDragStart,
            onDragEnd: props.onDragEnd,
            onFocus: props.onFocus,
            onBlur: props.onBlur,
            onContextMenu: props.onContextMenu,
            onMouseEnter: props.onMouseEnter,
            onMouseLeave: props.onMouseLeave,
            href: props.href,
            target: props.target,
            rel,
            download: props.download,
            draggable: props.draggable,
        };
    }
    else {
        linkProps = {
            onClick: (e) => e.preventDefault(),
            href: props.href,
            target: props.target,
            download: props.download,
        };
    }
    return ((0, jsx_runtime_1.jsxs)("a", { id: props.id, ref: ref, ...linkProps, className: (0, classnames_1.default)(props.expandClickableArea ? button_css_1.default.expandClickableAreaContainer : className, props.className), ...(0, button_aria_attributes_1.getButtonAriaAttributes)({ tagName: 'a', disabled: semanticallyDisabled, ...props }), children: [children, targetBlank && ((0, jsx_runtime_1.jsx)(screen_reader_content_1.ScreenReaderContent, { tagName: "span", children: link_messages_1.LinkMessages.opensInNewWindow() }))] }));
});
const ButtonWithTooltipInner = ({ buttonProps, tooltipTriggerProps, }) => {
    let ariaProps;
    if (buttonProps.ariaLabelledBy != null
        || buttonProps.ariaLabel != null
        || buttonProps.children != null) {
        ariaProps = { ariaDescribedBy: tooltipTriggerProps.tooltipId };
    }
    else {
        ariaProps = { ariaLabel: buttonProps.tooltipLabel };
    }
    const onMouseEnter = (event) => {
        var _a, _b;
        (_a = buttonProps.onMouseEnter) === null || _a === void 0 ? void 0 : _a.call(buttonProps, event);
        (_b = tooltipTriggerProps.onMouseEnter) === null || _b === void 0 ? void 0 : _b.call(tooltipTriggerProps);
    };
    const onMouseLeave = (event) => {
        var _a, _b;
        (_a = buttonProps.onMouseLeave) === null || _a === void 0 ? void 0 : _a.call(buttonProps, event);
        (_b = tooltipTriggerProps.onMouseLeave) === null || _b === void 0 ? void 0 : _b.call(tooltipTriggerProps);
    };
    const onMouseDown = (event) => {
        var _a, _b;
        (_a = buttonProps.onMouseDown) === null || _a === void 0 ? void 0 : _a.call(buttonProps, event);
        (_b = tooltipTriggerProps.onMouseDown) === null || _b === void 0 ? void 0 : _b.call(tooltipTriggerProps);
    };
    const onFocus = (event) => {
        var _a, _b;
        (_a = buttonProps.onFocus) === null || _a === void 0 ? void 0 : _a.call(buttonProps, event);
        (_b = tooltipTriggerProps.onFocus) === null || _b === void 0 ? void 0 : _b.call(tooltipTriggerProps);
    };
    const onBlur = (event) => {
        var _a, _b;
        (_a = buttonProps.onBlur) === null || _a === void 0 ? void 0 : _a.call(buttonProps, event);
        (_b = tooltipTriggerProps.onBlur) === null || _b === void 0 ? void 0 : _b.call(tooltipTriggerProps);
    };
    return ((0, jsx_runtime_1.jsx)(exports.InternalButton, { ...buttonProps, ...ariaProps, onFocus: onFocus, onBlur: onBlur, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, onMouseDown: onMouseDown, tooltipLabel: undefined }));
};
exports.ButtonWithTooltip = (0, mobx_react_1.observer)(function ButtonWithTooltip(props) {
    const tooltip = ((0, jsx_runtime_1.jsx)(tooltip_1.Tooltip, { label: props.tooltipLabel, shortcut: props.tooltipShortcut, disabled: props.tooltipDisabled, placement: props.tooltipPlacement, overflowBoundariesElement: props.tooltipOverflowBoundariesElement, closeOnClick: props.tooltipCloseOnClick, children: triggerProps => {
            return (0, jsx_runtime_1.jsx)(ButtonWithTooltipInner, { buttonProps: props, tooltipTriggerProps: triggerProps });
        } }));
    return props.stretch ? (0, jsx_runtime_1.jsx)("div", { className: button_css_1.default.stretchWrapper, children: tooltip }) : tooltip;
});
exports.AnchorWithTooltip = (0, mobx_react_1.observer)(function AnchorWithTooltip(props) {
    const button = props.disabled
        ? ((0, jsx_runtime_1.jsx)("div", { className: button_css_1.default.disabledContainer, children: (0, jsx_runtime_1.jsx)(exports.Anchor, { ...props, tooltipLabel: undefined, ariaLabel: props.ariaLabel || props.tooltipLabel }) }))
        : ((0, jsx_runtime_1.jsx)(exports.Anchor, { ...props, tooltipLabel: undefined, ariaLabel: props.ariaLabel || props.tooltipLabel }));
    return ((0, jsx_runtime_1.jsx)(tooltip_1.Tooltip, { label: props.tooltipLabel, shortcut: props.tooltipShortcut, disabled: props.tooltipDisabled, placement: props.tooltipPlacement, closeOnClick: props.tooltipCloseOnClick, children: button }));
});
const CircleButtonWithoutLabel = (props) => {
    return ((0, jsx_runtime_1.jsx)(ElevatedWrapper, { ...props, shape: "circle", children: (0, exports.renderButton)({ ...props, shape: 'circle' }) }));
};
exports.CircleButtonWithoutLabel = CircleButtonWithoutLabel;
function CircleButtonWithLabel({ variant, children, ...props }) {
    const labelId = React.useId();
    const size = getSize({ ...props, variant });
    return ((0, jsx_runtime_1.jsxs)(
        "div",
        { className: (0, classnames_1.default)(button_css_1.default.circleShapeWrapper, {
                [button_css_1.default.circleShapeWrapperXsmall]: size === 'xsmall',
                [button_css_1.default.circleShapeWrapperSmall]: size === 'small',
                [button_css_1.default.circleShapeWrapperMedium]: size === 'medium',
                [button_css_1.default.circleShapeWrapperLarge]: size === 'large',
            }), children: [(0, jsx_runtime_1.jsx)(ElevatedWrapper, { ...props, variant: variant, shape: "circle", children: 
                    (0, exports.renderButton)({
                        ...props,
                        tooltipLabel: props.tooltipLabel,
                        tooltipPlacement: props.tooltipPlacement || 'top',
                        shape: 'circle',
                        variant,
                        ariaLabelledBy: labelId,
                    }) }), (0, jsx_runtime_1.jsx)("label", { className: button_css_1.default.circleButtonLabel, children: (0, jsx_runtime_1.jsx)(typography_1.Text, { size: "small", id: labelId, tagName: "span", alignment: "center", tone: "secondary", lineClamp: 2, children: children }) })] }
    ));
}
exports.CircleButtonWithLabel = CircleButtonWithLabel;
function allowSquareSizing({ children, stretch, variant, icon, }) {
    return !children && !!icon && !stretch && ['subtleLinkButton'].indexOf(variant) === -1;
}
function getSize({ children, iconSize, size, variant, }) {
    if (['subtleLinkButton'].indexOf(variant) !== -1) {
        return;
    }
    if (size && size !== 'default') {
        return size;
    }
    if (variant === 'basic') {
        return;
    }
    if (!children && iconSize && ['tiny', 'small', 'large'].indexOf(iconSize) !== -1) {
        return iconSize;
    }
    return 'medium';
}
const ElevatedWrapper = (0, mobx_react_1.observer)(function ElevatedWrapper(props) {
    if (props.elevated && props.shape === 'circle' && props.variant !== 'contrast') {
        return ((0, jsx_runtime_1.jsx)("div", { className: (0, classnames_1.default)(button_css_1.default.elevatedWrapper, props.containerClassName), children: props.children }));
    }
    return (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: props.children });
});
const submitStore = new submit_store_1.SubmitStore();
const renderButton = (props) => {
    if (props.tooltipLabel != null && props.tooltipLabel.length > 0) {
        return (0, jsx_runtime_1.jsx)(exports.ButtonWithTooltip, { ...props, tooltipLabel: props.tooltipLabel });
    }
    return (0, jsx_runtime_1.jsx)(exports.InternalButton, { ...props, tooltipLabel: undefined });
};
exports.renderButton = renderButton;
const renderAnchor = (props) => {
    if (props.tooltipLabel != null && props.tooltipLabel.length > 0) {
        return (0, jsx_runtime_1.jsx)(exports.AnchorWithTooltip, { ...props, tooltipLabel: props.tooltipLabel });
    }
    return (0, jsx_runtime_1.jsx)(exports.Anchor, { ...props, tooltipLabel: undefined });
};
exports.renderAnchor = renderAnchor;
const renderButtonOrAnchor = (props) => {
    if (props.type === 'link') {
        return (0, exports.renderAnchor)(props);
    }
    return (0, exports.renderButton)(props);
};
exports.renderButtonOrAnchor = renderButtonOrAnchor;
