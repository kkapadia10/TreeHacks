"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DualDeserializationConfig = exports.ProtobufError = exports.Proto = void 0;
const memoize_1 = require('../memoize');
const preconditions_1 = require('../preconditions');
const constants_1 = require("./binary/constants");
const decode_1 = require("./binary/decode");
const deserialize_1 = require("./binary/deserialize");
const encode_1 = require("./binary/encode");
const serialize_1 = require("./binary/serialize");
const write_buffer_1 = require("./binary/write_buffer");
const internal_types_1 = require("./internal_types");
const makeType = (t) => t;
const ProtoType = {
    STRING: makeType({
        typeOfValue: 'string',
        wireType: constants_1.WireType.DELIMITED,
        writeValue(b, v) {
            const populateSize = b.createSizeReservation();
            encode_1.BinaryEncoder.writeString(b, v);
            populateSize();
        },
        readValue: async (buffer) => {
            await buffer.loadBytes(4);
            const size = decode_1.BinaryDecoder.readUnsignedVarint32(buffer);
            await buffer.loadBytes(size, true);
            return decode_1.BinaryDecoder.readString(buffer, size);
        },
    }),
    BOOLEAN: makeType({
        typeOfValue: 'boolean',
        defaultValue: false,
        fixedSize: 1,
        wireType: constants_1.WireType.VARINT,
        writeValue: encode_1.BinaryEncoder.writeBool,
        readValue: b => b.loadBytes(1, true).then(() => decode_1.BinaryDecoder.readBool(b)),
    }),
    DOUBLE: makeType({
        typeOfValue: 'number',
        defaultValue: 0,
        fixedSize: 8,
        wireType: constants_1.WireType.FIXED64,
        writeValue: encode_1.BinaryEncoder.writeDouble,
        readValue: b => b.loadBytes(8, true).then(() => decode_1.BinaryDecoder.readDouble(b)),
    }),
    INT32: makeType({
        typeOfValue: 'number',
        defaultValue: 0,
        wireType: constants_1.WireType.VARINT,
        writeValue: encode_1.BinaryEncoder.writeSignedVarint32,
        readValue: b => b.loadBytes(4).then(() => decode_1.BinaryDecoder.readSignedVarint32(b)),
    }),
    INT64: makeType({
        typeOfValue: 'number',
        defaultValue: 0,
        wireType: constants_1.WireType.VARINT,
        writeValue: encode_1.BinaryEncoder.writeSignedVarint64,
        readValue: b => b.loadBytes(8).then(() => decode_1.BinaryDecoder.readSignedVarint64(b)),
    }),
};
function getWireTag(tag, wireType) {
    const writer = new write_buffer_1.WriteBuffer(8);
    encode_1.BinaryEncoder.writeTag(writer, tag, wireType);
    return writer.flush();
}
function constantField(params) {
    const { tag, jsonFullKeyOrJsonMiniKey, jsonFullValue, value, defaults } = params;
    return {
        tag,
        wireTag: getWireTag(tag, constants_1.WireType.DELIMITED),
        fieldType: internal_types_1.FieldType.CONSTANT,
        jsonFullKey: jsonFullKeyOrJsonMiniKey === DISCRIMINATOR_JSON_MINI_KEY
            ? undefined
            : jsonFullKeyOrJsonMiniKey,
        jsonFullValue,
        value,
        defaults,
        typeOfValue: 'string',
    };
}
function requiredField(valueType, jsonFullKey, tag, def) {
    return {
        tag,
        wireTag: getWireTag(tag, valueType.wireType),
        fieldType: internal_types_1.FieldType.REQUIRED,
        jsonFullKey,
        default: def != null ? def : valueType.defaultValue,
        writeValue: valueType.writeValue,
        readValue: valueType.readValue,
        defaultValue: valueType.defaultValue,
        typeOfValue: valueType.typeOfValue,
    };
}
function optionalField(valueType, jsonFullKey, tag) {
    return {
        tag,
        wireTag: getWireTag(tag, valueType.wireType),
        fieldType: internal_types_1.FieldType.OPTIONAL,
        jsonFullKey,
        writeValue: valueType.writeValue,
        readValue: valueType.readValue,
        defaultValue: valueType.defaultValue,
        typeOfValue: valueType.typeOfValue,
    };
}
function repeatedField(valueType, jsonFullKey, tag) {
    return {
        tag,
        wireTag: getWireTag(tag, constants_1.WireType.DELIMITED),
        fieldType: internal_types_1.FieldType.REPEATED,
        jsonFullKey,
        writeValue: valueType.writeValue,
        readValue: valueType.readValue,
        typeOfValue: valueType.typeOfValue,
    };
}
function mapField(keyType, valueType) {
    return (tagOrJsonFullKey, tagOrObj, maybeObj) => {
        const { tag, jsonFullKey, other1: obj } = getOptions(tagOrJsonFullKey, tagOrObj, maybeObj);
        let writeValue;
        let readValue;
        let typeOfValue;
        if (valueType === 'object') {
            writeValue = (b, v) => (0, serialize_1.writeProtobufTo)(obj, b, v);
            readValue = b => (0, deserialize_1.readProtobufFrom)(obj, b);
            typeOfValue = 'object';
        }
        else if (valueType === 'enum') {
            writeValue = obj.protobufSerialize;
            readValue = obj.protobufDeserialize;
            typeOfValue = 'string';
        }
        else {
            writeValue = valueType.writeValue;
            readValue = valueType.readValue;
            typeOfValue = valueType.typeOfValue;
        }
        return {
            fieldType: internal_types_1.FieldType.MAP,
            tag,
            wireTag: getWireTag(tag, constants_1.WireType.DELIMITED),
            jsonFullKey,
            obj: obj,
            writeKey: keyType.writeValue,
            readKey: keyType.readValue,
            writeValue,
            readValue,
            typeOfKey: keyType.typeOfValue,
            typeOfValue,
        };
    };
}
class Proto {
    static constantString(jsonFullKeyOrJsonMiniKey, jsonFullValueOrTag, tagOrValue, maybeValue) {
        const { tag, jsonFullKey: jsonFullValue, other1: value, } = getOptions(jsonFullValueOrTag, tagOrValue, maybeValue);
        return constantField({ tag, jsonFullKeyOrJsonMiniKey, jsonFullValue, value, defaults: false });
    }
    static constantStringWithDefault(jsonFullKeyOrJsonMiniKey, jsonFullValueOrTag, tagOrValue, maybeValue) {
        const { tag, jsonFullKey: jsonFullValue, other1: value, } = getOptions(jsonFullValueOrTag, tagOrValue, maybeValue);
        return constantField({ tag, jsonFullKeyOrJsonMiniKey, jsonFullValue, value, defaults: true });
    }
    static requiredObject(tagOrJsonFullKey, tagOrObj, maybeObj) {
        const { tag, jsonFullKey, other1: obj } = getOptions(tagOrJsonFullKey, tagOrObj, maybeObj);
        return {
            tag,
            wireTag: getWireTag(tag, constants_1.WireType.DELIMITED),
            fieldType: internal_types_1.FieldType.REQUIRED,
            jsonFullKey,
            obj: obj,
            writeValue: (b, v) => (0, serialize_1.writeProtobufTo)(obj, b, v),
            readValue: d => (0, deserialize_1.readProtobufFrom)(obj, d),
            typeOfValue: 'object',
        };
    }
    static optionalObject(tagOrJsonFullKey, tagOrObj, maybeObj) {
        const { tag, jsonFullKey, other1: obj } = getOptions(tagOrJsonFullKey, tagOrObj, maybeObj);
        return {
            tag,
            wireTag: getWireTag(tag, constants_1.WireType.DELIMITED),
            fieldType: internal_types_1.FieldType.OPTIONAL,
            jsonFullKey,
            obj: obj,
            writeValue: (b, v) => (0, serialize_1.writeProtobufTo)(obj, b, v),
            readValue: d => (0, deserialize_1.readProtobufFrom)(obj, d),
            typeOfValue: 'object',
        };
    }
    static repeatedObject(tagOrJsonFullKey, tagOrObj, maybeObj) {
        const { tag, jsonFullKey, other1: obj } = getOptions(tagOrJsonFullKey, tagOrObj, maybeObj);
        return {
            tag,
            wireTag: getWireTag(tag, constants_1.WireType.DELIMITED),
            fieldType: internal_types_1.FieldType.REPEATED,
            jsonFullKey,
            obj: obj,
            writeValue: (b, v) => (0, serialize_1.writeProtobufTo)(obj, b, v),
            readValue: d => (0, deserialize_1.readProtobufFrom)(obj, d),
            typeOfValue: 'object',
        };
    }
    static requiredStringEnum(tagOrJsonFullKey, tagOrObj, objOrDef, maybeDef) {
        const { tag, jsonFullKey, other1: obj, other2: def, } = getOptions(tagOrJsonFullKey, tagOrObj, objOrDef, maybeDef);
        return {
            tag,
            wireTag: getWireTag(tag, constants_1.WireType.VARINT),
            fieldType: internal_types_1.FieldType.REQUIRED,
            jsonFullKey,
            obj,
            writeValue: obj.protobufSerialize,
            readValue: obj.protobufDeserialize,
            default: def,
            typeOfValue: 'string',
        };
    }
    static optionalStringEnum(tagOrJsonFullKey, tagOrObj, maybeObj) {
        const { tag, jsonFullKey, other1: obj } = getOptions(tagOrJsonFullKey, tagOrObj, maybeObj);
        return {
            tag,
            wireTag: getWireTag(tag, constants_1.WireType.VARINT),
            fieldType: internal_types_1.FieldType.OPTIONAL,
            jsonFullKey,
            obj,
            writeValue: obj.protobufSerialize,
            readValue: obj.protobufDeserialize,
            typeOfValue: 'string',
        };
    }
    static repeatedStringEnum(tagOrJsonFullKey, tagOrObj, maybeObj) {
        const { tag, jsonFullKey, other1: obj } = getOptions(tagOrJsonFullKey, tagOrObj, maybeObj);
        return {
            tag,
            wireTag: getWireTag(tag, constants_1.WireType.VARINT),
            fieldType: internal_types_1.FieldType.REPEATED,
            jsonFullKey,
            obj,
            writeValue: obj.protobufSerialize,
            readValue: obj.protobufDeserialize,
            typeOfValue: 'string',
        };
    }
    static createMessage(schema, options = {}) {
        const init = (0, memoize_1.memoize)(() => {
            const fields = schema();
            const fieldNames = Object.keys(fields);
            const fieldsByTag = {};
            const constantsByTag = {};
            for (const name of fieldNames) {
                const config = fields[name];
                switch (config.fieldType) {
                    case internal_types_1.FieldType.CONSTANT:
                        constantsByTag[config.tag] = { ...config, name };
                        break;
                    case internal_types_1.FieldType.REQUIRED:
                    case internal_types_1.FieldType.OPTIONAL:
                    case internal_types_1.FieldType.REPEATED:
                    case internal_types_1.FieldType.MAP:
                        fieldsByTag[config.tag] = { ...config, name };
                        break;
                    default:
                        throw new preconditions_1.UnreachableError(config);
                }
            }
            return {
                type: internal_types_1.MessageType.CONCRETE,
                fields,
                fieldMetadata: deriveFieldMetadata(fields, options.dualDeserializationConfig),
                fieldsByTag,
                constantsByTag,
            };
        });
        class Message {
            constructor(opts = {}) {
                const { fieldMetadata } = init();
                for (const metadatum of fieldMetadata) {
                    const { config: field, name: fieldName } = metadatum;
                    const value = opts[fieldName];
                    switch (field.fieldType) {
                        case internal_types_1.FieldType.CONSTANT:
                            this[fieldName] = field.value;
                            break;
                        case internal_types_1.FieldType.REQUIRED:
                            this[fieldName] = value == null ? field.default : value;
                            break;
                        case internal_types_1.FieldType.OPTIONAL:
                            this[fieldName] = value;
                            break;
                        case internal_types_1.FieldType.REPEATED:
                            this[fieldName] = value == null ? [] : value;
                            break;
                        case internal_types_1.FieldType.MAP:
                            this[fieldName] = value == null ? new Map() : value;
                            break;
                        default:
                            throw new preconditions_1.UnreachableError(field);
                    }
                }
            }
            static createUnchecked(opts = {}) {
                return new Message(opts);
            }
            static serialize(message) {
                return Message.serializeWithPath(message, []);
            }
            static deserialize(o) {
                return Message.deserializeWithPath(o, []);
            }
            static deserializeWithPath(o, path) {
                var _a;
                const { fieldMetadata } = init();
                const result = Object.create(Message.prototype);
                for (const metadatum of fieldMetadata) {
                    const { config: field, name: fieldName, primaryJsonKey, secondaryJsonKey } = metadatum;
                    let jsonKey = primaryJsonKey;
                    let value = o[jsonKey];
                    if (value == null && secondaryJsonKey != null && o[secondaryJsonKey] != null) {
                        jsonKey = secondaryJsonKey;
                        value = o[jsonKey];
                    }
                    switch (field.fieldType) {
                        case internal_types_1.FieldType.OPTIONAL: {
                            if (value == null) {
                                result[fieldName] = undefined;
                                break;
                            }
                            else if (typeof value !== field.typeOfValue) {
                                const keyEncodings = { primaryJsonKey, secondaryJsonKey };
                                throw makeOptionalTypeError(keyEncodings, value, field.typeOfValue, path);
                            }
                            path.push(jsonKey);
                            result[fieldName] = field.obj ? field.obj.deserializeWithPath(value, path) : value;
                            path.pop();
                            break;
                        }
                        case internal_types_1.FieldType.REQUIRED: {
                            if (value == null && field.defaultValue != null) {
                                result[fieldName] = field.defaultValue;
                                break;
                            }
                            else if (value == null || typeof value !== field.typeOfValue) {
                                const keyEncodings = { primaryJsonKey, secondaryJsonKey };
                                throw makeRequiredTypeError(keyEncodings, value, field.typeOfValue, path);
                            }
                            path.push(jsonKey);
                            result[fieldName] = field.obj ? field.obj.deserializeWithPath(value, path) : value;
                            path.pop();
                            break;
                        }
                        case internal_types_1.FieldType.CONSTANT: {
                            const { primaryJsonValue, secondaryJsonValue } = metadatum;
                            if (value == null && field.defaults) {
                                result[fieldName] = field.value;
                                break;
                            }
                            if (value === primaryJsonValue) {
                                result[fieldName] = field.value;
                                break;
                            }
                            if (secondaryJsonValue != null && value === secondaryJsonValue) {
                                result[fieldName] = field.value;
                                break;
                            }
                            const keyEncodings = { primaryJsonKey, secondaryJsonKey };
                            const valueEncodings = {
                                primaryJsonValue: primaryJsonValue,
                                secondaryJsonValue,
                            };
                            throw new TypeError(`Expected value ${expectedValues(valueEncodings)} for key ${expectedKeys(keyEncodings)} found: ${JSON.stringify(value)} ${pathTrace(path)}`);
                        }
                        case internal_types_1.FieldType.REPEATED: {
                            if (value == null) {
                                result[fieldName] = [];
                                break;
                            }
                            else if (!Array.isArray(value)) {
                                const keyEncodings = { primaryJsonKey, secondaryJsonKey };
                                throw makeRepeatedTypeError(keyEncodings, value, field.typeOfValue, path);
                            }
                            const deserializeWithPath = (_a = field.obj) === null || _a === void 0 ? void 0 : _a.deserializeWithPath;
                            if (deserializeWithPath) {
                                const values = new Array(value.length);
                                for (let j = 0; j < value.length; ++j) {
                                    if (typeof value[j] !== field.typeOfValue) {
                                        const keyEncodings = { primaryJsonKey, secondaryJsonKey };
                                        throw makeRequiredTypeError(keyEncodings, value[j], field.typeOfValue, [...path, jsonKey], j);
                                    }
                                    path.push(`${jsonKey}[${j}]`);
                                    values[j] = deserializeWithPath(value[j], path);
                                    path.pop();
                                }
                                result[fieldName] = values;
                            }
                            else {
                                for (let j = 0; j < value.length; ++j) {
                                    if (typeof value[j] !== field.typeOfValue) {
                                        const keyEncodings = { primaryJsonKey, secondaryJsonKey };
                                        throw makeRequiredTypeError(keyEncodings, value[j], field.typeOfValue, [...path, jsonKey], j);
                                    }
                                }
                                result[fieldName] = value;
                            }
                            break;
                        }
                        case internal_types_1.FieldType.MAP: {
                            if (value == null) {
                                result[fieldName] = new Map();
                                break;
                            }
                            else if (typeof value !== 'object') {
                                const keyEncodings = { primaryJsonKey, secondaryJsonKey };
                                throw new TypeError(`Expected Map for key ${expectedKeys(keyEncodings)}, found: ${JSON.stringify(value)} ${pathTrace(path)}`);
                            }
                            const isNumber = field.typeOfKey === 'number';
                            const entries = Object.entries(value);
                            const pairs = new Array(entries.length);
                            for (let i = 0; i < entries.length; ++i) {
                                const [serializedKey, serializedValue] = entries[i];
                                let deserializedKey;
                                if (isNumber) {
                                    deserializedKey = Number(serializedKey);
                                    if (isNaN(deserializedKey)) {
                                        throw new TypeError(`Expected number map key, found: ${JSON.stringify(serializedKey)} ${pathTrace([...path, jsonKey])}`);
                                    }
                                }
                                else {
                                    deserializedKey = serializedKey;
                                }
                                if (typeof serializedValue !== field.typeOfValue) {
                                    throw new TypeError(`Expected ${field.typeOfValue} map value for map key "${deserializedKey}", found: ${JSON.stringify(value[serializedKey])} ${pathTrace([...path, jsonKey])}`);
                                }
                                path.push(`${jsonKey}["${deserializedKey}"]`);
                                const deserializedValue = field.obj
                                    ? field.obj.deserializeWithPath(serializedValue, path)
                                    : value[serializedKey];
                                path.pop();
                                pairs[i] = [deserializedKey, deserializedValue];
                            }
                            result[fieldName] = new Map(pairs);
                            break;
                        }
                        default:
                            throw new preconditions_1.UnreachableError(field);
                    }
                }
                return result;
            }
        }
        Message.init = init;
        Message.serializeWithPath = options.unproducible
            ? (_message, path) => {
                throw new TypeError(`Unproducible oneof case ${pathTrace(path)}`);
            }
            : (message, path) => {
                var _a, _b;
                if (message == null || typeof message !== 'object') {
                    throw new TypeError(`Expected type object, found: ${JSON.stringify(message)} ${pathTrace(path)}`);
                }
                const { fieldMetadata } = init();
                const res = {};
                for (const metadatum of fieldMetadata) {
                    const { config: field, name: fieldName, primaryJsonKey } = metadatum;
                    const value = message[fieldName];
                    const jsonKey = primaryJsonKey;
                    switch (field.fieldType) {
                        case internal_types_1.FieldType.CONSTANT: {
                            if (value !== field.value) {
                                throw new TypeError(`Expected value ${JSON.stringify(field.value)} for key "${primaryJsonKey}", found: ${JSON.stringify(value)} ${pathTrace(path)}`);
                            }
                            res[jsonKey] = metadatum.primaryJsonValue;
                            break;
                        }
                        case internal_types_1.FieldType.REQUIRED: {
                            if (field.defaultValue != null && value === field.defaultValue) {
                                break;
                            }
                            path.push(jsonKey);
                            const serializedValue = field.obj
                                ? field.obj.serializeWithPath(value, path)
                                : value;
                            path.pop();
                            if (typeof serializedValue !== field.typeOfValue) {
                                throw makeRequiredTypeError({ primaryJsonKey }, value, field.typeOfValue, path);
                            }
                            res[jsonKey] = serializedValue;
                            break;
                        }
                        case internal_types_1.FieldType.OPTIONAL: {
                            if (value == null) {
                                break;
                            }
                            path.push(jsonKey);
                            const serializedValue = field.obj
                                ? field.obj.serializeWithPath(value, path)
                                : value;
                            path.pop();
                            if (typeof serializedValue !== field.typeOfValue) {
                                throw makeOptionalTypeError({ primaryJsonKey }, value, field.typeOfValue, path);
                            }
                            res[jsonKey] = serializedValue;
                            break;
                        }
                        case internal_types_1.FieldType.REPEATED: {
                            if (value == null) {
                                break;
                            }
                            else if (!Array.isArray(value)) {
                                throw makeRepeatedTypeError({ primaryJsonKey }, value, field.typeOfValue, path);
                            }
                            else if (value.length === 0) {
                                break;
                            }
                            const serializeWithPath = (_a = field.obj) === null || _a === void 0 ? void 0 : _a.serializeWithPath;
                            if (serializeWithPath) {
                                const result = new Array(value.length);
                                for (let i = 0; i < value.length; ++i) {
                                    path.push(`${jsonKey}[${i}]`);
                                    const serializedValue = serializeWithPath(value[i], path);
                                    path.pop();
                                    if (typeof serializedValue !== field.typeOfValue) {
                                        throw makeRequiredTypeError({ primaryJsonKey }, serializedValue, field.typeOfValue, [...path, jsonKey], i);
                                    }
                                    result[i] = serializedValue;
                                }
                                res[jsonKey] = result;
                            }
                            else {
                                for (let i = 0; i < value.length; ++i) {
                                    if (typeof value[i] !== field.typeOfValue) {
                                        throw makeRequiredTypeError({ primaryJsonKey }, value[i], field.typeOfValue, [...path, jsonKey], i);
                                    }
                                }
                                res[jsonKey] = value;
                            }
                            break;
                        }
                        case internal_types_1.FieldType.MAP: {
                            if (!(value instanceof Map)) {
                                throw new TypeError(`Expected Map for key "${primaryJsonKey}", found: ${JSON.stringify(value)} ${pathTrace(path)}`);
                            }
                            else if (value.size === 0) {
                                break;
                            }
                            const map = {};
                            const serializeWithPath = (_b = field.obj) === null || _b === void 0 ? void 0 : _b.serializeWithPath;
                            for (const [key, mapValue] of value) {
                                if (typeof key !== field.typeOfKey) {
                                    throw new TypeError(`Expected ${field.typeOfKey} map key, found: ${JSON.stringify(key)} ${pathTrace([...path, jsonKey])}`);
                                }
                                path.push(`${jsonKey}["${key}"]`);
                                const serializedValue = serializeWithPath
                                    ? serializeWithPath(mapValue, path)
                                    : mapValue;
                                path.pop();
                                if (typeof serializedValue !== field.typeOfValue) {
                                    throw new TypeError(`Expected ${field.typeOfValue} map value for map key "${key}", found: ${JSON.stringify(serializedValue)} ${pathTrace([...path, jsonKey])}`);
                                }
                                map[key] = serializedValue;
                            }
                            res[jsonKey] = map;
                            break;
                        }
                        default:
                            throw new preconditions_1.UnreachableError(field);
                    }
                }
                return res;
            };
        return Message;
    }
    static createOneOf(schema, commonFields, options = {}) {
        const init = (0, memoize_1.memoize)(() => {
            const config = schema();
            const discriminatorKey = Object.keys(config)[0];
            let discriminatorTag;
            let discriminatorJsonKeyEncodings;
            const nameToObject = new Map();
            const serializedToObject = new Map();
            const tagToObject = new Map();
            for (let i = 0; i < config[discriminatorKey].length; i += 2) {
                const tag = config[discriminatorKey][i];
                const msg = config[discriminatorKey][i + 1];
                const msgFields = msg.init().fields;
                const discriminator = msgFields[discriminatorKey];
                if (!discriminator) {
                    throw new TypeError(`Missing discriminator.`);
                }
                if (discriminator.fieldType !== internal_types_1.FieldType.CONSTANT) {
                    throw new TypeError(`Discriminator must be FieldType.CONSTANT, was ${discriminator.fieldType}.}`);
                }
                const caseDiscriminatorJsonKeyEncodings = choosePrimaryAndSecondaryJSONFromConfig(DISCRIMINATOR_JSON_MINI_KEY, discriminator.jsonFullKey, options.dualDeserializationConfig);
                const { primary: primaryJsonValue, secondary: secondaryJsonValue } = choosePrimaryAndSecondaryJSONFromConfig(toJsonMini(tag - 1), discriminator.jsonFullValue, options.dualDeserializationConfig);
                tagToObject.set(tag, { Msg: msg, value: discriminator.value });
                nameToObject.set(discriminator.value, msg);
                serializedToObject.set(primaryJsonValue, msg);
                if (secondaryJsonValue) {
                    serializedToObject.set(secondaryJsonValue, msg);
                }
                if (discriminatorJsonKeyEncodings
                    && discriminatorJsonKeyEncodings.primaryJsonKey
                        !== caseDiscriminatorJsonKeyEncodings.primary) {
                    throw new TypeError(`oneOf JSON keys are not consistent. ${discriminatorJsonKeyEncodings.primaryJsonKey} ${caseDiscriminatorJsonKeyEncodings.primary}`);
                }
                if (discriminatorJsonKeyEncodings
                    && discriminatorJsonKeyEncodings.secondaryJsonKey
                        !== caseDiscriminatorJsonKeyEncodings.secondary) {
                    throw new TypeError(`oneOf secondary JSON keys are not consistent. ${discriminatorJsonKeyEncodings.secondaryJsonKey} ${caseDiscriminatorJsonKeyEncodings.secondary}`);
                }
                discriminatorTag = discriminator.tag;
                const { primary: primaryJsonKey, secondary: secondaryJsonKey } = caseDiscriminatorJsonKeyEncodings;
                discriminatorJsonKeyEncodings = { primaryJsonKey, secondaryJsonKey };
            }
            if (discriminatorJsonKeyEncodings == null || discriminatorTag == null) {
                throw new TypeError('OneOf has no cases.');
            }
            const fields = commonFields();
            const fieldNames = Object.keys(fields);
            const fieldsByTag = {};
            for (const name of fieldNames) {
                fieldsByTag[fields[name].tag] = { ...fields[name], name };
            }
            const defaultObject = options.defaultCase != null ? options.defaultCase() : undefined;
            return {
                type: internal_types_1.MessageType.ONE_OF,
                fieldMetadata: deriveFieldMetadata(fields, options.dualDeserializationConfig),
                discriminatorKey,
                nameToObject,
                discriminatorTag,
                discriminatorJsonKeyEncodings,
                serializedToObject,
                defaultObject,
                fields,
                fieldsByTag,
                constantsByTag: {},
                tagToObject,
            };
        });
        const serializeWithPath = (t, path) => {
            const { discriminatorKey, nameToObject } = init();
            const type = t[discriminatorKey];
            const obj = nameToObject.get(type);
            if (!obj) {
                throw new TypeError(`Unknown oneof deserialized case: ${JSON.stringify(type)} ${pathTrace(path)}`);
            }
            return obj.serializeWithPath(t, path);
        };
        const deserializeWithPath = (o, path) => {
            const { serializedToObject, discriminatorJsonKeyEncodings, defaultObject } = init();
            const { primaryJsonKey, secondaryJsonKey } = discriminatorJsonKeyEncodings;
            let type = o[primaryJsonKey];
            if (type == null && secondaryJsonKey) {
                type = o[secondaryJsonKey];
            }
            if (type == null && defaultObject) {
                return defaultObject.deserializeWithPath(o, path);
            }
            const obj = serializedToObject.get(type);
            if (!obj) {
                throw new TypeError(`Unknown oneof serialized case: ${JSON.stringify(type)} ${pathTrace(path)}`);
            }
            return obj.deserializeWithPath(o, path);
        };
        return {
            init,
            serialize: t => serializeWithPath(t, []),
            serializeWithPath,
            deserialize: o => deserializeWithPath(o, []),
            deserializeWithPath,
        };
    }
    static createEnumUtil(schema, baseNumber = 0, options = {}) {
        const init = (0, memoize_1.memoize)(() => {
            const config = schema();
            const values = [];
            const serializedToValue = new Map();
            const valueToSerialized = new Map();
            const valueToProtobufSerialized = new Map();
            const protobufSerializedToValue = new Map();
            const unproducible = new Set();
            let i = 0;
            let index = 1;
            while (i < config.length) {
                const value = index++;
                const protobufSerialized = config[i];
                const jsonMiniValue = toJsonMini(protobufSerialized - baseNumber);
                i += 1;
                let jsonFullValue;
                const maybeJsonFullValue = config[i];
                if (typeof maybeJsonFullValue === 'string') {
                    jsonFullValue = maybeJsonFullValue;
                    i += 1;
                }
                const { primary: primaryJsonValue, secondary: secondaryJsonValue } = choosePrimaryAndSecondaryJSONFromConfig(jsonMiniValue, jsonFullValue, options.dualDeserializationConfig);
                const maybeOptions = config[i];
                if (typeof maybeOptions === 'object' && maybeOptions.unproducible) {
                    unproducible.add(value);
                    i += 1;
                }
                values.push(value);
                serializedToValue.set(primaryJsonValue, value);
                if (secondaryJsonValue) {
                    serializedToValue.set(secondaryJsonValue, value);
                }
                valueToSerialized.set(value, primaryJsonValue);
                valueToProtobufSerialized.set(value, protobufSerialized);
                protobufSerializedToValue.set(protobufSerialized, value);
            }
            return {
                values,
                valueToSerialized,
                valueToProtobufSerialized,
                protobufSerializedToValue,
                serializedToValue,
                unproducible: unproducible.size ? unproducible : undefined,
            };
        });
        const getSerialized = (value, map, path) => {
            const { unproducible } = init();
            if (unproducible && unproducible.has(value)) {
                throw new TypeError(`Unproducible enum value: ${JSON.stringify(value)} ${path ? pathTrace(path) : ''}`);
            }
            const serialized = map.get(value);
            if (serialized == null) {
                throw new TypeError(`Unrecognized deserialized enum value: ${JSON.stringify(value)} ${path ? pathTrace(path) : ''}`);
            }
            return serialized;
        };
        const deserializeWithPath = (jsonValue, path) => {
            const value = init().serializedToValue.get(jsonValue);
            if (value == null) {
                throw new TypeError(`Unrecognized serialized enum value: ${JSON.stringify(jsonValue)} ${pathTrace(path)}`);
            }
            return value;
        };
        return {
            values: () => init().values,
            producibleValues: () => {
                const { values, unproducible } = init();
                if (unproducible == null) {
                    return values;
                }
                return values.filter(value => !unproducible.has(value));
            },
            serialize: (value) => {
                return getSerialized(value, init().valueToSerialized, []);
            },
            serializeWithPath: (value, path) => {
                return getSerialized(value, init().valueToSerialized, path);
            },
            deserialize: (jsonValue) => {
                return deserializeWithPath(jsonValue, []);
            },
            deserializeWithPath,
            protobufSerialize: (buffer, value) => {
                encode_1.BinaryEncoder.writeEnum(buffer, getSerialized(value, init().valueToProtobufSerialized));
            },
            async protobufDeserialize(buffer) {
                const { protobufSerializedToValue } = init();
                await buffer.loadBytes(4);
                return protobufSerializedToValue.get(decode_1.BinaryDecoder.readEnum(buffer));
            },
        };
    }
}
exports.Proto = Proto;
Proto.requiredDouble = (a, b, c) => {
    const { tag, jsonFullKey, other1 } = getOptions(a, b, c);
    return requiredField(ProtoType.DOUBLE, jsonFullKey, tag, other1);
};
Proto.requiredInt32 = (a, b, c) => {
    const { tag, jsonFullKey, other1 } = getOptions(a, b, c);
    return requiredField(ProtoType.INT32, jsonFullKey, tag, other1);
};
Proto.requiredInt64 = (a, b, c) => {
    const { tag, jsonFullKey, other1 } = getOptions(a, b, c);
    return requiredField(ProtoType.INT64, jsonFullKey, tag, other1);
};
Proto.optionalDouble = (a, b) => {
    const { tag, jsonFullKey } = getOptions(a, b);
    return optionalField(ProtoType.DOUBLE, jsonFullKey, tag);
};
Proto.optionalInt32 = (a, b) => {
    const { tag, jsonFullKey } = getOptions(a, b);
    return optionalField(ProtoType.INT32, jsonFullKey, tag);
};
Proto.optionalInt64 = (a, b) => {
    const { tag, jsonFullKey } = getOptions(a, b);
    return optionalField(ProtoType.INT64, jsonFullKey, tag);
};
Proto.repeatedDouble = (a, b) => {
    const { tag, jsonFullKey } = getOptions(a, b);
    return repeatedField(ProtoType.DOUBLE, jsonFullKey, tag);
};
Proto.repeatedInt32 = (a, b) => {
    const { tag, jsonFullKey } = getOptions(a, b);
    return repeatedField(ProtoType.INT32, jsonFullKey, tag);
};
Proto.repeatedInt64 = (a, b) => {
    const { tag, jsonFullKey } = getOptions(a, b);
    return repeatedField(ProtoType.INT64, jsonFullKey, tag);
};
Proto.requiredString = (a, b, c) => {
    const { tag, jsonFullKey, other1 } = getOptions(a, b, c);
    return requiredField(ProtoType.STRING, jsonFullKey, tag, other1);
};
Proto.optionalString = (a, b) => {
    const { tag, jsonFullKey } = getOptions(a, b);
    return optionalField(ProtoType.STRING, jsonFullKey, tag);
};
Proto.repeatedString = (a, b) => {
    const { tag, jsonFullKey } = getOptions(a, b);
    return repeatedField(ProtoType.STRING, jsonFullKey, tag);
};
Proto.requiredBoolean = (a, b, c) => {
    const { tag, jsonFullKey, other1 } = getOptions(a, b, c);
    return requiredField(ProtoType.BOOLEAN, jsonFullKey, tag, other1);
};
Proto.optionalBoolean = (a, b) => {
    const { tag, jsonFullKey } = getOptions(a, b);
    return optionalField(ProtoType.BOOLEAN, jsonFullKey, tag);
};
Proto.repeatedBoolean = (a, b) => {
    const { tag, jsonFullKey } = getOptions(a, b);
    return repeatedField(ProtoType.BOOLEAN, jsonFullKey, tag);
};
Proto.int32Int32Map = mapField(ProtoType.INT32, ProtoType.INT32);
Proto.int32Int64Map = mapField(ProtoType.INT32, ProtoType.INT64);
Proto.int32BoolMap = mapField(ProtoType.INT32, ProtoType.BOOLEAN);
Proto.int32DoubleMap = mapField(ProtoType.INT32, ProtoType.DOUBLE);
Proto.int32StringMap = mapField(ProtoType.INT32, ProtoType.STRING);
Proto.int32StringEnumMap = mapField(ProtoType.INT32, 'enum');
Proto.int32ObjectMap = mapField(ProtoType.INT32, 'object');
Proto.int64Int32Map = mapField(ProtoType.INT64, ProtoType.INT32);
Proto.int64Int64Map = mapField(ProtoType.INT64, ProtoType.INT64);
Proto.int64BoolMap = mapField(ProtoType.INT64, ProtoType.BOOLEAN);
Proto.int64DoubleMap = mapField(ProtoType.INT64, ProtoType.DOUBLE);
Proto.int64StringMap = mapField(ProtoType.INT64, ProtoType.STRING);
Proto.int64StringEnumMap = mapField(ProtoType.INT64, 'enum');
Proto.int64ObjectMap = mapField(ProtoType.INT64, 'object');
Proto.doubleInt32Map = mapField(ProtoType.DOUBLE, ProtoType.INT32);
Proto.doubleInt64Map = mapField(ProtoType.DOUBLE, ProtoType.INT64);
Proto.doubleBoolMap = mapField(ProtoType.DOUBLE, ProtoType.BOOLEAN);
Proto.doubleDoubleMap = mapField(ProtoType.DOUBLE, ProtoType.DOUBLE);
Proto.doubleStringMap = mapField(ProtoType.DOUBLE, ProtoType.STRING);
Proto.doubleStringEnumMap = mapField(ProtoType.DOUBLE, 'enum');
Proto.doubleObjectMap = mapField(ProtoType.DOUBLE, 'object');
Proto.stringInt32Map = mapField(ProtoType.STRING, ProtoType.INT32);
Proto.stringInt64Map = mapField(ProtoType.STRING, ProtoType.INT64);
Proto.stringBooleanMap = mapField(ProtoType.STRING, ProtoType.BOOLEAN);
Proto.stringDoubleMap = mapField(ProtoType.STRING, ProtoType.DOUBLE);
Proto.stringStringMap = mapField(ProtoType.STRING, ProtoType.STRING);
Proto.stringStringEnumMap = mapField(ProtoType.STRING, 'enum');
Proto.stringObjectMap = mapField(ProtoType.STRING, 'object');
Proto.writeProtobufStream = serialize_1.writeProtobufStream;
Proto.readProtobufStream = deserialize_1.readProtobufStream;
function deriveFieldMetadata(fields, dualDeserializationConfig) {
    return Object.entries(fields).map(([name, config]) => {
        var _a, _b;
        const fieldEncodings = deriveFieldEncodings(config, dualDeserializationConfig);
        return {
            config,
            name,
            primaryJsonKey: fieldEncodings.keyEncodings.primaryJsonKey,
            secondaryJsonKey: fieldEncodings.keyEncodings.secondaryJsonKey,
            primaryJsonValue: (_a = fieldEncodings.valueEncodings) === null || _a === void 0 ? void 0 : _a.primaryJsonValue,
            secondaryJsonValue: (_b = fieldEncodings.valueEncodings) === null || _b === void 0 ? void 0 : _b.secondaryJsonValue,
        };
    });
}
function deriveFieldEncodings(fieldConfig, dualDeserializationConfig) {
    let valueEncodings;
    let jsonMiniKey = toJsonMini(fieldConfig.tag - 1);
    if (fieldConfig.fieldType === internal_types_1.FieldType.CONSTANT) {
        const { primary: primaryJsonValue, secondary: secondaryJsonValue } = choosePrimaryAndSecondaryJSONFromConfig(jsonMiniKey, fieldConfig.jsonFullValue, dualDeserializationConfig);
        jsonMiniKey = DISCRIMINATOR_JSON_MINI_KEY;
        valueEncodings = { primaryJsonValue, secondaryJsonValue };
    }
    const { primary: primaryJsonKey, secondary: secondaryJsonKey } = choosePrimaryAndSecondaryJSONFromConfig(jsonMiniKey, fieldConfig.jsonFullKey, dualDeserializationConfig);
    const keyEncodings = { primaryJsonKey, secondaryJsonKey };
    return { keyEncodings, valueEncodings };
}
function choosePrimaryAndSecondaryJSONFromConfig(jsonMini, jsonFull, dualDeserializationConfig) {
    if (!jsonFull) {
        if (dualDeserializationConfig !== undefined) {
            throw new Error("Dual Deserialization config templated but JSON full key/value wasn't");
        }
        return { primary: jsonMini };
    }
    if (dualDeserializationConfig === undefined) {
        return {
            primary: jsonFull,
        };
    }
    else if (dualDeserializationConfig === DualDeserializationConfig.MINI_PRIMARY_FULL_SECONDARY) {
        return {
            primary: jsonMini,
            secondary: jsonFull,
        };
    }
    else if (dualDeserializationConfig === DualDeserializationConfig.FULL_PRIMARY_MINI_SECONDARY) {
        return {
            primary: jsonFull,
            secondary: jsonMini,
        };
    }
    throw new Error("function should have been exhaustive, but wasn't");
}
function makeRepeatedTypeError(keyEncodings, value, expectedType, path) {
    return new TypeError(`Expected repeated ${expectedType} value for key ${expectedKeys(keyEncodings)}, found: ${JSON.stringify(value)} ${pathTrace(path)}`);
}
function makeOptionalTypeError(keyEncodings, value, expectedType, path) {
    return new TypeError(`Expected optional ${expectedType} value for key ${expectedKeys(keyEncodings)}, found: ${JSON.stringify(value)} ${pathTrace(path)}`);
}
function makeRequiredTypeError(keyEncodings, value, expectedType, path, index) {
    const atIndex = index !== undefined ? ` at index ${index}` : '';
    return new TypeError(`Expected ${expectedType} value${atIndex} for key ${expectedKeys(keyEncodings)}, found: ${JSON.stringify(value)} ${pathTrace(path)}`);
}
function expectedKeys(keyEncodings) {
    const { primaryJsonKey, secondaryJsonKey } = keyEncodings;
    if (secondaryJsonKey) {
        return `either "${primaryJsonKey}" OR "${secondaryJsonKey}"`;
    }
    return `"${primaryJsonKey}"`;
}
function expectedValues(valueEncodings) {
    const { primaryJsonValue, secondaryJsonValue } = valueEncodings;
    if (secondaryJsonValue) {
        return `either "${primaryJsonValue}" OR "${secondaryJsonValue}"`;
    }
    return `"${primaryJsonValue}"`;
}
function pathTrace(path) {
    return `(path: .${path.join('.')})`;
}
var internal_types_2 = require("./internal_types");
Object.defineProperty(exports, "ProtobufError", { enumerable: true, get: function () { return internal_types_2.ProtobufError; } });
var DualDeserializationConfig;
(function (DualDeserializationConfig) {
    DualDeserializationConfig[DualDeserializationConfig["MINI_PRIMARY_FULL_SECONDARY"] = 0] = "MINI_PRIMARY_FULL_SECONDARY";
    DualDeserializationConfig[DualDeserializationConfig["FULL_PRIMARY_MINI_SECONDARY"] = 1] = "FULL_PRIMARY_MINI_SECONDARY";
})(DualDeserializationConfig || (exports.DualDeserializationConfig = DualDeserializationConfig = {}));
const DISCRIMINATOR_JSON_MINI_KEY = 'A?';
const JSON_MINI_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';
function toJsonMini(x) {
    if (x < JSON_MINI_ALPHABET.length) {
        return JSON_MINI_ALPHABET.charAt(x);
    } else {
        const builder = [];
        while (x > 0) {
            builder.push(JSON_MINI_ALPHABET.charAt(x % JSON_MINI_ALPHABET.length));
            x = Math.floor(x / JSON_MINI_ALPHABET.length);
        }
        return builder.reverse().join('');
    }
}
function getOptions(tagOrJsonFullKey, tagOrOther1, other1OrOther2, maybeOther2) {
    if (typeof tagOrJsonFullKey === 'string') {
        return {
            jsonFullKey: tagOrJsonFullKey,
            tag: tagOrOther1,
            other1: other1OrOther2,
            other2: maybeOther2,
        };
    }
    else {
        return {
            tag: tagOrJsonFullKey,
            other1: tagOrOther1,
            other2: other1OrOther2,
        };
    }
}
