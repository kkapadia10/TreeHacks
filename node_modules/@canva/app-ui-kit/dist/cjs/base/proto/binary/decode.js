"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BinaryDecoder = void 0;
const constants_1 = require("./constants");
class BinaryDecoder {
    static readTag(buffer) {
        const header = BinaryDecoder.readUnsignedVarint32(buffer);
        return { tag: header >>> 3, wireType: header & 0x7 };
    }
    static readSplitVarint64(buffer, convert) {
        let temp = 128;
        let lowBits = 0;
        let highBits = 0;
        for (let i = 0; i < 4 && temp >= 128; i++) {
            temp = buffer.read();
            lowBits |= (temp & 0x7f) << (i * 7);
        }
        if (temp >= 128) {
            temp = buffer.read();
            lowBits |= (temp & 0x7f) << 28;
            highBits |= (temp & 0x7f) >> 4;
        }
        if (temp >= 128) {
            for (let i = 0; i < 5 && temp >= 128; i++) {
                temp = buffer.read();
                highBits |= (temp & 0x7f) << (i * 7 + 3);
            }
        }
        if (temp < 128) {
            return convert(lowBits >>> 0, highBits >>> 0);
        }
        throw new Error('Failed to read varint, encoding is invalid.');
    }
    static readUnsignedVarint32(buffer) {
        let temp;
        temp = buffer.read();
        let x = temp & 0x7f;
        if (temp < 128) {
            return x;
        }
        temp = buffer.read();
        x |= (temp & 0x7f) << 7;
        if (temp < 128) {
            return x;
        }
        temp = buffer.read();
        x |= (temp & 0x7f) << 14;
        if (temp < 128) {
            return x;
        }
        temp = buffer.read();
        x |= (temp & 0x7f) << 21;
        if (temp < 128) {
            return x;
        }
        temp = buffer.read();
        x |= (temp & 0x0f) << 28;
        if (temp < 128) {
            return x >>> 0;
        }
        if (buffer.read() >= 128
            && buffer.read() >= 128
            && buffer.read() >= 128
            && buffer.read() >= 128
            && buffer.read() >= 128) {
            assert(false);
        }
        return x;
    }
    static readSignedVarint32(buffer) {
        return BinaryDecoder.readUnsignedVarint32(buffer);
    }
    static readSignedVarint64(buffer) {
        return BinaryDecoder.readSplitVarint64(buffer, BinaryDecoder.joinInt64);
    }
    static readUint32(buffer) {
        const a = buffer.read();
        const b = buffer.read();
        const c = buffer.read();
        const d = buffer.read();
        return ((a << 0) | (b << 8) | (c << 16) | (d << 24)) >>> 0;
    }
    static readInt32(buffer) {
        const a = buffer.read();
        const b = buffer.read();
        const c = buffer.read();
        const d = buffer.read();
        return (a << 0) | (b << 8) | (c << 16) | (d << 24);
    }
    static readInt64(buffer) {
        const bitsLow = BinaryDecoder.readUint32(buffer);
        const bitsHigh = BinaryDecoder.readUint32(buffer);
        return BinaryDecoder.joinInt64(bitsLow, bitsHigh);
    }
    static readDouble(buffer) {
        return buffer.readFloat();
    }
    static readBool(buffer) {
        return !!buffer.read();
    }
    static readEnum(buffer) {
        return BinaryDecoder.readSignedVarint32(buffer);
    }
    static readString(buffer, length) {
        const end = buffer.bytesRead + length;
        const codeUnits = [];
        let result = '';
        while (buffer.bytesRead < end) {
            const c = buffer.read();
            if (c < 128) {
                codeUnits.push(c);
            }
            else if (c < 192) {
                continue;
            }
            else if (c < 224) {
                const c2 = buffer.read();
                codeUnits.push(((c & 31) << 6) | (c2 & 63));
            }
            else if (c < 240) {
                const c2 = buffer.read();
                const c3 = buffer.read();
                codeUnits.push(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
            }
            else if (c < 248) {
                const c2 = buffer.read();
                const c3 = buffer.read();
                const c4 = buffer.read();
                let codepoint = ((c & 7) << 18) | ((c2 & 63) << 12) | ((c3 & 63) << 6) | (c4 & 63);
                codepoint -= 0x10000;
                const low = (codepoint & 1023) + 0xdc00;
                const high = ((codepoint >> 10) & 1023) + 0xd800;
                codeUnits.push(high, low);
            }
            if (codeUnits.length >= 8192) {
                result += String.fromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
            }
        }
        result += String.fromCharCode.apply(null, codeUnits);
        return result;
    }
    static joinInt64(bitsLow, bitsHigh) {
        const sign = bitsHigh & 0x80000000;
        if (sign) {
            bitsLow = (~bitsLow + 1) >>> 0;
            bitsHigh = ~bitsHigh >>> 0;
            if (bitsLow === 0) {
                bitsHigh = (bitsHigh + 1) >>> 0;
            }
        }
        const result = bitsHigh * constants_1.BinaryConstants.TWO_TO_32 + (bitsLow >>> 0);
        return sign ? -result : result;
    }
}
exports.BinaryDecoder = BinaryDecoder;
function assert(cond) {
    if (!cond) {
        throw new Error();
    }
}
