"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeProtobufTo = exports.writeProtobufStream = void 0;
const preconditions_1 = require('../../preconditions');
const internal_types_1 = require("../internal_types");
const write_buffer_1 = require("./write_buffer");
function writeProtobufStream(Msg, message, bufferSize = 512) {
    const encoder = new write_buffer_1.WriteBuffer(bufferSize);
    writeProtobufTo(Msg, encoder, message);
    return new ReadableStream({
        start(controller) {
            controller.enqueue(encoder.flush());
            controller.close();
        },
    });
}
exports.writeProtobufStream = writeProtobufStream;
function writeProtobufTo(InitialMsg, buffer, message) {
    const initData = InitialMsg.init();
    if (initData.type === internal_types_1.MessageType.ONE_OF) {
        const type = message[initData.discriminatorKey];
        const CaseMsg = initData.nameToObject.get(type);
        if (!CaseMsg) {
            throw new TypeError(`Unknown oneof deserialized case ${type}.`);
        }
        writeProtobufTo(CaseMsg, buffer, message);
        return;
    }
    const populateSize = buffer.createSizeReservation();
    let oneOfReservedSize;
    for (const { name: fieldName, config: fieldConfig } of initData.fieldMetadata) {
        const value = message[fieldName];
        switch (fieldConfig.fieldType) {
            case internal_types_1.FieldType.OPTIONAL:
                if (value == null) {
                    break;
                }
                buffer.writeBytes(fieldConfig.wireTag);
                fieldConfig.writeValue(buffer, value);
                break;
            case internal_types_1.FieldType.REQUIRED:
                if (value == null || fieldConfig.defaultValue === value) {
                    break;
                }
                buffer.writeBytes(fieldConfig.wireTag);
                fieldConfig.writeValue(buffer, value);
                break;
            case internal_types_1.FieldType.REPEATED: {
                if (!value.length) {
                    break;
                }
                buffer.writeBytes(fieldConfig.wireTag);
                const populateFieldSize = buffer.createSizeReservation();
                for (let i = 0; i < value.length; ++i) {
                    fieldConfig.writeValue(buffer, value[i]);
                }
                populateFieldSize();
                break;
            }
            case internal_types_1.FieldType.CONSTANT:
                buffer.writeBytes(fieldConfig.wireTag);
                oneOfReservedSize = buffer.createSizeReservation();
                break;
            case internal_types_1.FieldType.MAP: {
                if (!value.size) {
                    break;
                }
                buffer.writeBytes(fieldConfig.wireTag);
                const populateFieldSize = buffer.createSizeReservation();
                for (const [key, val] of value) {
                    fieldConfig.writeKey(buffer, key);
                    fieldConfig.writeValue(buffer, val);
                }
                populateFieldSize();
                break;
            }
            default:
                throw new preconditions_1.UnreachableError(fieldConfig);
        }
    }
    oneOfReservedSize === null || oneOfReservedSize === void 0 ? void 0 : oneOfReservedSize();
    populateSize();
}
exports.writeProtobufTo = writeProtobufTo;
