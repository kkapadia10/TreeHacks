"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readProtobufFrom = exports.readProtobufStream = void 0;
const preconditions_1 = require('../../preconditions');
const internal_types_1 = require("../internal_types");
const constants_1 = require("./constants");
const decode_1 = require("./decode");
const read_buffer_1 = require("./read_buffer");
async function readProtobufStream(Msg, stream) {
    return readProtobufFrom(Msg, new read_buffer_1.ReadBuffer(stream));
}
exports.readProtobufStream = readProtobufStream;
async function readProtobufFrom(Msg, buffer) {
    let metaData = Msg.init();
    const values = {};
    await buffer.loadBytes(4);
    const size = decode_1.BinaryDecoder.readUnsignedVarint32(buffer);
    const bufferEnd = buffer.bytesRead + size;
    while (buffer.bytesRead < bufferEnd) {
        await buffer.loadBytes(4);
        const { tag, wireType } = decode_1.BinaryDecoder.readTag(buffer);
        if (metaData.type === internal_types_1.MessageType.ONE_OF && metaData.tagToObject.has(tag)) {
            Msg = metaData.tagToObject.get(tag).Msg;
            metaData = Msg.init();
        }
        const constConfig = metaData.constantsByTag[tag];
        if (constConfig && values[constConfig.name] == null) {
            decode_1.BinaryDecoder.readUnsignedVarint32(buffer);
            values[constConfig.name] = constConfig.value;
            continue;
        }
        const fieldConfig = metaData.fieldsByTag[tag];
        if (!fieldConfig) {
            consumeMissingField(wireType, buffer);
        }
        else {
            values[fieldConfig.name] = await readField(fieldConfig, buffer);
        }
    }
    for (const { name: fieldName, config: field } of metaData.fieldMetadata) {
        if (values[fieldName] != null) {
            continue;
        }
        switch (field.fieldType) {
            case internal_types_1.FieldType.OPTIONAL:
                break;
            case internal_types_1.FieldType.REQUIRED:
                if (field.defaultValue == null) {
                    throw new TypeError(`expected ${field.typeOfValue} for property "${fieldName}" with tag "${field.tag}", but it was not present.`);
                }
                values[fieldName] = field.defaultValue;
                break;
            case internal_types_1.FieldType.MAP:
                values[fieldName] = new Map();
                break;
            case internal_types_1.FieldType.REPEATED:
                values[fieldName] = [];
                break;
            case internal_types_1.FieldType.CONSTANT:
                if (!field.defaults) {
                    throw new TypeError(`expected discriminator for property "${fieldName}" with tag "${field.tag}", but it was not present.`);
                }
                values[fieldName] = field.value;
                break;
            default:
                throw new preconditions_1.UnreachableError(field);
        }
    }
    return Object.assign(Object.create(Msg.prototype), values);
}
exports.readProtobufFrom = readProtobufFrom;
async function readField(fieldConfig, buffer) {
    switch (fieldConfig.fieldType) {
        case internal_types_1.FieldType.OPTIONAL:
        case internal_types_1.FieldType.REQUIRED:
            return fieldConfig.readValue(buffer);
        case internal_types_1.FieldType.REPEATED:
            await buffer.loadBytes(4);
            const listSize = decode_1.BinaryDecoder.readUnsignedVarint32(buffer);
            const listEnd = buffer.bytesRead + listSize;
            const array = [];
            while (buffer.bytesRead < listEnd) {
                array.push(await fieldConfig.readValue(buffer));
            }
            return array;
        case internal_types_1.FieldType.MAP:
            await buffer.loadBytes(4);
            const mapSize = decode_1.BinaryDecoder.readUnsignedVarint32(buffer);
            const mapEnd = buffer.bytesRead + mapSize;
            const map = new Map();
            while (buffer.bytesRead < mapEnd) {
                map.set(await fieldConfig.readKey(buffer), await fieldConfig.readValue(buffer));
            }
            return map;
        case internal_types_1.FieldType.CONSTANT:
            throw new Error();
        default:
            throw new preconditions_1.UnreachableError(fieldConfig);
    }
}
function consumeMissingField(wireType, buffer) {
    switch (wireType) {
        case constants_1.WireType.INVALID:
            throw new Error('Invalid WireType');
        case constants_1.WireType.VARINT:
            while (buffer.read() >= 128) {}
            break;
        case constants_1.WireType.FIXED64:
            for (let i = 0; i < 8; ++i) {
                buffer.read();
            }
            break;
        case constants_1.WireType.DELIMITED:
            const size = decode_1.BinaryDecoder.readUnsignedVarint32(buffer);
            for (let i = 0; i < size; ++i) {
                buffer.read();
            }
            break;
        default:
            throw new preconditions_1.UnreachableError(wireType);
    }
}
