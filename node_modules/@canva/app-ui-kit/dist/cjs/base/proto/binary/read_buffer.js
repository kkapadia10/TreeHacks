"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReadBuffer = void 0;
const internal_types_1 = require("../internal_types");
const floatBuffer = new DataView(new ArrayBuffer(8));
class ReadBuffer {
    constructor(stream) {
        this.chunkQueue = [];
        this.cursor = 0;
        this.bytesRead_ = 0;
        this.reader = stream.getReader();
        this.remaining = 0;
    }
    async loadBytes(amount, force = false) {
        while (this.remaining < amount) {
            const result = await this.reader.read();
            if (result.done) {
                break;
            }
            const value = result.value;
            if (value.length === 0) {
                continue;
            }
            this.remaining += value.length;
            this.chunkQueue.push(value);
        }
        if (force && this.remaining < amount) {
            throw new internal_types_1.ProtobufError('Insufficient data on stream.');
        }
    }
    get bytesRead() {
        return this.bytesRead_;
    }
    read() {
        if (this.remaining === 0) {
            throw new internal_types_1.ProtobufError('loadBytes not called before read.');
        }
        if (!this.currentChunk || this.cursor === this.currentChunk.length) {
            const nextChunk = this.chunkQueue.shift();
            if (!nextChunk) {
                throw new internal_types_1.ProtobufError('Insufficient data on stream.');
            }
            this.currentChunk = nextChunk;
            this.cursor = 0;
        }
        this.remaining -= 1;
        this.bytesRead_ += 1;
        return this.currentChunk[this.cursor++];
    }
    readFloat() {
        for (let i = 0; i < 8; ++i) {
            floatBuffer.setUint8(i, this.read());
        }
        return floatBuffer.getFloat64(0, true);
    }
}
exports.ReadBuffer = ReadBuffer;
